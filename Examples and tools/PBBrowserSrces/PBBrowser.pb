; ***************************************************************************;;                               PBBrowser;;                         By Zapman - March 2025;                      created with PureBasic 6.20;                           For Windows only.                      Global PBB_NumVersion$ = "1.01";; ***************************************************************************;; A special thank you to 'Cage' from the French PureBasic forum for his help and; support during testing of the first beta versions.; Other thank you to the English PureBasic forum members for their help during; debugging: highend, Axolotl, le_magn, AZJIO, Michael Vogel, Denis and all others.;; To Do: Search by regular expressions (RegEx) ;;        Filter settings in the 'Found in...' panel: ☑ Exclude comments and strings;                                                    ☑ Detail the results ;;        In 'PBBrowser help and tools': - a new tool to generate a list of procedures declarations (Declare);                                         from the list of procedures ;;        List of strings included in code files (probably by RegEx) ;;        Spanish and german versions ;;        Mac OS and Linux versions.;;; *********************** FIXED WITH THIS VERSION: ************************;; ProcedureC, ProcedureDLL and ProcedureCDLL are now recognized as "Procedure";;;;#NomProg = "PBBrowser";IncludePath  "PBBrowser resources/Source Codes/"XIncludeFile "PBBrowserDeclarations.pb"XIncludeFile "PBBrowserInitialize.pb";If #PB_Compiler_64Bit  PBB_NumVersion$ + " x64"ElseIf #PB_Compiler_32Bit  PBB_NumVersion$ + " x86"EndIf;CompilerIf #PB_Compiler_Unicode  PBB_NumVersion$ + " - Unicode"CompilerElse  PBB_NumVersion$ + " - NonUnicode"CompilerEndIf;; **********************************************************************************;;-          Miscellaneous procedures, used by various parts of the program;; **********************************************************************************;Procedure.s FullAddressToRelativeAddress(Addr$, RefAddr$)  ;  ; Designed for calculating IncludedFile values, this procedure converts the address  ; of a page on the disk ("C:\My Documents\WebFolder\sub_folder\filename.htm", for example)  ; into a relative address for this page ("sub_folder/filename.htm").  ;  ; The RefAddr$ variable (reference address) must contain the path to the file containing 'IncludedFile Addr$'.  ;  Protected PosInText  ;  If Left(Addr$, 1) <> Left(RefAddr$, 1)    ; The two adress are not on the same disk. Calculation is not possible.    ProcedureReturn Addr$  EndIf  PosInText = 1  RefAddr$ = ReplaceString(GetPathPart(RefAddr$), "\", "/")  RefAddr$ = ReplaceString(GetPathPart(RefAddr$), "//", "/")  Addr$ = ReplaceString(Addr$, "\", "/")  Addr$ = ReplaceString(Addr$, "//", "/")  ;  If Right(RefAddr$, 1) <> "/" : RefAddr$ + "/" : EndIf  If LCase(FastLeft(Addr$, 7)) <> "http://" And LCase(FastLeft(Addr$, 8)) <> "https://" And LCase(FastLeft(Addr$, 4)) <> "www." And FindString(FastLeft(Addr$, 3), ":")    While PosInText <= Len(RefAddr$) And FastMid(RefAddr$, PosInText, 1) = FastMid(Addr$, PosInText, 1) : PosInText + 1 : Wend ; determine the common root    While PosInText > 1 And FastMid(Addr$, PosInText - 1, 1) <> "/" : PosInText - 1 : Wend ; Go back up to / (the two names may have their first letters identical)    Addr$ = Right(Addr$, Len(Addr$) - PosInText + 1)    While RefAddr$      PosInText = FindString(RefAddr$, "/", PosInText)      If PosInText        Addr$    = "../" + Addr$        RefAddr$ = Right(RefAddr$, Len(RefAddr$) - PosInText)        PosInText = 0      Else        RefAddr$ = ""      EndIf    Wend  EndIf  ProcedureReturn Addr$EndProcedure;Procedure.s CorrectAddrSyntaxe(Adress$)  ;  ; Correct an adress$ syntaxe if it is not correct.  ; The way of interpreting syntax problems is adapted  ; to the PureBasic compiler way of doing the same.  ;  Protected mAdress$  ;  Adress$ = ReplaceString(Adress$, "/", "\")  Adress$ = ReplaceString(Adress$, "\.\", "\")  Repeat    mAdress$ = Adress$    Adress$ = ReplaceString(Adress$, "...\", "..\")    Adress$ = ReplaceString(Adress$, "\\", "\")  Until mAdress$ = Adress$  If Left(Adress$, 2) = ".\"    Adress$ = Mid(Adress$, 3)  EndIf  ProcedureReturn Adress$EndProcedure;Procedure.s RelativeAddressToFullAddress(RelAddr$, RefAddr$)  ;  ; Designed for decoding IncludedPath and IncludedFile values, this procedure converts the relative address  ; of a page ("sub_folder/filename.htm", for example) into a disk address.  ;  ; The RefAddr$ variable (reference address) must contain the path to the file containing 'IncludedFile RelAddr$'.  ;  ; Example:  ; If RelAddr$ contains a relative address (like "../DropUpLoad/create_menu.php")  ; and RefAddr$ contains a reference address (like "D:\LUC\Dropbox\RankSpiritDev\CSSMenuManager\CSSMenuManager.pb")  ; The returned value will be "D:\LUC\Dropbox\RankSpiritDev\DropUpLoad\create_menu.php".  ;  Protected NewPath$, NewAddr$, PosInText, pf  ;  RefAddr$ = CorrectAddrSyntaxe(RefAddr$)  RelAddr$ = CorrectAddrSyntaxe(RelAddr$)  ;  If FindString(Left(RelAddr$, 3), ":") ; The given address is not relative!    NewAddr$ = RelAddr$  Else    ;    NewPath$ = GetPathPart(RefAddr$)    ;    If RelAddr$      NewAddr$ = NewPath$ + RelAddr$    EndIf    ;    Repeat      PosInText = FindString(NewAddr$, "\..\")      ; The notation '..\' indicates moving up one level in the folder hierarchy.      If PosInText        pf = PosInText + 4        ; Move up one level...        While PosInText And FastMid(NewAddr$, PosInText - 1, 1) <> "\" : PosInText - 1 : Wend        If PosInText And pf <= Len(NewAddr$)          ; and remove the level along with '..\'.          NewAddr$ = FastLeft(NewAddr$, PosInText - 1) + FastMid(NewAddr$, pf)        ElseIf PosInText          NewAddr$ = FastLeft(NewAddr$, PosInText - 1)          PosInText = 0        EndIf      EndIf    Until PosInText = 0  EndIf  ProcedureReturn NewAddr$EndProcedure;Procedure.s ListProjectsFiles(ProjectAddr$)  ;  ; Explore the project file 'ProjectAddr$' and return its list of files.  ;  Protected ListOfFiles$, PosInProject  Protected ProjectDescr$ = FileToText(ProjectAddr$)  ;  PosInProject = 0  Repeat    PosInProject = FindString(ProjectDescr$, "<file name", PosInProject)    If PosInProject      PosInProject + Len("<file name")      mPosInProject = PosInProject      ;      ; Look for first quote after "<file name":      PosInProject = FindString(ProjectDescr$, #DOUBLEQUOTE$, PosInProject)      If PosInProject And (PosInProject - mPosInProject) < 10        PosInProject + 1        ;        ; Look for second quote after "<file name":        pf = FindString(ProjectDescr$, #DOUBLEQUOTE$, PosInProject)        If pf          ;          ; Extract FileName between the two quote char:          FileName$ = FastMid(ProjectDescr$, PosInProject, pf - PosInProject)          If FindString(Left(FileName$, 3), ":") = 0            ; File address is relative.            FileName$ = RelativeAddressToFullAddress(FileName$, ProjectAddr$)          EndIf          ;          ListOfFiles$ + FileName$ + #CR$        EndIf      EndIf    EndIf  Until PosInProject = 0  ProcedureReturn ListOfFiles$EndProcedure;Procedure ManageWaitingWindow(PriorityMode = #WorkInBackGround, ToPrint$ = "", EProgBarTitle$ = "")  ;  ; This procedure is intended to display a waiting window for procedures  ; whose execution takes a long time. Managing this system is quite simple:  ; Simply add the line 'ManageWaitingWindow(MyAppWindow)' in a loop  ; so that the window automatically appears if the loop execution takes  ; more than 300 milliseconds.  ;  ; 'CloseWaitingWindow()' should be called to close this waiting window  ; when the execution loop is completed.  ;  ; For this to work, 'WhiteBoxOverWindow' must have been called after  ; the main application window ('MainWindow') has been created.  ;  ; After 300 milliseconds from the first call, a white overlay is displayed  ; in front of the main window.  ; After 500 milliseconds from the first call, a small window is created  ; at the center of the main window with the message GetTextFromCatalogPB("SearchInProgress").  ; After 500 milliseconds, and every 350 milliseconds, the message is followed  ; by an increasing number of dots.  ;  ; In the current version of PBBrowser, the waiting window no longer has a chance  ; to appear, since all operations related to deep exploration are split into  ; 200 ms slices and no longer block user navigation.  ; This waiting window system was developed for previous versions and was retained  ; for possible future program evolution.  ;  ; The first part of this procedure is still useful, however: it updates  ; the text of GPBBGadgets\TProgressBar to display, during the exploration,  ; the type of item currently being examined. 'EProgBarTitle$' is the parameter  ; that should contain the text to display; This text is updated every 200 ms.  ;  Shared PBBWaitingGadget  ;  Static LastUpdateForWaitingMS, LastValueForToPrint$, LastUpdateForPBarTitleMS  ;  If EProgBarTitle$ And IsGadget(GPBBGadgets\TProgressBar) And ElapsedMilliseconds() - LastUpdateForPBarTitleMS > 200    If Len(EProgBarTitle$) > 15      ; 17 is the maximum length that GPBBGadgets\TProgressBar can display.      SetGadgetText(GPBBGadgets\TProgressBar, EProgBarTitle$)    Else      SetGadgetText(GPBBGadgets\TProgressBar, GetTextFromCatalogPB("Exploration") + " " + EProgBarTitle$)    EndIf    LastUpdateForPBarTitleMS = ElapsedMilliseconds()    ;    ; The following lines allow to know the duration of each type of operation    ; during deep exploration. This allowed me to optimize the procedures    ; used for this task.    ;;    Static LastEProgBarTitle$, TotTPBTime;     If LastEProgBarTitle$ <> EProgBarTitle$;       If LastEProgBarTitle$;         Debug LastEProgBarTitle$ + " : "+Str(ElapsedMilliseconds()-TotTPBTime)+" ms.";       EndIf;       LastEProgBarTitle$ = EProgBarTitle$;       TotTPBTime = ElapsedMilliseconds();     EndIf  EndIf  ;  If PriorityMode <> #WorkInBackGround    If ElapsedMilliseconds() - LastUpdateForWaitingMS > 1000      ; Whoa! LastUpdateForWaitingMS hasn't been updated for a while.      ; We're likely in the first call of this procedure within a loop.      ; Simply update LastUpdateForWaitingMS:      LastUpdateForWaitingMS = ElapsedMilliseconds()    Else      If PBBWaitingGadget = 0 And ElapsedMilliseconds() - LastUpdateForWaitingMS > 500        ; The waiting window is not yet open. Open it:        DisablePBBWindow()        If ToPrint$ = ""          ToPrint$ = GetTextFromCatalogPB("SearchInProgress")        EndIf        LastValueForToPrint$ = ""        PBBWaitingGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, ToPrint$)        LastUpdateForWaitingMS = ElapsedMilliseconds()        Delay(1)      ElseIf IsGadgetHidden(GPBBGadgets\IWhiteOver) And (ElapsedMilliseconds() - LastUpdateForWaitingMS) > 300        HideGadget(GPBBGadgets\IWhiteOver, #False) ; Displays a white overlay in front of the main window        Delay(1)      ElseIf ElapsedMilliseconds() - LastUpdateForWaitingMS > 350 And IsGadget(PBBWaitingGadget)        ; The waiting window is open. Update the message:        If LastValueForToPrint$ = ToPrint$ Or ToPrint$ = ""          ToPrint$ = GetGadgetText(PBBWaitingGadget)        Else          LastValueForToPrint$ = ToPrint$          ToPrint$ + #CR$        EndIf        ToPrint$ = ReplaceString(ToPrint$, #CR$, #CR$ + ".")        SetGadgetText(PBBWaitingGadget, ToPrint$)        LastUpdateForWaitingMS = ElapsedMilliseconds()        Delay(1)      EndIf    EndIf  EndIfEndProcedure;Procedure CloseWaitingWindow()  Shared PBBWaitingGadget  ;  If PBBWaitingGadget    ; If the waiting window is open, close it.    DestroyParentWindow(PBBWaitingGadget)    PBBWaitingGadget = 0  EndIf  EnablePBBWindow()EndProcedure;Procedure.s ExtractSectionArroundExpression(*CodeString.String, Expression$, posInCode, KeepComment = #False, CheckInCode = #CheckAll | #CheckOneKeyWordOnly, FMode = #PB_String_CaseSensitive)  ;  ; Verifies that Expression$ is not within quotes or comments  ; in the code contained in *CodeString.  ; Then extracts the line section containing the expression,  ; optionally removing parts of the line before And after ":".  ;  ; If posInCode is zero at the time of calling the procedure, Expression$ is searched  ; within *CodeString, otherwise posInCode should contain this position.  ;  ; If KeepComment = #True, a copy of the comment that was in the line  ; is saved in the shared variable 'PBBLComment$'.  ;  ; If CheckInCode = #NoCheck, the task is done assuming it’s outside quotes or comments.  ;  Shared PBBLComment$  ;  Protected posdepR, posEndR, posInLine, BreakInLine, mBreakInLine, FullLine.String  ;  If posInCode = 0    posInCode = FindInPBPointedCode(*CodeString, Expression$, 1, CheckInCode, FMode)  EndIf  If PosInCode    ; Move up to start of line:    posdepR = posInCode    FastFindPrecReturn(*CodeString\s, posdepR)    posdepR + 1    ; Find the end of line:    posEndR = FindString(*CodeString\s, #CR$, posInCode)    If posEndR = 0 : posEndR = Len(*CodeString\s) + 1 : EndIf    ; Extract the complete line:    FullLine\s = FastMid(*CodeString\s, posdepR, posEndR - posdepR)    ; Check that the expression found is surrounded by valid separators    ; and if CheckInCode = #CheckAll, also ensure it is not    ; within quotes or comments.    posInLine = FindInPBPointedCode(FullLine, Expression$, 1, CheckInCode, FMode)    If PosInLine      ; If the line has multiple segments separated by ":",      ; remove the segments before the one of interest:      BreakInLine = 0      Repeat        mBreakInLine = BreakInLine        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ":", BreakInLine + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ":", BreakInLine + 1)        EndIf      Until BreakInLine = 0 Or BreakInLine > PosInLine      If mBreakInLine        FullLine\s = FastMid(FullLine\s, mBreakInLine + 1)      EndIf      ;      ; Remove any trailing segments and comments.      If KeepComment = #True        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ";", 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ";", 1)        EndIf        If BreakInLine          PBBLComment$ = FastMid(FullLine\s, BreakInLine)          FullLine\s = FastLeft(FullLine\s, BreakInLine - 1)        Else          PBBLComment$ = ""        EndIf        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ":", 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ";", 1)        EndIf      Else        BreakInLine = FindInPBPointedCode(FullLine, ":,;", 1, #CheckOnlyComAndQuote)      EndIf      If BreakInLine        FullLine\s = FastLeft(FullLine\s, BreakInLine - 1)      EndIf      FullLine\s = Trim(FullLine\s)    Else      FullLine\s = ""    EndIf  Else    FullLine\s = ""  EndIf  ProcedureReturn FullLine\sEndProcedure;Procedure.s PurifyElementName(ElementName$)  ;  ; This procedure removes parentheses and the element type mention  ; (for variables) to ensure the element is properly found  ; in lists and in the code. The element name is returned in LCase  ; because all searches are done on LCase versions of the code and  ; lists.  ;  Protected pp, ToDel$, ct, DChar$  ;  If ElementName$    ToDel$ = ":(.\" + #SpecialSpace$ + #NonBreakableSpace$    While FindString(ToDel$ + " ", FastLeft(ElementName$, 1))      ElementName$ = FastMid(ElementName$, 2)    Wend    For ct = 1 To Len(ToDel$)      DChar$ = FastMid(ToDel$, ct, 1)      pp = FindString(ElementName$, DChar$)      If pp        ElementName$ = Trim(FastLeft(ElementName$, pp - 1))      EndIf    Next  EndIf  ProcedureReturn LCase(ElementName$)EndProcedure;Procedure CheckIfElementExistsInList(ElementNameLCase$, TypeOfElement)  ;  ; Checks if the element named 'ElementName$' already exists in the 'ElementsList()' list.  ;  Protected Parentheses, ExistingElement = -1  ;  If ListSize(ElementsList()) > 0    If TypeOfElement = #DoManualSearch      ForEach ElementsList()         If FastLeft(ElementsList()\NameLCase, Len(ElementNameLCase$)) = ElementNameLCase$          ExistingElement = ListIndex(ElementsList())          Break        EndIf      Next    ElseIf TypeOfElement = #FindAnyType Or TypeOfElement = #FindFollowedByParentheses Or TypeOfElement = #FindNotFollowedByParentheses      ForEach ElementsList()        If ElementsList()\NameLCase = ElementNameLCase$          ;          If TypeOfElement = #FindAnyType            ExistingElement = ListIndex(ElementsList())            Break          Else            Parentheses = 0            Select ElementsList()\Type              Case #PBBProcedure, #PBBNativeFunction                Parentheses = 1              Case #PBBVariable                If FindString(ElementsList()\VariableSpecies, "List") Or FindString(ElementsList()\VariableSpecies, "Array") Or FindString(ElementsList()\VariableSpecies, "Map")                  Parentheses = 1                EndIf            EndSelect            If (Parentheses And TypeOfElement = #FindFollowedByParentheses) Or (Parentheses = 0 And TypeOfElement = #FindNotFollowedByParentheses)               ExistingElement = ListIndex(ElementsList())              Break            EndIf          EndIf        EndIf      Next    Else      ForEach ElementsList()        If ElementsList()\Type = TypeOfElement And ElementsList()\NameLCase = ElementNameLCase$          ExistingElement = ListIndex(ElementsList())          Break        EndIf      Next    EndIf  EndIf  ;  ; Implicitly assumes there won’t be two elements with the same name,  ; as PureBasic doesn’t allow this unless they are different types  ; (e.g., you can have a structure and a procedure with the same name,  ; but not two structures with the same name).  ;  ; If a variable name is used both as global and protected, there will  ; be a confusion in results and later versions of PBBrowser should  ; solve that problem. But, for now, local variables are not listed  ; as 'elements'.  ;  ; Enumeration elements are a special case, as they might not have names.  ; Therefore, in the 'CompleteListOfAllElements()' procedure,  ; a unique name based on their position in the code is assigned  ; to identify them in lists.  ProcedureReturn ExistingElementEndProcedure;Procedure GetTypeOfExpression(Expression$, *FoundDetails.LastSearchDetails = 0, TypeOfSearch = #DoManualSearch)  ;  ; Searches for 'Expression$' in various element lists as well  ; as in native functions and PureBasic keywords, returning the type of expression found.  ; The type will be one of the values of the 'PBBTypes' enumeration  ; defined in PBBrowersDeclaration.pb  ;  Protected FIL, ne  Protected ctype = -1 ; Return value  ;  Protected found = -1  ;  Protected mExpression$ = Expression$  Protected Parentheses = 0  ;  ;  If Expression$    If FindString(Expression$, "(") > 1      Parentheses = 1      If TypeOfSearch = #DoManualSearch        TypeOfSearch = #FindFollowedByParentheses      EndIf    EndIf    Expression$ = PurifyElementName(Expression$)    If Expression$      ;      ; Explore all element lists until the expression is found in one of them.      ;      ctype = 0      ;      found = CheckIfElementExistsInList(Expression$, TypeOfSearch)      ;      If found > -1        Expression$ = ElementsList()\Name        ctype = ElementsList()\Type      Else        If FastLeft(Expression$, 1) = "#"          ctype = #PBBConstante        Else          ctype = -1          ; Search in native function list, correcting case if found.          If TypeOfSearch <> #FindNotFollowedByParentheses            FIL = FindString(PBFunctionListLCase$, "/" + Expression$ + #CR$)            If FIL              Expression$ = FastMid(PBFunctionList$, FIL + 1, Len(Expression$))              ctype = #PBBNativeFunction              found = 1            EndIf          EndIf          If found <> 1            ; Search in PureBasic keywords.            For ne = 1 To ArraySize(PBBasicKeyword$())              If PBBasicKeywordLCase$(ne) = Expression$                ; Correct case.                Expression$ = PBBasicKeyword$(ne)                ctype = #PBBBasicKeyword                found = 1                Break              EndIf            Next          EndIf        EndIf      EndIf    EndIf  EndIf  ;  If *FoundDetails    If found > -1      *FoundDetails\ElementType = ctype      *FoundDetails\ElementName$ = Expression$      ;      If ctype = #PBBVariable        *FoundDetails\TypeName$ = ElementsList()\VariableSpecies      ElseIf ctype <> -1        *FoundDetails\TypeName$ = GetTextFromCatalogPB(PBBTypeNames$(ctype))      EndIf    Else      *FoundDetails\ElementType = -1      *FoundDetails\ElementName$ = mExpression$      *FoundDetails\TypeName$ = ""    EndIf  EndIf  ProcedureReturn ctypeEndProcedure;; **********************************************************************************;;-           Procedures to store an furnish a specifique element code;; **********************************************************************************;Structure ElementContentStruct  EC_FSource$  EC_LCase.i  EC_StartingPos.i  EC_Content.StringEndStructure;NewList ElementContentListing.ElementContentStruct();Procedure GetPointedElementContentFromFile(FSource$, ElementStartingPos, ElementEndingPos, ReturnLCase = #False)  ;  ; Extracts from the file FSource$ the code segment marked by the positions  ; given as parameters.  ;  ; To save time, the excerpts are kept in memory cache.  ; The return value is a pointer to a String and this pointer  ; remains valid outside the procedure because the string is kept  ; in a 'Shared' array.  ;  Shared ElementContentListing()  ;  Protected *SPointer.string, LS  ;  Protected Found = 0  ForEach ElementContentListing()    If ElementContentListing()\EC_FSource$ = FSource$ And ElementContentListing()\EC_StartingPos = ElementStartingPos And ElementContentListing()\EC_LCase = ReturnLCase      Found = 1      Break    EndIf  Next  ;  If Found = 0    AddElement(ElementContentListing())    ElementContentListing()\EC_FSource$ = FSource$    ElementContentListing()\EC_LCase = ReturnLCase    ElementContentListing()\EC_StartingPos = ElementStartingPos    *SPointer.string = GetPointedCodeFromFile(FSource$, ReturnLCase)    If *SPointer      LS = Len(*SPointer\s)      If ElementStartingPos < LS And ElementEndingPos < LS And *SPointer\s <> "Error"        ElementContentListing()\EC_Content\s = FastMid(*SPointer\s, ElementStartingPos, ElementEndingPos - ElementStartingPos)      Else        ElementContentListing()\EC_Content\s = "Error"      EndIf    EndIf  EndIf  ProcedureReturn ElementContentListing()\EC_Content  ;EndProcedure;Procedure EraseObsoleteElementsContents(FileName$)  ;  Shared ElementContentListing()  ;  ForEach ElementContentListing()    If ElementContentListing()\EC_FSource$ = FileName$      ; Requests the deletion of all code excerpts      ; stored in memory for the file 'FileName$'      DeleteElement(ElementContentListing())    EndIf  NextEndProcedure;;; **********************************************************************************;;-           Procedures to establish the list of files of the project;; **********************************************************************************;Procedure ExtractIncludePathOrFileName(*SearchStringLCase.String, *SearchString.String, ToSearch$, PosInCode, *PathOrFileName.String, *ValueType.String)  ;  ; Searchs into '*SearchString' the mentions contained by 'ToSearch$'  ; and returns the position where one of them has been found.  ;  ; 'ToSearch$' can contain a LCase list as "includepath,includefile,xincludefile,includebinary".  ; '*ValueType' is set with the found mention.  ; '*PathOrFileName' is set with the InQuote-word following the mention.  ;  ; example of use:  ;   PosInCode = ExtractIncludePathOrFileName(*SearchString, "includepath,includefile,xincludefile,includebinary", PosInCode, @PathOrFileName, @ValueType)  ; if 'IncludeFile "MyFile.pb"' exists into *SearchString\s  ; -> PosInCode will contain the position  ; -> PathOrFileName\s will contain '"MyFile.pb"'  ; -> ValueType\s will contain 'IncludeFile'.  ;  Protected mp  ;  PosInCode = FindInPBPointedCode(*SearchStringLCase, ToSearch$, PosInCode)  If PosInCode    mp = PosInCode    If FindString(ToSearch$, ",") = 0      PosInCode + Len(ToSearch$) - 1    EndIf    PosInCode = FirstOccurrenceOfChar(*SearchString\s, " (" + #DOUBLEQUOTE$, PosInCode)    If PosInCode      *ValueType\s = FastMid(*SearchString\s, mp, PosInCode - mp)      *PathOrFileName\s = ExtractSectionArroundExpression(*SearchString, *ValueType\s, mp)      *PathOrFileName\s = FastMid(*PathOrFileName\s, Len(*ValueType\s) + 1)      *ValueType\s = LCase(*ValueType\s)      ;    EndIf  EndIf  ProcedureReturn PosInCodeEndProcedure;Procedure.s CompleteListOfFiles(FileName$, ParentFileName$ = "", NoLine$ = "", PriorityMode = #WorkInBackGround, ErrorWhileReadingFile$ = "")  ;  ; From a PureBasic file address,  ; lists included files (by IncludeFile or XIncludeFile).  ;  ; The result is stored in the string 'TempListOfFiles$'  ; as 'IncludedFileAddress + #TAB$ + 'IncludingFileAddress' + #CR$  ;  ; This function also establish a BinaryFiles list which is  ; stored in 'PBBListOfBinaries$'.  ;  Shared TempListOfFiles$, HighestParent$  Static ConcatenedCode.String  Static ConcatenedCodeLCase.String  ;  Structure ConstantStruct    ConstantName$    ConstantValue$  EndStructure  ;  Static NewList Constants.ConstantStruct()  ;  If TempListOfFiles$ = ""    ; Exploration is begginning or begginning again.    ; Initialize variables:    ClearList(Constants())    ConcatenedCode\s = ""    ConcatenedCodeLCase\s = ""    PBBListOfBinaries$ = ""  EndIf  ;  Protected *SearchString.String, *SearchStringLCase.string  Protected PosInCode, Included$, IncludePathMem$  Protected PathOrFileName.String, ValueType.String  Protected PosConst, pf, mpf, ConstName$, PosInConcatenedCode  Protected ConstReplaced, ConstDeclaration$, mLine$, Cont  Protected nbSame, mPosConst, CLine$, PosInFileList, PLine$  Protected ErrorDetails$  ;  If FileName$    If FileSize(FileName$) < 2      If FindString(ErrorWhileReadingFile$, FileName$ + #CR$) = 0        ErrorDetails$ + FileName$        If ParentFileName$          ErrorDetails$ + #CR$ + "  -> Included in: " + ParentFileName$ + " line " + NoLine$        EndIf        ErrorWhileReadingFile$ + ErrorDetails$ + #CR$      EndIf    Else      CLine$ = FileName$ + #TAB$ + ParentFileName$ + #TAB$ + NoLine$ + #TAB$      PosInFileList = FindString(TempListOfFiles$, FileName$ + #TAB$, 0)      If PosInFileList        ; FileName$ allready exists in TempListOfFiles$.        ; If it's not referenced as an Included file, add the reference:        If ParentFileName$ And NoLine$          pf = FindString(TempListOfFiles$, #CR$, PosInFileList)          PLine$ = FastMid(TempListOfFiles$, PosInFileList, pf - PosInFileList)          If FindString(PLine$, ParentFileName$) = 0            TempListOfFiles$ = Left(TempListOfFiles$, PosInFileList - 1) + CLine$ + FastMid(TempListOfFiles$, pf)            If HighestParent$ = "" Or HighestParent$ = FileName$              HighestParent$ = ParentFileName$            EndIf          EndIf        EndIf      Else        TempListOfFiles$ + CLine$ + #CR$        *SearchString = GetPointedCodeFromFile(FileName$, #False)        *SearchStringLCase = GetPointedCodeFromFile(FileName$, #True)        ConcatenedCode\s + *SearchString\s        ConcatenedCodeLCase\s + *SearchStringLCase\s        ManageWaitingWindow(PriorityMode)        PosInCode = 0        Repeat          PosInCode = ExtractIncludePathOrFileName(*SearchStringLCase, *SearchString, "includepath,includefile,xincludefile,includebinary", PosInCode + 1, @PathOrFileName, @ValueType)          If PosInCode            ;            ; Look if there are constant names into the address:            ;            ; [NOTE] : later, PBBrowser will establish a complete list of constants with            ; their values. But, at the moment, it's not done, because PBBrowser            ; needs first to have the complete list of files of the examined project            ; to establish te list of its 'elements' (as constants). So, the lines just            ; following will only work on constants needed by the 'include' declarations.            nbSame = 0            PosConst = 0            Repeat              mPosConst = PosConst              PosConst = FindInPBPointedCode(PathOrFileName, "#", PosConst)              If mPosConst = PosConst                ; A constant value can contain constant names. So, it is possible that                ; the loop stays many times a the same position.                ; But if, by exception, a constante value is equal to the name of a constante that                ; has the first one as value, we need to get out of that trap:                nbSame + 1                If nbSame = 20                  PosConst = 0                  ErrorWhileReadingFile$ + GetTextFromCatalogPB("ConstantNameError") + " " + ValueType\s + " " + PathOrFileName\s + #CR$                EndIf              Else                nbSame = 0              EndIf              If PosConst                Cont = 1                ; Extract the constant name:                pf = FirstOccurrenceOfChar(PathOrFileName\s, ListPBSep$, PosConst)                mpf = pf                If pf                  While Mid(PathOrFileName\s, pf, 1) = " " : pf + 1 : Wend                  ; Check if the "#" char is really the beggining of a constant name.                  ; If so, the constant name must be at the end of the line or must                  ; be followed by the '+' signe. Else, the '#' is just a part of the filename.                  If pf <= Len(PathOrFileName\s) And Mid(PathOrFileName\s, pf, 1) <> "+" And Mid(PathOrFileName\s, pf, 1) <> #CR$                    Cont = 0                    PosConst = pf                  EndIf                Else                  pf = Len(PathOrFileName\s) + 1                EndIf                If Cont                  ConstName$ = FastMid(PathOrFileName\s, PosConst, mpf - PosConst)                  ;                  ; Try to replace the constant name by its value:                  If ListSize(Constants()) > 0                    ForEach Constants()                      If LCase(Constants()\ConstantName$) = LCase(ConstName$)                        PathOrFileName\s = Left(PathOrFileName\s, PosConst - 1) + Constants()\ConstantValue$ + Mid(PathOrFileName\s, pf)                        Cont = 0                        Break                      EndIf                    Next                  EndIf                Else                  PosConst + 1                EndIf                ;                If Cont                  ;                  ; Because this constant is not allready recorded, we must                  ; look for the constant declaration in the concatened code                  ; and get its value:                  PosInConcatenedCode = 0                  ConstReplaced = 0                  Repeat                    PosInConcatenedCode = FindInPBPointedCode(ConcatenedCodeLCase, LCase(ConstName$), PosInConcatenedCode)                    If PosInConcatenedCode                      ; Extract the line where the constant name has been found:                      ConstDeclaration$ = ExtractSectionArroundExpression(ConcatenedCode, ConstName$, PosInConcatenedCode, #False, #CheckAll | #CheckOneKeyWordOnly, #PB_String_NoCase)                      ; Check that the constant name is in first position into the line:                      If LCase(FastLeft(ConstDeclaration$, Len(ConstName$))) = LCase(ConstName$)                        ; Remove the constant name from 'ConstDeclaration$':                        ConstDeclaration$ = Trim(FastMid(ConstDeclaration$, Len(ConstName$) + 1))                        ; Check that the constant name is followed by "=":                        If Left(ConstDeclaration$, 1) = "="                          ; Remove the "=" char from 'ConstDeclaration$':                          ConstDeclaration$ = Trim(FastMid(ConstDeclaration$, 2))                          ; Record the constant and its value in order to gain time:                          ; (if a constant is used many times, it needs to be defined                          ; only one time)                          AddElement(Constants())                          Constants()\ConstantName$ = ConstName$                          Constants()\ConstantValue$ = ConstDeclaration$                          ; Replace the constant name by its value in the 'Include' line:                          PathOrFileName\s = Left(PathOrFileName\s, PosConst - 1) + Constants()\ConstantValue$ + Mid(PathOrFileName\s, pf)                          ConstReplaced = 1                        EndIf                      EndIf                      PosInConcatenedCode + Len(ConstName$)                    EndIf                  Until PosInConcatenedCode = 0 Or ConstReplaced                  If ConstReplaced = 0                    ;AlertInPBBWindow(GetTextFromCatalogPB("UnsolvedFileName") + " " + ValueType\s + " " + PathOrFileName\s + ".")                    ErrorWhileReadingFile$ + GetTextFromCatalogPB("ConstantNameError") + " " + ValueType\s + " " + PathOrFileName\s + #CR$                    PosInConcatenedCode + Len(ConstName$)                    PosConst + Len(ConstName$)                  EndIf                EndIf              EndIf            Until PosConst = 0            ;            ; Calculates the address if it is composed of several parts:            ;            ; TakeOff parentheses:            FindReplaceInPBPointedCode(PathOrFileName, "(", "")            FindReplaceInPBPointedCode(PathOrFileName, ")", "")            PathOrFileName\s = Trim(PathOrFileName\s)            ;            ; Delete spaces arround the "+" character:            Repeat              mLine$ = PathOrFileName\s              FindReplaceInPBPointedCode(PathOrFileName, " +", "+", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)              FindReplaceInPBPointedCode(PathOrFileName, "+ ", "+", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)            Until PathOrFileName\s = mLine$            ;            ; Replace '"+"' by nothing            PathOrFileName\s = ReplaceString(PathOrFileName\s, #DOUBLEQUOTE$ + "+" + #DOUBLEQUOTE$, "")            ; Replace '"' by nothing            PathOrFileName\s = ReplaceString(PathOrFileName\s, #DOUBLEQUOTE$, "")            ;            If ValueType\s = "includepath"              IncludePathMem$ = PathOrFileName\s              If Right(IncludePathMem$, 1) <> "/" And Right(IncludePathMem$, 1) <> "\"                IncludePathMem$ + "\"                ; [NOTE] : IncludePathMem$ can be used several times by many 'Include' declarations                ; following its own declaration in the same file.                ; But it is not saved as a 'Static' data, because each path is calculated relatively                ; to the file address of the file using it. When a new code file is open by the                ; compiler, precedent IncludePath declaration are not used.              EndIf            ElseIf ValueType\s = "includebinary"              Included$ = RelativeAddressToFullAddress(IncludePathMem$ + PathOrFileName\s, FileName$)              If FindString(PBBListOfBinaries$, Included$ + #TAB$, 0) = 0                NoLine$ = Str(CountString(FastMid(*SearchString\s, 1 , PosInCode), #CR$) + 1)                PBBListOfBinaries$ + Included$ + #TAB$ + FileName$ + #TAB$ + NoLine$ + #CR$              EndIf            Else ; Include or XInclude              Included$ = RelativeAddressToFullAddress(IncludePathMem$ + PathOrFileName\s, FileName$)              NoLine$ = Str(CountString(FastMid(*SearchString\s, 1 , PosInCode), #CR$) + 1)              ErrorWhileReadingFile$ = CompleteListOfFiles(Included$, FileName$, NoLine$, PriorityMode, ErrorWhileReadingFile$) ; Recursive call.            EndIf          EndIf        Until PosInCode = 0      EndIf    EndIf  EndIf  ProcedureReturn ErrorWhileReadingFile$EndProcedure;Procedure.s SetListOfFiles(FileName$, PriorityMode = #WorkInBackGround)  ;  ; From a PureBasic file address,  ; lists the files included by IncludeFile or XIncludeFile recursively,  ; OR  ; if the file is a project, establish the list of code files of the project.  ;  ; The result is stored in the global variable 'PBBListOfFiles$'  ; as 'IncludedFileAddress + #TAB$ + IncludingFileAddress + #TAB$ + NoLine + #TAB$ + #CR$  ;  ; This function also establish a BinaryFiles list which is  ; stored in 'PBBListOfBinaries$'.  ;  Shared TempListOfFiles$, HighestParent$  ;  Protected ErrorWhileReadingFile$, CurrentProject$, StartingFile$  Protected *FirstFileContent.String  Protected mFileName$, FName$, AdrFP$, PosInCode, p, pf  Protected PosInFileList, LineC$, ProjectFiles$, ProjectDescr$  ;  TempListOfFiles$ = ""  ;  If FileName$    If LCase(GetExtensionPart(FileName$)) = "pb" Or LCase(GetExtensionPart(FileName$)) = "pbi"      ;      ; The user has open a .pb or .pbi files.      ;      ; Look if a project is currently open into the IDE:      CurrentProject$ = GetPBPOpenFile(PureBasicProgAddr$)      If FileSize(CurrentProject$) > 1        ; Look if the file given as a parameter belongs to the project:        ProjectFiles$ = ListProjectsFiles(CurrentProject$)        PosInFileList = 0        Repeat          PosInFileList + 1          FName$ = StringField(ProjectFiles$, PosInFileList, #CR$)          If FName$ = FileName$            ; Filename$ belongs to the open project.            ; The whole project will be examined.            FileName$ = CurrentProject$          EndIf        Until FName$ = ""      EndIf    EndIf    If LCase(GetExtensionPart(FileName$)) = "pbp"      ;      ; The user has open a projet file or a project containing      ; the open file has been found.      ;      ; Integrate all the code files listed in the project:      ProjectFiles$ = ListProjectsFiles(FileName$)      StartingFile$ = GetFilePart(FileName$)      HighestParent$ = ""      PosInFileList = 0      Repeat        PosInFileList + 1        FName$ = StringField(ProjectFiles$, PosInFileList, #CR$)        If LCase(GetExtensionPart(FName$)) = "pb" Or  LCase(GetExtensionPart(FName$)) = "pbi"          ErrorWhileReadingFile$ = CompleteListOfFiles(FName$, "", "", PriorityMode, ErrorWhileReadingFile$)        EndIf      Until FName$ = ""      ; Identify the main file:      ProjectDescr$ = FileToText(FileName$)      p = FindString(ProjectDescr$, "<section name=" + #DOUBLEQUOTE$ + "targets")      If p        p = FindString(ProjectDescr$, "<inputfile value=" + #DOUBLEQUOTE$, p)        If p          p + Len("<inputfile value=" + #DOUBLEQUOTE$)          pf = FindString(ProjectDescr$, #DOUBLEQUOTE$, p)          FName$ = Mid(ProjectDescr$, p, pf - p)          FileName$ = RelativeAddressToFullAddress(FName$, FileName$)        EndIf      EndIf      If p = 0 Or FileName$ = ""        ; Project has no registered main file. Choose the HighestParent found.        FileName$ = HighestParent$      EndIf      If ErrorWhileReadingFile$        ErrorWhileReadingFile$ + "  --> Listed in project " + GetFilePart(FileName$) + #CR$      EndIf    Else      ;      ; The user has open a .pb or .pbi files.      ;      ; Create the file list by examining 'IncludedFile' mentions:      *FirstFileContent = GetPointedCodeFromFile(FileName$, #False)      If *FirstFileContent\s = ""        ; The file is empty or non-existent        SetGadgetText(GPBBGadgets\Adr_gadget, "")        ProcedureReturn FileName$      Else        ;        ; Check if the file whose address had been received has as a parameter        ; as 'Main File' (see the 'Compiler/Compiler Options...' command        ; in the PureBasic editor).        mFileName$ = FileName$        AdrFP$ = ""        PosInCode = FindString(*FirstFileContent\s, #CR$ + "; UseMainFile = ")        If PosInCode          ;          ; The file has a 'Main File' parameter.          ; Use this main file to establish the list of files:          PosInCode + Len("; UseMainFile = ")          pf = FindString(*FirstFileContent\s, #CR$, PosInCode)          If pf = 0            pf = Len(*FirstFileContent\s) + 1          EndIf          AdrFP$ = Trim(FastMid(*FirstFileContent\s, PosInCode, pf - PosInCode))          AdrFP$ = RelativeAddressToFullAddress(AdrFP$, FileName$)          If FileSize(AdrFP$) > 2            FileName$ = AdrFP$          EndIf        EndIf        ;        ErrorWhileReadingFile$ = CompleteListOfFiles(FileName$, "", "", PriorityMode)        ;        If FindString(TempListOfFiles$, mFileName$) = 0          ; There is a problem!          ; It seems that the address we started with designated AdrFP$ as the main file,          ; but AdrFP$ does not include the original address in its list of included files.          ; Result: the starting address does not appear in TempListOfFiles$.          ; That's not good. Let's include the original address and any 'included' files.          FileName$ = mFileName$          ErrorWhileReadingFile$ = CompleteListOfFiles(FileName$, "", "", PriorityMode, ErrorWhileReadingFile$)        EndIf        ;        StartingFile$ = GetFilePart(FileName$)        ;        CloseWaitingWindow()      EndIf    EndIf  EndIf  If ErrorWhileReadingFile$ And ErrorWhileReadingFile$ <> "ListOfFiles error" + #CR$    AlertInPBBWindow(GetTextFromCatalogPB("ErrorWhileReadingFile") + #CR$ + ErrorWhileReadingFile$, GetTextFromCatalogPB("IncludedFileError"), 1, 0, 1)  EndIf  ;  ; Check if the new set of files is included by the old one :  ;  If TempListOfFiles$    PosInFileList = 0    Included = 1    Repeat       PosInFileList + 1      LineC$ = StringField(TempListOfFiles$, PosInFileList, #CR$)      If LineC$        If FindString(PBBListOfFiles$, StringField(LineC$, 1, #TAB$)) = 0          ; The new set includes a file wich is not included by the old set.          ; -> Update 'PBBListOfFiles$':          PBBListOfFiles$ = TempListOfFiles$          Included = 0          Break        EndIf      EndIf    Until LineC$ = ""    If Included = 0      SetGadgetText(GPBBGadgets\Adr_gadget, StartingFile$)    EndIf  Else    PBBListOfFiles$ = ""    SetGadgetText(GPBBGadgets\Adr_gadget, "")  EndIf  ;;   If ErrorWhileReadingFile$;     ProcedureReturn "ListOfFiles error";   Else    ProcedureReturn FileName$;  EndIfEndProcedure;; **********************************************************************************;;-        Procedures to establish the list of variables used by a procedure;; **********************************************************************************;Procedure.s ParseArguments(ArgList$)  ;  ; In an argument list such as arg1, arg2, arg"; etc.  ; this procedure will replace commas with the tab character (#TAB$).  ;  ; The operation is designed in such a way that if the arguments themselves  ; contain arguments (for example: arg1(a,b,c), arg2(d,e,f), arg3(g,h,i), etc.),  ; result ends up with arg1(a,b,c)#TAB$arg2(d,e,f)#TAB$arg3(g,h,i)#TAB$etc.  ;  Protected InQuote = 0, NbPar = 0, Pos, CChar  ;  For Pos = 1 To Len(ArgList$)    CChar = PeekC(@ArgList$ + (Pos - 1) * SizeOf(CHARACTER))    If CChar = 34 ; Quote      If InQuote = 1 : InQuote = 0 : Else : InQuote = 1 : EndIf    EndIf    If InQuote = 0      If CChar = Asc("(")        NbPar + 1      ElseIf CChar = Asc(")")        NbPar - 1      EndIf      If CChar = Asc(",") And NbPar = 0        PokeC(@ArgList$ + (Pos - 1) * SizeOf(CHARACTER), 9)      EndIf    EndIf  Next  ProcedureReturn ArgList$EndProcedure;Procedure DeleteCommentsAndSpacesFromPBCode(*SearchString.string, CleanSpaces = #True, EraseAllComments = #False)  ;  ; Removes unnecessary spaces (if CleanSpaces is #True)  ; and comments from the code.  ; If 'EraseAllComments' is #False, only lines containing only comments are removed.  ; Otherwise, all comments are removed.  ;  Protected mlen, PosInCode, pf, DoIt, posDepR, TestS$, nbg  ;  If CleanSpaces    ; The second loop could do the job of the first one,    ; but we save time by removing spaces 4 by 4 at the beginning.    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, "    ", " ")    Until mlen = Len(*SearchString\s)    ; Removing double spaces:    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, "  ", " ")    Until mlen = Len(*SearchString\s)    ; Removing spaces at the beginning of lines:    *SearchString\s = ReplaceString(*SearchString\s, #CR$ + " ", #CR$)    ; Removing double line breaks:    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, #CR$ + #CR$, #CR$)    Until mlen = Len(*SearchString\s)  EndIf  ;  ; Removing comments.  PosInCode = 0  Repeat    PosInCode = FindString(*SearchString\s, ";", PosInCode + 1)    If PosInCode = 1  Or (PosInCode > 1 And (EraseAllComments Or FastMid(*SearchString\s, PosInCode - 1, 1) = #CR$))      DoIt = 1      posdepR = PosInCode      FastFindPrecReturn(*SearchString\s, posdepR)      If PosInCode - posdepR > 0        TestS$ = Trim(FastMid(*SearchString\s, posdepR, PosInCode - posdepR))        If TestS$          ;          ; Check that the semicolon found is not inside quotes.          ;          nbg = CountString(TestS$, #DOUBLEQUOTE$)          If nbg & 1 ; Odd number of quotes.            DoIt = 0            PosInCode + 2          EndIf        EndIf      Else        ; Remove the preceding carriage return, if any.        If PosInCode > 1 : PosInCode - 1 : EndIf      EndIf      If DoIt        pf = FindString(*SearchString\s, #CR$, PosInCode + 1)        If pf          *SearchString\s = FastLeft(*SearchString\s, PosInCode - 1) + FastMid(*SearchString\s, pf)        EndIf      EndIf    ElseIf PosInCode      PosInCode = FindString(*SearchString\s, #CR$, PosInCode + 1)    EndIf  Until PosInCode = 0  Repeat    mlen = Len(*SearchString\s)    *SearchString\s = ReplaceString(*SearchString\s, #CR$ + #CR$, #CR$)  Until mlen = Len(*SearchString\s)  *SearchString\s = Trim(*SearchString\s)  If Left(*SearchString\s, 1) = #CR$    *SearchString\s = FastMid(*SearchString\s, 2)  EndIfEndProcedure;Procedure.s IncludeMacrosIntoProcedure(ElementName$, *ProcCode.String)  ;  ; This procedure will extract the code of the procedure 'ElementName$'  ; and produce new code that includes in the procedure's code  ; the code of any macros that are referenced, exactly as the  ; PureBasic compiler does during compilation.  ;  Shared ListOfMacro$  ;  Protected *SearchString.String, ProcCodeLCase.String, mLenProcCode  Protected *MacroCode.String, MacroCode$  Protected FileName$, ElementStartingPos, ElementEndingPos, ElementNameLCase$  Protected PosInCode, PARIL  Protected EOFLP, StartCallingParam, CallingParamList$, EndCallingParam  Protected EOFLM, MacroParamList$, EOFLM2, MacroCodeLCase$, MacroParam$, MacroParamValue$  Protected CallingParam$, PosParam  ;  ListOfMacro$ = #TAB$  ;  If ElementName$ And *ProcCode    ;    ; Clean up the procedure name for easier searching:    ElementName$ = PurifyElementName(ElementName$)    ;    ; Search for the procedure in the list of procedures:    ;    If CheckIfElementExistsInList(ElementName$, #PBBProcedure) > -1      FileName$           = ElementsList()\FileName      ElementStartingPos  = ElementsList()\StartingPos      ElementEndingPos    = ElementsList()\EndingPos      ; Retrieve the procedure code:      *SearchString = GetPointedElementContentFromFile(FileName$, ElementStartingPos, ElementEndingPos)      ;      ; Make a copy of the code, because it will be modified:      *ProcCode\s = *SearchString\s      ProcCodeLCase\s = LCase(*ProcCode\s)      ;      Repeat        ;        ; Store the length of the code, and repeat the following        ; as long as we detect any modifications to *ProcCode\s.        mLenProcCode = Len(*ProcCode\s)        ; It is possible that one macro calls another, so we need        ; to keep looping until there are no more nested macros.        ;        ; We will go through the list of macros to see if we find        ; the name of any macro in the procedure code.        ForEach ElementsList()          If ElementsList()\Type = #PBBMacro            ElementNameLCase$  = ElementsList()\NameLCase            ElementName$       = ElementsList()\Name            FileName$          = ElementsList()\FileName            ElementStartingPos = ElementsList()\StartingPos            ElementEndingPos   = ElementsList()\EndingPos            ;            PosInCode = 0            Repeat              PosInCode = FindInPBPointedCode(ProcCodeLCase, ElementNameLCase$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)              If PosInCode                ; Add the name of the macro to the list of macros found                ; in the code:                If FindString(ListOfMacro$, #TAB$ + ElementName$ + #TAB$) = 0                  ListOfMacro$ + ElementName$ + #TAB$                EndIf                ; We have found the name of the macro in the procedure's code.                ; Search for the end of the line:                EOFLP = FindInPBPointedCode(ProcCodeLCase, ":," + #CR$, PosInCode, #CheckOnlyComAndQuote)                If EOFLP = 0 : EOFLP = Len(ProcCodeLCase\s) + 1 : EndIf                ;                ; Check if the macro is called with parameters:                StartCallingParam = PosInCode + Len(ElementNameLCase$)                ; Skip over any spaces that follow the macro name:                While PeekC(@ProcCodeLCase\s + (StartCallingParam - 1) * SizeOf(CHARACTER)) = #Space : StartCallingParam + 1 : Wend                CallingParamList$ = ""                If PeekC(@ProcCodeLCase\s + (StartCallingParam - 1) * SizeOf(CHARACTER)) = Asc("(")                  ; The macro call has parameters.                  StartCallingParam + 1                  EndCallingParam = EOFLP                  ;                  ; From the end of the line, move backwards until reach the closing parenthesis:                  While EndCallingParam > StartCallingParam And PeekC(@ProcCodeLCase\s + (EndCallingParam - 1) * SizeOf(CHARACTER)) <> Asc(")") : EndCallingParam - 1 : Wend                  ; Extract the list of parameters:                  CallingParamList$ = FastMid(*ProcCode\s, StartCallingParam, EndCallingParam - StartCallingParam)                  CallingParamList$ = ParseArguments(CallingParamList$)                  ;                EndIf                ; Retrieve the macro code:                *MacroCode = GetPointedElementContentFromFile(FileName$, ElementStartingPos, ElementEndingPos)                ; Remove comments and unnecessary spaces:                DeleteCommentsAndSpacesFromPBCode(*MacroCode, #True, #True)                ;                ; Find the end of the first line:                EOFLM = FindInPBPointedCode(*MacroCode, ":," + #CR$, 1, #CheckOnlyComAndQuote)                ;                ; Find the start of the parameter list:                StartCallingParam = FindInPBPointedCode(*MacroCode, "(", 1, #CheckOnlyComAndQuote)                If StartCallingParam > EOFLM : StartCallingParam = 0 : EndIf                ;                If CallingParamList$ And StartCallingParam = 0                  AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), calling of " + ElementNameLCase$ + " is done with parametres, but this macro has no parametres!")                  ProcedureReturn                 EndIf                ;                MacroParamList$ = ""                If StartCallingParam                  StartCallingParam + 1                  EndCallingParam = EOFLM                  ;                  ; From the end of the line, move backwards until reach the closing parenthesis:                  While EndCallingParam > StartCallingParam And PeekC(@*MacroCode\s + (EndCallingParam - 1) * SizeOf(CHARACTER)) <> Asc(")") : EndCallingParam - 1 : Wend                  ; Extract the list of parameters                  MacroParamList$ = FastMid(*MacroCode\s, StartCallingParam, EndCallingParam - StartCallingParam)                  MacroParamList$ = ParseArguments(MacroParamList$)                EndIf                ;                EOFLM2 = FindInPBPointedCode(*MacroCode, "EndMacro", EOFLM) - 1                If EOFLM2 = 0                  AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), 'EndMacro' is missing in the code of " + ElementNameLCase$ + "!")                  ProcedureReturn                  EndIf                While FastMid(*MacroCode\s, EOFLM2, 1) = #CR$ Or FastMid(*MacroCode\s, EOFLM2, 1) = " "                  EOFLM2 - 1                Wend                ;                If EOFLM2 < EOFLM + 2                   AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), Macro code is missing: " + ElementNameLCase$ + ".")                  ProcedureReturn                  EndIf                ; Remove the first and last lines of the macro code and make a copy:                EOFLM + 1                MacroCode$ = Trim(FastMid(*MacroCode\s, EOFLM, EOFLM2 - EOFLM + 1))                ;                ; In the macro code, replace the macro arguments                ; with the arguments provided during the macro call:                If MacroParamList$                  MacroCodeLCase$ = LCase(MacroCode$)                  PARIL = 0                  Repeat                    PARIL + 1                    MacroParam$ = Trim(StringField(MacroParamList$, PARIL, #TAB$))                    If MacroParam$                      ; In the macro code, retrieve the default value                      ; for one of the parameters:                      MacroParamValue$ = Trim(StringField(MacroParam$, 2, "="))                      MacroParam$ = Trim(StringField(MacroParam$, 1, "="))                      CallingParam$ = Trim(StringField(CallingParamList$, PARIL, #TAB$))                      ; If a parameter value is not provided during the call,                      ; use the default value:                      If CallingParam$ = "" : CallingParam$ = MacroParamValue$ : EndIf                      PosParam = 0                      Repeat                        PosParam = FindInPBStringCode(MacroCodeLCase$, LCase(MacroParam$), PosParam + 1, #CheckAll | #CheckOneKeyWordOnly)                        If PosParam                          MacroCode$ = FastLeft(MacroCode$, PosParam - 1) + CallingParam$ + FastMid(MacroCode$, PosParam + Len(MacroParam$))                          MacroCodeLCase$ = LCase(MacroCode$)                          PosParam + Len(CallingParam$) - Len(MacroParam$)                        EndIf                      Until PosParam = 0                    EndIf                  Until MacroParam$ = ""                EndIf                ; Replace the macro call with its code:                *ProcCode\s = FastLeft(*ProcCode\s, PosInCode - 1) + MacroCode$ + FastMid(*ProcCode\s, EOFLP)                ProcCodeLCase\s = LCase(*ProcCode\s)              EndIf            Until PosInCode = 0            ;          EndIf        Next      Until mLenProcCode = Len(*ProcCode\s)    Else      ;AlertInPBBWindow("IncludeMacrosIntoProcedure () --> The Procedure '" + ElementName$ + " cannot be found in Element List!")      *ProcCode\s = "Error"    EndIf    ; Remove the very first tab character in ListOfMacro$,    ; which was only there to facilitate searches:    ListOfMacro$ = Mid(ListOfMacro$, 2)    ;  EndIfEndProcedure;Structure VariableListings  ProcedureName.s  CompleteList.s  Unused.s  Unprotected.sEndStructure;Procedure.s CheckVariable(VWord$, LineOfCode$, *Result.VariableListings, VarPos, ListOp$, Label$ = "")  ;  ; This procedure will attempt to determine if the value contained  ; in VWord$ is a local, shared or global variable name.  ;  ; LineOfCode$ is the line of code containing VWord$,  ; *Result\CompleteList is the list of already identified variables,  ; VarPos is the position where VWord$ appears in LineOfCode$.  ;  Protected  mVWord$, Pos  Protected FoundDetails.LastSearchDetails  Protected pTest, VWordSimple$, VListLCase$, PosSimple, PosWithPoint, LenLine  Protected FollowingPar, TypeOfElement, VDeclare$, PosEOL, PosLastTab  ;  If VarPos And VWord$ And FindString("#\$%?." + #DOUBLEQUOTE$, Left(VWord$, 1)) = 0 And IsStringNum(VWord$) = #False And (VarPos = 1 Or FindString("#\$%?." + #DOUBLEQUOTE$, FastMid(LineOfCode$, VarPos - 1, 1)) = 0)    ;    ; Check that the found name is not inside quotes or a comment:    If VarPos = FindInPBStringCode(LineOfCode$, VWord$, VarPos)      ; If VWord$ is a structured variable, remove the field name that follows      ; the variable name:      VWord$ = Trim(StringField(VWord$, 1, "\"))      ; Also remove all the separator characters that may be attached to the variable name:      mVWord$ = VWord$      For Pos = 1 To Len(ListOp$)        VWord$ = ReplaceString(VWord$, FastMid(ListOp$, Pos, 1), "")      Next      VWord$ = ReplaceString(VWord$, "@", "")      If VWord$        If FastLeft(mVWord$, 1) = "*"          ; See below for special handling of the "*" character.          ; We may have removed this character by removing all separator characters          ; in the 'For Pos = 1 To Len(ListOp$)' loop above. If that's the case, prepare          ; the test that follows:          VarPos + 1        EndIf        ;        If RecognizePointer(LineOfCode$, VarPos)          VWord$ = "*" + VWord$        EndIf        ;        ; Remove the variable type, if it has one:        VWordSimple$ = Trim(LCase(StringField(VWord$, 1, ".")))        ;        ; Remove the prefix (e.g., 'Array'):        If FindString(VWord$, " ")          Label$ + " " + StringField(VWord$, 1, " ")          VWord$ = StringField(VWord$, 2, " ")        EndIf        ;        ; Check if the variable is already in the list:        VListLCase$ = LCase(*Result\CompleteList)        PosSimple = FindString(VListLCase$, #TAB$ + VWordSimple$ + #TAB$)        PosWithPoint = FindString(VListLCase$, #TAB$ + VWordSimple$ + ".")        If PosSimple = 0 And PosWithPoint = 0          ; The variable is not in the list.          ; Check if an opening parenthesis follows.          pTest = VarPos + Len(vWord$)          ; Skip any spaces that may follow the word:          LenLine = Len(LineOfCode$)          While pTest < LenLine And PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)) = #Space            pTest + 1          Wend          ;          If PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)) = Asc("(")            FollowingPar = 1            TypeOfSearch = #FindFollowedByParentheses          Else            FollowingPar = 0            TypeOfSearch = #FindNotFollowedByParentheses          EndIf          ;          ; Check if the word is not the name of a native function or a word          ; belonging to the Basic vocabulary. 'GetTypeOfExpression()' will also          ; check if it is a global variable:          ;          TypeOfElement = GetTypeOfExpression(VWord$, FoundDetails, TypeOfSearch)          If TypeOfElement = -1 And FollowingPar = 0            ; The name was not found in the elements.            ; Only add it to the list if it is not            ; followed by an opening parenthesis.            ; -> Arrays and lists will only be added to the list if            ;    1- they are in the global variables list            ;    2- at the time of their declaration by 'Dim' or 'NewList' or 'NewMap'.            ;       (in which case, add them not here but in the            ;        'ListVariables()' procedure).            ; In all other cases, consider that words followed            ; by an opening parenthesis are not variables, but            ; procedures or functions.            If Label$              *Result\CompleteList + Label$ + #TAB$ + VWord$ + #TAB$ + "Unused" + #CR$            Else              *Result\CompleteList + #TAB$ + VWord$ + #TAB$ + "Used" + #CR$            EndIf            ;          ElseIf TypeOfElement = #PBBVariable And (FollowingPar = 0 Or FindString(FoundDetails\TypeName$, "Array") Or FindString(FoundDetails\TypeName$, "List") Or FindString(FoundDetails\TypeName$, "Map"))            ; The variable is a Shared or Global variable.            ; Only add it to the list if it is not followed by an opening parenthesis            ; or if 'Shared' or 'Global' variable is/are found with the same name that            ; is an array, list, or map.            VDeclare$ = ReplaceString(FoundDetails\TypeName$, " Var", "")            *Result\CompleteList + VDeclare$ + #TAB$ + VWord$ + #TAB$ + "Used" + #CR$          EndIf        ElseIf PosSimple And FindString(VWord$, ".")          ; The variable is in the list, but VWord$ has a type,          ; while the version recorded in *Result\CompleteList does not.          ; Update *Result\CompleteList:          PosEOL = FindString(*Result\CompleteList, #CR$, PosSimple + 1)          *Result\CompleteList = FastLeft(*Result\CompleteList, PosSimple) + VWord$ + #TAB$ + "Used" + FastMid(*Result\CompleteList, PosEOL)        ElseIf PosSimple Or PosWithPoint          ; The variable is already in the list. Mark it as used:          If PosWithPoint = 0 : PosWithPoint = PosSimple : EndIf          PosLastTab = FindString(*Result\CompleteList, #TAB$, PosWithPoint + 1)          PosEOL = FindString(*Result\CompleteList, #CR$, PosLastTab)          *Result\CompleteList = FastLeft(*Result\CompleteList, PosLastTab) + "Used" + FastMid(*Result\CompleteList, PosEOL)        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)  ;  ; Prepare separator lists for the following:  Protected ListPBSepLessPoint$ = ReplaceString(ListPBSep$, ".", "")            ListPBSepLessPoint$ = ReplaceString(ListPBSepLessPoint$, "\", "")  Protected ListPBSepLessStar$ = ReplaceString(ListPBSep$, "*", "")  Protected mPosInLine, PosInLine, BeforeSign, EBeforeSign, LenLine  Protected WordBefore$, AfterSign, EAfterSign, WordAfter$  ;  LenLine = Len(LineOfCode$)  mPosInLine = 0  Repeat    ; The method used to identify variables is not subtle:    ; Search for an operator and look at the two words on either side of the operator.    ; Also look at what is on either side of commas as well as what is between parentheses.    ; A more detailed check will then be done using the 'CheckVariable()' procedure.    PosInLine = FirstOccurrenceOfChar(LineOfCode$, ListOp$, mPosInLine + 1)    If PosInLine      mPosInLine = PosInLine      If PosInLine > 1        ; Extract the word before the operator:        BeforeSign = PosInLine        ; Skip spaces or other separator characters:        While BeforeSign > 1 And FindString(ListPBSep$, Chr(PeekC(@LineOfCode$ + (BeforeSign - 2) * SizeOf(CHARACTER))))          BeforeSign - 1        Wend        If FindString(FastMid(LineOfCode$, BeforeSign, PosInLine - BeforeSign), ")") = 0          ; If the operator is bordered by a closing parenthesis on its left,          ; do not look further. This would be unnecessary since our          ; search method has already caused us to look at what is between parentheses.          EBeforeSign = BeforeSign          ; Go back further until another separator character is found:          While BeforeSign > 1 And FindString(ListPBSepLessPoint$, Chr(PeekC(@LineOfCode$ + (BeforeSign - 2) * SizeOf(CHARACTER)))) = 0            BeforeSign - 1          Wend          ; Extract the preceding word:          WordBefore$ = FastMid(LineOfCode$, BeforeSign, EBeforeSign - BeforeSign)          ;          ; Now check if it could be a variable:          CheckVariable(WordBefore$, LineOfCode$, *Result, BeforeSign, ListOp$)        EndIf      EndIf      ;      If FastMid(LineOfCode$, PosInLine, 1) <> ")" ; Don't look after the closing parenthesis.        ; Skip the separator characters (spaces or others) that might follow the operator:        AfterSign = PosInLine + 1        While AfterSign <= LenLine And FindString(ListPBSepLessStar$, Chr(PeekC(@LineOfCode$ + (AfterSign - 1) * SizeOf(CHARACTER))))          AfterSign + 1        Wend        ;        ; Move further until a separator character is found:        EAfterSign = AfterSign + 1        While EAfterSign <= LenLine And FindString(ListPBSepLessPoint$, Chr(PeekC(@LineOfCode$ + (EAfterSign - 1) * SizeOf(CHARACTER)))) = 0          EAfterSign + 1        Wend        ; Extract the word following the operator:        WordAfter$ = FastMid(LineOfCode$, AfterSign, EAfterSign - AfterSign)        ;        ; Now test the word to see if it is a variable:        CheckVariable(WordAfter$, LineOfCode$, *Result, AfterSign, ListOp$)      EndIf      ;    EndIf  Until PosInLine = 0EndProcedure;  Procedure ListVariables(ElementName$, *Result.VariableListings)  ;  ; This procedure lists the variables found in the procedure  ; named 'ElementName$'.  ;  ; To return reliable results, it requires that the list of  ; 'Global' and 'Shared' variables has already been established.  ;  Protected AfterEqual$  Protected ListOp$ = "=+-/*&|!<>%,()"  Protected PSO, ePSO, PosInCode, mPosInCode, LineOfCode$, PosCom  Protected KeyWordsListTest$, KeyWordsList$, VDeclare$, PosKL, KeyWord$  Protected CharAfter$, pS, VType$, NoVar, Var$, SVar$  Protected PosInList, VLine$, VUsed$  ;  If ListCompletionAll(#PBBVariable) = #ListCompletion_Done        Protected ProcCode.String    ;    ; First, include in the procedure the code of the macros    ; that it might call. This way, the variables in the    ; macros will be examined just like the others:    IncludeMacrosIntoProcedure(ElementName$, ProcCode)    If ProcCode\s = "Error"      ProcedureReturn #False    EndIf    ;    ProcCode\s + #CR$    ;    ;    *Result\ProcedureName = ElementName$    ;    ; Before examining the code to extract the variables,    ; handle the special case of PureBasic functions which might have    ; type or structure names as parameters. If, for example, Sizeof() is    ; found in the code, its parameter might be considered    ; as a variable name (and it should not). Thus, remove this mention:    ;    KeyWordsList$ = "SizeOf,CopyStructure,Defined"    PosInList = 0    Repeat      PosInList + 1      KeyWord$ = StringField(KeyWordsList$, PosInList, ",")      If KeyWord$        Repeat          PSO = FindInPBPointedCode(ProcCode, KeyWord$, 1, #CheckAll, #PB_String_NoCase)          If PSO            ePSO = PSO + Len(KeyWord$)            ; Skip following spaces:            While PeekC(@ProcCode\s + (ePSO - 1) * SizeOf(CHARACTER)) = #Space : ePSO + 1 : Wend            If PeekC(@ProcCode\s + (ePSO - 1) * SizeOf(CHARACTER)) = Asc("(")              ePSO = FindString(ProcCode\s, ")", ePSO)              If ePSO                ePSO + 1                ProcCode\s = FastLeft(ProcCode\s, PSO - 1) + FastMid(ProcCode\s, ePSO)              EndIf            EndIf          EndIf        Until PSO = 0      EndIf    Until KeyWord$ = ""    ;    *Result\CompleteList = ""    PosInCode = 0    Repeat      mPosInCode = PosInCode + 1      ; Extract a line of code between the characters ":" and/or #CR$:      ; 'FindInPBPointedCode()' ensures that these characters are not      ; found inside quotes or comments.      PosInCode = FindInPBPointedCode(ProcCode, ":," + #CR$, mPosInCode, #CheckOnlyComAndQuote)      If PosInCode And (PosInCode - mPosInCode) > 1        LineOfCode$ = Trim(FastMid(ProcCode\s, mPosInCode, PosInCode - mPosInCode))        ;        ; Remove any comment at the end of the line:        PosCom = FindInPBStringCode(LineOfCode$, ";", 1, #CheckOnlyComAndQuote)        If PosCom          LineOfCode$ = Trim(FastLeft(LineOfCode$, PosCom - 1))        EndIf        ;        KeyWordsListTest$ = ",If,ElseIf,While,Until,Select,Case,For,ProcedureReturn,"                KeyWordsList$ = "Procedure,ProcedureC,ProcedureDLL,ProcedureCDLL,Protected,Static,Shared,Global,NewList,NewMap,Dim" + KeyWordsListTest$        VDeclare$ = ""        PosKL = 0        Repeat          PosKL + 1          KeyWord$ = StringField(KeyWordsList$, PosKL, ",")          If KeyWord$            If LCase(FastLeft(LineOfCode$, Len(KeyWord$))) = LCase(KeyWord$)              CharAfter$ =  FastMid(LineOfCode$, Len(KeyWord$) + 1, 1)              If CharAfter$ = "." Or CharAfter$ = " "                LineOfCode$ = Trim(FastMid(LineOfCode$, Len(KeyWord$) + 1))                If FindString(KeyWordsListTest$, "," + KeyWord$ + ",")                  ;                  ; In lines like "If MyVar",                  ; the method used to detect variables                  ; will be ineffective, since such lines don't contain                  ; any operators from ListOp$.                  ; Thus, force a check for this special case:                  ;                  LineOfCode$ = "+" + LineOfCode$                  LineOfCode$ = FindReplaceInPBStringCode(LineOfCode$, "And,Or,XOr,Not,To,Step", "+", 0, #CheckAll, #PB_String_NoCase)                  ;                  FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)                  ;                ElseIf Left(KeyWord$, 9) = "Procedure"                  VDeclare$ = "Parametre"                ElseIf KeyWord$ = "NewList"                  VDeclare$ = "List"                ElseIf KeyWord$ = "NewMap"                  VDeclare$ = "Map"                ElseIf KeyWord$ = "Dim"                  VDeclare$ = "Array"                Else                  VDeclare$ = KeyWord$                EndIf                Break              EndIf            EndIf          EndIf        Until KeyWord$ = ""        ;        If VDeclare$          If VDeclare$ = "Parametre"            ; Only keep what's inside the parentheses of the first line.            LineOfCode$ = FastMid(LineOfCode$, FindString(LineOfCode$, "(") + 1)            LineOfCode$ = Left(LineOfCode$, Len(LineOfCode$) - 1)          Else            ; Handle list and array declarations            ; in Static or Protected:            If LCase(FastLeft(LineOfCode$, 7)) =  LCase("NewList")              VDeclare$ + " List"              LineOfCode$ = Trim(FastMid(LineOfCode$, 8))            ElseIf LCase(FastLeft(LineOfCode$, 7)) = LCase("NewMap")              VDeclare$ + " Map"              LineOfCode$ = Trim(FastMid(LineOfCode$, 7))            ElseIf LCase(FastLeft(LineOfCode$, 3)) = LCase("Dim")              VDeclare$ + " Array"              LineOfCode$ = Trim(FastMid(LineOfCode$, 4))            EndIf          EndIf          ;          If Left(LineOfCode$, 1) = "."            ; We have a list of variables preceded by a type (e.g., '.s').            ; Extract the type:            pS = FindString(LineOfCode$, " ")            If pS              VType$ = FastLeft(LineOfCode$, pS - 1)              ; and remove the type declaration from LineOfCode$              LineOfCode$ = Trim(FastMid(LineOfCode$, pS + 1))            EndIf          Else            VType$ = ""          EndIf          ;          LineOfCode$ = ParseArguments(LineOfCode$)          NoVar = 0          Repeat            NoVar + 1            Var$ = StringField(LineOfCode$, NoVar, #TAB$)            If Var$              ;              AfterEqual$ = ""              If VDeclare$ <> "Parameter" And FindString(Var$, "=")                ; If a variable is used in a 'Protected' declaration,                ; (i.e., if it appears after the "=" sign), note                ; its usage.                AfterEqual$ = FastMid(Var$, FindString(Var$, "="))              EndIf              ; And for the following, keep only the variable name:              Var$ = Trim(StringField(Var$, 1, "="))              Var$ = Trim(StringField(Var$, 1, "("))              ;              ; If the variable is in the elements list, we will retrieve              ; its characteristics to get as much information as possible:              If FindString(VDeclare$, "Shared", 1, #PB_String_NoCase) Or FindString(VDeclare$, "Global", 1, #PB_String_NoCase)                SVar$ = PurifyElementName(Var$)                If CheckIfElementExistsInList(SVar$, #PBBVariable) > -1                  Var$ = ElementsList()\Name                  VDeclare$ = ReplaceString(ElementsList()\VariableSpecies, " Var", "")                EndIf              EndIf              If Var$                If Right(Var$, 1) = "$" : VType$ = "" : EndIf                CheckVariable(Var$ + VType$, Var$ + VType$, *Result, 1, ListOp$, VDeclare$)              EndIf              If AfterEqual$                FindVarInCodeLine(AfterEqual$, ListOp$, *Result.VariableListings)              EndIf            EndIf          Until Var$ = ""        Else          FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)        EndIf      EndIf    Until PosInCode = 0    ;    ; All variables that were not labeled are considered 'unprotected':    ;    *Result\CompleteList = #CR$ + *Result\CompleteList    *Result\CompleteList = ReplaceString(*Result\CompleteList, #CR$ + #TAB$, #CR$ + "Unprotected" + #TAB$)    *Result\CompleteList = FastMid(*Result\CompleteList, 2)    ;    *Result\Unused = ""    *Result\Unprotected = ""    PosInList = 0    Repeat      PosInList + 1      VLine$ = StringField(*Result\CompleteList, PosInList, #CR$)      If VLine$        VDeclare$ = StringField(VLine$, 1, #TAB$)        Var$ = StringField(VLine$, 2, #TAB$)        VUsed$ = StringField(VLine$, 3, #TAB$)        If VUsed$ = "Unused"          *Result\Unused + Var$ + ", "        EndIf        If VDeclare$ = "Unprotected"          *Result\Unprotected + Var$ + ", "        EndIf      EndIf    Until VLine$ = ""    If *Result\Unused      *Result\Unused = GetTextFromCatalogPB("UnusedVariables:") + " " + Fastleft(*Result\Unused, Len(*Result\Unused) - 2)    EndIf    If *Result\Unprotected      *Result\Unprotected = GetTextFromCatalogPB("UnprotectedVariables:") + " " + Fastleft(*Result\Unprotected, Len(*Result\Unprotected) - 2)    EndIf  Else    *Result\ProcedureName = ElementName$    *Result\CompleteList = ""    *Result\Unprotected = ""    *Result\Unused = ""    ProcedureReturn #False  EndIf  ;  ProcedureReturn #True  ;EndProcedure  ;; **********************************************************************************;;-                Formatting and coloring of elements in the panels;; **********************************************************************************;Procedure ColorizeNativePBFunctions(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; Color the names of PureBasic native functions  ;  Protected PosInCode, nl, pf, pfl, pfl2, RColor, REContent.String, PBKeyword$  Protected *TextFontObjet.ITextFont2  Protected PBBUnusedElementColor = GetPBBNumParameter("PBBUnusedElementColor")  ;  If *REContent = 0    ; Create a memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; See the explanations provided in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("PureKeywordColor")  EndIf  ;  nl = 0  pf = 0  Repeat    pfl = FindString(PBFunctionListLCase$, "/", pfl)    If pfl      nl + 1      pfl + 1      pfl2 = FindString(PBFunctionListLCase$, #CR$, pfl)      PBKeyword$ = FastMid(PBFunctionListLCase$, pfl, pfl2 - pfl)      pfl = pfl2      PosInCode = posdep      Repeat        PosInCode = FindInPBPointedCode(*REContent, PBKeyword$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)        If PosInCode          pf = PosInCode + Len(PBKeyword$)          *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf - 1)          *TextFontObjet\GetForeColor(@Rcolor)          If RColor <> PBBUnusedElementColor            *TextFontObjet\SetForeColor(pcolor)          EndIf          *TextFontObjet\Release()        EndIf      Until PosInCode = 0    EndIf  Until pfl = 0EndProcedure;Procedure ColorizeOneElement(NoREGadget, PosInCode, Color, MainPBBPanelState, *REContent.String, SStrLength, ElementNameLCase$, DontUnderline$)  ;  Protected pd, pf  ;  Repeat    PosInCode = FindInPBPointedCode(*REContent, ElementNameLCase$, PosInCode, #CheckAll | #CheckOneKeyWordOnly)    If PosInCode      pf = PosInCode + Len(ElementNameLCase$)      If pf > SStrLength : pf = SStrLength + 1 : EndIf      If ElementNameLCase$ <> DontUnderline$  And FastMid(*REContent\s, PosInCode, pf - PosInCode) <> LCase(#OutOfElementsName)        ; Do not underline the name of the element in the title.        TOM_SetFontStyles(NoREGadget, "Underline()", PosInCode - 1, pf - 1)      EndIf      ;      If MainPBBPanelState = #FoundInFilesPBBPanel        ; When we are in the "Found in..." panel,        ; we color everything up to the end of the line.        pf = FindString(*REContent\s, #CR$, pf)        If pf = 0 : pf = SStrLength + 1 : EndIf        ;        ; Now examine what is before to see if the element        ; is preceded by 'In Macro' or 'In Structure', for example. If so,        ; extend the selection to give the same color to the entire sequence        pd = PosInCode        ; Skip the space or the colon preceding it:        While pd > 1 And (FastMid(*REContent\s, pd - 1, 1) = " " Or FastMid(*REContent\s, pd - 1, 1) = ":" Or FastMid(*REContent\s, pd - 1, 1) = #NonBreakableSpace$) : pd - 1 : Wend         ; Skip the preceding word:        While pd > 1 And FindString(ListPBSep$ + #NonBreakableSpace$, FastMid(*REContent\s, pd - 1, 1)) = 0 : pd - 1 : Wend        If pd > 3 And FastMid(*REContent\s, pd - 3, 3) = "in" + #NonBreakableSpace$          pd = pd - 3        Else          pd = PosInCode        EndIf      Else        pd = PosInCode      EndIf      TOM_SetFontStyles(NoREGadget, "Forecolor(" + Str(Color) + ")", pd - 1, pf - 1)      ;      PosInCode = pf    EndIf  Until PosInCode = 0  ;EndProcedure;Procedure ColorizeElementsNames(NoREGadget, posdep = 0, TitleColor = 0, MainPBBPanelState = 0, *REContent.String = 0, DontUnderline$ = "")  ;  ; Will color and underline (in some cases) the names of elements (procedures, structures, macros, etc.)  ; This procedure is used to display the content of all REGAdgets,  ; except for the file list.  ; 'NoREGadget' can take multiple values.  ;  Protected Color  Protected SStrLength, REContent.String  Protected mListPBSep$  Protected IsUnUsed ; Return value  ;  ; Add #NonBreakableSpace$ to 'ListPBSep$' which is necessary for processing  ; what is displayed in "Found in..."  ; 'ListPBSep$' is a global variable declared and defined  ; just before the 'FindInPBCode()' procedure.  ; It contains the list of characters used as separators  ; in PureBasic syntax.  mListPBSep$ = ListPBSep$  ListPBSep$ + #NonBreakableSpace$  ;  If *REContent = 0    ; Create a memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; See the explanations given in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  SStrLength = Len(*REContent\s)  ;  ; Start by coloring the mention in the constant '#OutOfElementsName'  ColorizeOneElement(NoREGadget, posdep, ListOfAllElementsColor(#PBBProcedure), MainPBBPanelState, *REContent, SStrLength, GetTextFromCatalogPB(#OutOfElementsName), GetTextFromCatalogPB(#OutOfElementsName))  ;  ; Then color all the element names found in the code or list:  ForEach ElementsList()    ;    If ElementsList()\Used Or ListCompletionUsed(ElementsList()\Type) < #ListCompletion_Done      ; If deep exploration is not finished, display the element      ; by default as if it were used.      If ElementsList()\NameLCase = DontUnderline$ And TitleColor        Color = TitleColor      Else        Color = ListOfAllElementsColor(ElementsList()\Type)      EndIf    Else ; else color it in gray:      Color = GetPBBNumParameter("PBBUnusedElementColor")      If ElementsList()\NameLCase = DontUnderline$        IsUnUsed = 1      EndIf    EndIf    ColorizeOneElement(NoREGadget, posdep, Color, MainPBBPanelState, *REContent, SStrLength, ElementsList()\NameLCase, DontUnderline$)    ;  Next  ;  ListPBSep$ = mListPBSep$  ;  ProcedureReturn IsUnUsedEndProcedure;Procedure ColorizeInQuote(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; Colors the text between quotes.  ;  Protected PosInCode, pg, pgf, mp, REContent.String  ;  If *REContent = 0    ; Create memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; See the explanations given in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("StringColor")  EndIf  ;  PosInCode = posdep  Repeat    mp = PosInCode    PosInCode = FindString(*REContent\s, #CR$, PosInCode + 1)    If PosInCode      pgf = mp      Repeat        pg = FindString(*REContent\s, #DOUBLEQUOTE$, pgf + 1)        If pg And pg < PosInCode          pg + 1          ; Check if we are not inside a comment:          If FindString(Mid(*REContent\s, pgf, pg - pgf), ";") = 0            pgf = FindString(*REContent\s, #DOUBLEQUOTE$, pg)            If pgf = 0 Or pgf > PosInCode : pgf = PosInCode : EndIf            TOM_SetFontStyles(NoREGadget, "Forecolor(" + Str(pcolor) + ")", pg - 1, pgf - 1)          Else            pg = 0          EndIf        EndIf      Until pg = 0 Or pg > PosInCode    EndIf  Until PosInCode = 0EndProcedure;Procedure ColorizeBasicKeyWords(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0, ElementUnused = 0)  ;  ; Color the PureBasic keywords (if, endif, while, wend, etc.)  ; and make them bold.  ;  Protected ne, PosInCode, pf, mListPBSep$, SStrLength, REContent.String, SColor  Protected *TextFontObjet.ITextFont2  Protected PBBUnusedElementColor = GetPBBNumParameter("PBBUnusedElementColor")  ;  If *REContent = 0    ; Create memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; Explanation about eliminating #LF$:    ; When extracting a string from a RichEdit Gadget with TOM_GetText()    ; or another method, line breaks include #CR$+#LF$. However, when making a selection on its    ; content, line breaks count as only one character.    ; To ensure accurate counts, one of the two characters must be eliminated before performing    ; operations like 'SetSelection()' or TOM_GetTextFontObj().    ;    ; Explanation about '*REContent\s': when the '*REContent' parameter    ; has a non-null value, the string used is the one contained by the pointer.    ; It is neither reloaded from the gadget nor duplicated in memory.    ; This can save time and memory space.    ;  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("BasicKeywordColor")  EndIf  ;  ; Simplify the separator list to save time  ; and add #NonBreakableSpace$ for processing in "Found in..."  ; ListPBSep$ is a global variable declared and defined  ; just before the 'FindInPBCode()' procedure.  ; It contains the list of characters used as separators  ; in the PureBasic syntax.  mListPBSep$ = ListPBSep$  ListPBSep$ = " :;." + #CR$ + #NonBreakableSpace$  SStrLength = Len(*REContent\s)  ;  For ne = 1 To ArraySize(PBBasicKeywordLCase$())    PosInCode = posdep - 1    Repeat      PosInCode = FindInPBPointedCode(*REContent, PBBasicKeywordLCase$(ne), PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)      If PosInCode        pf = PosInCode + Len(PBBasicKeywordLCase$(ne))        If pf >= SStrLength : pf = SStrLength : EndIf        *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf)        *TextFontObjet\SetBold(#TomTrue)        *TextFontObjet\GetForeColor(@SColor)        ;        If SColor <> PBBUnusedElementColor          If Mid(*REContent\s, pf, 2) = " ▷"            ;            ; We are on an element type name from the "Found in..." list.            ; The characters " ▷" (right-pointing triangle) were placed by            ; the 'SetListFoundInFiles()' procedure to indicate the location            ; where the searched expression (if it's an element) was declared.            ; Color everything until the end of the line.            ;            *TextFontObjet\Release()            pf = FindString(*REContent\s, #CR$, PosInCode)            If pf = 0 : pf = SStrLength + 1 : EndIf            *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf)            ;            If ElementUnused              ;              ; The 'ElementUnused' parameter indicates that the element is unused,              ; and it should be colored gray.              *TextFontObjet\SetForeColor(PBBUnusedElementColor)            Else              *TextFontObjet\SetForeColor(pColor)            EndIf          Else            *TextFontObjet\SetForeColor(pColor)          EndIf        EndIf        *TextFontObjet\Release()      EndIf    Until PosInCode = 0  Next  ; Don't forget to restore ListPBSep$  ; for general use:  ListPBSep$ = mListPBSep$EndProcedure;Procedure ColorizeNativeConstants(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; Color the names of PureBasic's or Windows'  native constants.  ; Constants defined in the program will be colored by the  ; 'ColorizeElementsNames()' procedure.  ;  Protected PosInCode, pf, REContent.String, ElementNameLCase$  ;  If *REContent = 0    ; Create a memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; See the explanation given in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("ConstantColor")  EndIf  ;  PosInCode = posdep  Repeat    PosInCode = FindString(*REContent\s, "#", PosInCode + 1)    If PosInCode      pf = FirstOccurrenceOfCharPointed(*REContent, ListPBSep$, PosInCode + 1) ; Find the end of the constant name      If pf        ElementNameLCase$ = FastMid(*REContent\s, PosInCode , pf - PosInCode) ; Extract the constant name        ; Check that the constante is not an element:        If CheckIfElementExistsInList(ElementNameLCase$, #PBBConstante) = -1          ; Check that the found position is not inside quotes or comments:          If PosInCode = FindInPBPointedCode(*REContent, ElementNameLCase$, PosInCode, #CheckAll | #CheckOneKeyWordOnly)            TOM_SetFontStyles(NoREGadget, "Forecolor(" + Str(pcolor) + ")", PosInCode - 1, pf)          EndIf        EndIf      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure ColorizeComments(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; Color the comments into code.  ;  Protected PosInCode, mp, pv, nbg, REContent.String  ;  If *REContent = 0    ; Create a memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$    ; See the explanation given in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("CommentColor")  EndIf  ;  PosInCode = posdep  Repeat    mp = PosInCode + 1    PosInCode = FindString(*REContent\s, #CR$, mp)    If PosInCode      pv = mp      CC_FindSemicolon:       pv = FindString(*REContent\s, ";", pv)      If pv And pv < PosInCode        nbg = CountString(FastMid(*REContent\s, mp, pv - mp), #DOUBLEQUOTE$)        If nbg & 1 ; There is an odd number of quotes before the semicolon          pv + 1   ; Move to the next one.          Goto CC_FindSemicolon        EndIf        TOM_SetFontStyles(NoREGadget, "Forecolor(" + Str(pcolor) + ")", pv - 1, PosInCode)      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure UnderlineFNamesAndLinks(NoREGadget, posdep = 0, *REContent.String = 0, DontUnderlineNumbers = 0)  ;  ; Examine the content of the RichEdit gadget 'NoREGadget' and applies the 'underline' style  ; to numbers in parentheses, file names found in PBBListOfFiles$,  ; and 'custom links' found in the shared variable 'PBBCustomLinks$'.  ;  ; This procedure also applies a specific color to the terms 'Set',  ; 'Return>', and 'Param>' that appear in the text.  ;  Shared PBBCustomLinks$  Protected PosInCode, pf, PosInFileList, LineC$, FileName$, REContent.String  Protected pd, mention$, nl, CustomLinksLine$  Protected PBBSetValueColor = GetPBBNumParameter("PBBSetValueColor")  ;  If *REContent = 0    ; Create a memory space for *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), #LF$, "") + #CR$)    ; See explanations given in the 'ColorizeBasicKeyWords' procedure.  EndIf  ;  If *REContent\s    If DontUnderlineNumbers = 0       ; Underline line numbers in parentheses.      PosInCode = posdep - 1      Repeat        PosInCode = FindString(*REContent\s, "(", PosInCode + 1)        If PosInCode          PosInCode + 1          pf = FindString(*REContent\s, ")", PosInCode)          If pf And Val(FastMid(*REContent\s, PosInCode, pf - PosInCode))            TOM_SetFontStyles(NoREGadget, "Underline()", PosInCode - 1, pf - 1)          EndIf        EndIf      Until PosInCode = 0    EndIf    ;    ;    ; Colorize the terms "Set>", "Return>", "Param>", etc.    PosInCode = posdep - 1    Repeat      PosInCode = FindString(*REContent\s, #ThisPlaceChar$, PosInCode + 1) ; #ThisPlaceChar$ = "➭"      If PosInCode        pd = PosInCode        FastFindPrecSpaces(*REContent\s, pd)        mention$ = FastMid(*REContent\s, pd + 1, PosInCode - pd - 1)        If FindString(mention$, "set") Or FindString(mention$, "read") Or FindString(mention$, "param") Or FindString(mention$, "ret") Or FindString(mention$, "poke")          TOM_SetFontStyles(NoREGadget, "ForeColor(" + Str(PBBSetValueColor) + ")", pd, PosInCode - 1)        EndIf      EndIf    Until PosInCode = 0    ;    ;    ; Underline the file names found in PBBListOfFiles$.    ;    If PBBListOfFiles$      PosInFileList = 0      Repeat         PosInFileList + 1        LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)        If LineC$          FileName$ = LCase(GetFilePart(StringField(LineC$, 1, #TAB$)))          PosInCode = posdep - 1          Repeat            PosInCode = FindString(*REContent\s, FileName$, PosInCode + 1)            If PosInCode              PosInCode - 1 : If PosInCode < 0 : PosInCode = 0 : EndIf              pf = PosInCode + Len(FileName$)              TOM_SetFontStyles(NoREGadget, "ForeColor(" + Str(GetValueFromBPPrefFile("NormalTextColor")) + "),Underline()", PosInCode, pf)              PosInCode = pf            EndIf          Until PosInCode = 0        EndIf      Until LineC$ = ""    EndIf    ;    ; Underline the file names found in PBBListOfBinaries$.    ;    If PBBListOfBinaries$      PosInFileList = 0      Repeat         PosInFileList + 1        LineC$ = StringField(PBBListOfBinaries$, PosInFileList, #CR$)        If LineC$          FileName$ = LCase(GetFilePart(StringField(LineC$, 1, #TAB$)))          PosInCode = posdep - 1          Repeat            PosInCode = FindString(*REContent\s, FileName$, PosInCode + 1)            If PosInCode              PosInCode - 1 : If PosInCode < 0 : PosInCode = 0 : EndIf              pf = PosInCode + Len(FileName$)              TOM_SetFontStyles(NoREGadget, "ForeColor(" + Str(GetValueFromBPPrefFile("NormalTextColor")) + "),Underline()", PosInCode, pf)              PosInCode = pf            EndIf          Until PosInCode = 0        EndIf      Until LineC$ = ""    EndIf    ;    ; Underline 'CustomLinks', if there are any.    ;    nl = 0    Repeat      nl + 1      CustomLinksLine$ = LCase(StringField(PBBCustomLinks$, nl, #CR$))      If CustomLinksLine$        PosInCode = FindString(*REContent\s, CustomLinksLine$, posdep)        If PosInCode          PosInCode - 1 : If PosInCode < 0 : PosInCode = 0 : EndIf          pf = PosInCode + Len(CustomLinksLine$)          TOM_SetFontStyles(NoREGadget, "Underline()", PosInCode, pf)        EndIf      EndIf    Until CustomLinksLine$ = ""  EndIfEndProcedure;; **********************************************************************************;;-                                Pannels management;; **********************************************************************************;Procedure GetActivePBBPanel()  ;  ; Examine the state of the two nested panels (MainPanelGadget and ListsPGadget)  ; and returns the number from the 'PBBPanel' enumeration based on  ; the currently active panel.  ;  Protected TypeOfElement  ;  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    ; #ListPBBPanel is a panel that contains other panels,    ; so continue the exploration if it is encountered.    If GetGadgetState(NoGadgetPBBPanel(TypeOfElement)) = NoPBBPanel(TypeOfElement) And TypeOfElement <> #ListPBBPanel      ProcedureReturn TypeOfElement    EndIf  NextEndProcedure;Procedure GetREGadgetNbrFromActivePBBPanel()  ;  ; Examine the state of the two nested panels (MainPanelGadget and ListsPGadget)  ; and returns the gadget number of the corresponding RichEditGadget (EditorGadget)  ; for the currently active panel.  ;  ProcedureReturn NoREGadgetOfPBBPanel(GetActivePBBPanel())EndProcedure;Procedure SetActivePBBPanel(NoPBBPanel)  ;  ; NoPBBPanel must be one of the values from the 'PBBPanels' enumeration  ; (see the declaration of this enumeration at the beginning of the program)  ;  ; #FilePBBPanel  ; #ListPBBPanel  ; #DetailPBBPanel  ; #FoundInFilesPBBPanel  ;  ; #ProcPBBPanel  ; #StructurePBBPanel  ; #MacroPBBPanel  ; ...  Protected TypeOfElement  ;  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    If NoREGadgetOfPBBPanel(TypeOfElement) And TypeOfElement = NoPBBPanel      If TypeOfElement >= #ProcPBBPanel        ; If we are in the 'ListsPGadget' PanelGadget, which is nested        ; inside the 'MainPanelGadget' PanelGadget, set 'MainPanelGadget' to #ListPBBPanel        SetGadgetState(NoGadgetPBBPanel(#ListPBBPanel), NoPBBPanel(#ListPBBPanel))      EndIf      SetGadgetState(NoGadgetPBBPanel(TypeOfElement), NoPBBPanel(TypeOfElement))    EndIf  NextEndProcedure;; **********************************************************************************;;-                          Management of the element list;; **********************************************************************************;; The 'elements' correspond to the different parts of code that can be; isolated within a global code. Procedures, macros, and structures,; for example, correspond to this 'element' concept.; The complete list of what we define as 'elements' is found in; the 'PBBTypes' enumeration, which is in the declaration file:;   #PBBProcedure;   #PBBStructure;   #PBBMacro;   #PBBEnumeration;   #PBBInterface;   #PBBLabel;   #PBBConstant;   #PBBVariable;   ...;; When a code file is opened in PBBrowser, it is immediately; examined to compile a list of its elements. This list is; stored in 'ElementsList()'.; A second phase of exploration then attempts to determine which; elements appear in the code without being used by any other,; and which are actually used.;;; ----------------------------------------------------------------------------------;-                  Procedures for the first phase of exploration;Procedure CompleteListOfAllElements(FileName$, TypeOfElement, PriorityMode, CLE_StartTime, *Limits.Point = 0)  ;  ; This procedure creates the list of 'TypeOfElement' type elements defined and contained  ; in the 'FileName$' file and updates the ElementsList() based on the found elements  ;  ; This procedure is designed to run in the background  ; and will stop after 200 milliseconds have passed since 'CLE_StartTime',  ; but it will complete the exploration if PriorityMode = '#FinishCompletionNow'.  ;  ; If 'PriorityMode' has a value different from '#WorkInBackGround', a waiting window will be displayed  ; during its execution.  ;  Shared PBBLComment$ ; Used to retrieve the comment of declarations  ;  Static *SearchString.String ; Contains the portion of code currently being worked on.  Static mTypeOfElement       ; Contains the last type of element worked on,  ;                             ; to avoid searching and translating its name every time.  Static PBBType$, PBBTypeTranslated$, PBBExtendedType$ ; Element type name.  Static VariableSpecies  ;  Protected SStrLength ; To avoid recalculating the total length of the examined string too often,  ;                       ; it is calculated only once at the start of the procedure.  Protected PosInCode, pd, pf, pfe, LastCodeStartingPos, tp, mps, mpo, cont ; various positions in the code.  Protected ElementStartingPos, RealElement ; Results of checks for different types of elements.  Protected ExtractLine$                    ; For working with code snippets.  Protected reboot, nbp, nbq, CChar$  ;  ; Parameters of found elements in the code:  Protected ElementEndingPos, StartingLine, EndingLine, ElementName$, CompleteElementDeclaration$, UnNamed  ;  ; Other variables:  Protected VariableSpecies$, FinishExam, VariableSubSpecies$, pp, VariableType$  Protected NbParenthesis, PosParenthesis, ppar, ElementNameLCase$, ExtendedTypeName$  ;  If ListCompletionAll(TypeOfElement) < #ListCompletion_Done    If ListCompletionAll(TypeOfElement) = #ListCompletion_Undone      ; Start (or restart) from zero for this element.      ListOfAllElementsNbr(TypeOfElement) = 0      ListOfUsedElementsNbr(TypeOfElement) = 0      PosInCode = 0    EndIf    ;    If FileName$      ; Reference file has been changed.      ListCompletionReference$(TypeOfElement) = FileName$      *SearchString = GetPointedCodeFromFile(FileName$)      If *Limits        PosInCode = *Limits\x - 1      Else        PosInCode = 0      EndIf      VariableSpecies = 1    Else      ; The exploration has already started. Continue it.      PosInCode = ListCompletionStage(TypeOfElement)      FileName$ = ListCompletionReference$(TypeOfElement)    EndIf    ;    SStrLength = Len(*SearchString\s)    ;    If mTypeOfElement <> TypeOfElement Or PBBType$ = ""      PBBType$ = PBBTypeNames$(TypeOfElement)      PBBTypeTranslated$ = GetTextFromCatalogPB(PBBType$ + "s")      If TypeOfElement = #PBBEnumeration        ; For this particular case, search for both types of enumeration:        PBBExtendedType$ = "Enumeration,EnumerationBinary"      ElseIf TypeOfElement = #PBBProcedure        ; For this particular case, search for both types of procedures:        PBBExtendedType$ = "Procedure,ProcedureC,ProcedureDLL,ProcedureCDLL"      Else        PBBExtendedType$ = PBBType$      EndIf      mTypeOfElement = TypeOfElement    EndIf    ;    If TypeOfElement = #PBBVariable    ; The identification of Variables is quite specific, and is handled separately.    ;    ; Strictly speaking, a variable is not an element (organized as 'Element'... 'EndElement in the code).    ;    ; Since we decided to classify variables into several categories    ; (Global, Shared, Static, Protected, Local), this requires to perform multiple searches for    ; each of these categories. Furthermore, for a single 'Global' type declaration, for example,    ; there can be multiple variables to register (separated by commas).    ; The 'Variable' element is the only one that presents such complications.      ;      Repeat        VariableSpecies$ = StringField(#PBBVariableSpecies$, VariableSpecies, ",")        ;        Repeat          ManageWaitingWindow(PriorityMode, GetTextFromCatalogPB("LookingForElements") + " " + PBBTypeTranslated$ + ".", PBBTypeTranslated$)          PBBLComment$ = ""          FinishExam = 0          ;          PosInCode = FindString(*SearchString\s, VariableSpecies$, PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, VariableSpecies$, PosInCode, #True)            If CompleteElementDeclaration$              StartingLine = CountString(FastMid(*SearchString\s, 1, PosInCode), #CR$) + 1              EndingLine = StartingLine              ;              ElementStartingPos = Len(VariableSpecies$) + 1              VariableSubSpecies$ = "Var"              VariableType$ = ""              Repeat                While ElementStartingPos <= Len(CompleteElementDeclaration$) And (FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = " " Or FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = ",")                  If FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = ","                    VariableSubSpecies$ = "Var"                  EndIf                  ElementStartingPos + 1                Wend                If FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = "="                  ; There can be something like Global Var1 = Value1, Var2 = Value2  --> Var1 and Var2 must be added into ElementsList()                  ; or Global Var1 = MyFunction(Value1, Value2), Var2                --> Var1 and Var2 must be added into ElementsList()                  ;                  ; So, we must look for a comma that is not inside parentheses or quotes:                  nbp = 0                  nbq = 0                  Repeat                    ElementStartingPos + 1                    If ElementStartingPos <= Len(CompleteElementDeclaration$)                      CChar$ = Fastmid(CompleteElementDeclaration$, ElementStartingPos, 1)                      If CChar$ = "("                        nbp + 1                      ElseIf CChar$ = ")"                        nbp - 1                      ElseIf CChar$ = #DOUBLEQUOTE$                        nbq = Abs(nbq - 1)                      EndIf                    EndIf                  Until ElementStartingPos = Len(CompleteElementDeclaration$) Or (CChar$ = "," And nbp = 0 And nbq = 0)                  If CChar$ <> "," Or nbp Or nbq                    ElementStartingPos = 0                  EndIf                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 3) = "Dim"                  VariableSubSpecies$ = "Array"                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 7) = "NewList"                  VariableSubSpecies$ = "List"                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 6) = "NewMap"                  VariableSubSpecies$ = "Map"                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = "."                  ; CompleteElementDeclaration$ is something like "Global.a MyVariable"                  pp = ElementStartingPos                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                  VariableType$ = FastMid(CompleteElementDeclaration$, pp, ElementStartingPos - pp)                Else                  ElementEndingPos = FirstOccurrenceOfChar(CompleteElementDeclaration$, " ,:=" + #CR$, ElementStartingPos)                  If ElementEndingPos  = 0 : FinishExam = 1 : ElementEndingPos = Len(CompleteElementDeclaration$) + 1 : EndIf                  ;                  If ElementEndingPos > ElementStartingPos                    ElementName$ = FastMid(CompleteElementDeclaration$, ElementStartingPos, ElementEndingPos - ElementStartingPos)                    ;                    NbParenthesis = 0                    PosParenthesis = 0                    Repeat                      PosParenthesis = FindInPBStringCode(ElementName$, "(", PosParenthesis + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                      If PosParenthesis : NbParenthesis + 1 : EndIf                    Until PosParenthesis = 0                    PosParenthesis = 0                    Repeat                      PosParenthesis = FindInPBStringCode(ElementName$, ")", PosParenthesis + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                      If PosParenthesis : NbParenthesis - 1 : EndIf                    Until PosParenthesis = 0                    ;                    If NbParenthesis > 0                      While NbParenthesis                        ElementEndingPos = FindInPBStringCode(CompleteElementDeclaration$, ")", ElementEndingPos, #CheckOnlyComAndQuote)                        If ElementEndingPos = 0                          ElementEndingPos = Len(CompleteElementDeclaration$)                          NbParenthesis = 0                          FinishExam = 1                        Else                          ElementEndingPos + 1                          NbParenthesis - 1                        EndIf                      Wend                      ElementName$ = FastMid(CompleteElementDeclaration$, ElementStartingPos, ElementEndingPos - ElementStartingPos)                    EndIf                    ;                    ppar = FindString(ElementName$, "(")                    If ppar                      ElementName$ = FastLeft(ElementName$, ppar - 1)                    EndIf                    ;                    ElementNameLCase$ = PurifyElementName(ElementName$)                    ;                    If CheckIfElementExistsInList(ElementNameLCase$, TypeOfElement) = -1                      AddElement(ElementsList())                      ElementsList()\Type = TypeOfElement                      ElementsList()\Name = ElementName$ + VariableType$                      ElementsList()\NameLCase = ElementNameLCase$                      ElementsList()\FileName = FileName$                      ElementsList()\Declaration = CompleteElementDeclaration$                      ElementsList()\StartingLine = StartingLine                      ElementsList()\EndingLine = EndingLine                      ElementsList()\StartingPos = PosInCode                      ElementsList()\EndingPos = PosInCode + Len(CompleteElementDeclaration$)                      ElementsList()\VariableSpecies = VariableSpecies$ + " " + VariableSubSpecies$                      ElementsList()\Comment = PBBLComment$                                            ElementsList()\Used = 0                      ElementsList()\DeclarationDetails = ""                      ElementsList()\Parents = ""                      ElementsList()\Children = ""                      ;                      ListOfAllElementsNbr(TypeOfElement) + 1                      ;                    EndIf                  EndIf                  ElementStartingPos = ElementEndingPos                EndIf                                Until ElementStartingPos = 0 Or FinishExam              :               PosInCode + Len(CompleteElementDeclaration$)              ;            Else              PosInCode + Len(VariableSpecies$)            EndIf          EndIf          If PosInCode = 0            VariableSpecies + 1          EndIf        Until PosInCode = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)      Until VariableSpecies = 3 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)    Else      Repeat        ManageWaitingWindow(PriorityMode, GetTextFromCatalogPB("LookingForElements") + " " + PBBTypeTranslated$ + ".", PBBTypeTranslated$)        ElementStartingPos = 0        LastCodeStartingPos = PosInCode        PBBLComment$ = ""        If TypeOfElement = #PBBLabel          ;          ; The identification of Labels is also specific, but since there is only one label per line,          ; handle this case in a common flow with the other elements.          ;          PosInCode = FindString(*SearchString\s, ":", PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            ; On mémorise la position de fin de nom :            mps = PosInCode            ; On saute les espaces qui suivent            pf = PosInCode + 1            While pf <= SStrLength And PeekC(@*SearchString\s + (pf - 1) * SizeOf(CHARACTER)) = #Space : pf + 1 : Wend            ; We are looking for a label. Therefore, the ":" that is placed at the end            ; of the label name must appear at the end of the line; otherwise, this line is not relevant to us.            ; The end of the line can be the end of the string '*SearchString\s', a carriage return (#CR$),            ; or a ":".            ;            If pf > SStrLength Or FastMid(*SearchString\s, pf, 1) = ":" Or FastMid(*SearchString\s, pf, 1) = #CR$              ; We are at the end of the line. Let's search for the first separator before              ; the potential label name.              While PosInCode > 1 And FindString(ListPBSep$, FastMid(*SearchString\s, PosInCode - 1, 1)) = 0 : PosInCode - 1 : Wend              If PosInCode And PosInCode < mps ; The label must be adjacent to the ":". If there is a separator just before, it's not a label.                ElementName$ = FastMid(*SearchString\s, PosInCode, mps - PosInCode)                ; If it's not "Else" and it's not a module name:                If ElementName$ <> "Else" And FastMid(*SearchString\s, mps, 2) <> "::"                  ; Extract the portion of the line containing the expression,                  ; and at the same time, check that the found expression                  ; is not within quotes or in a comment.                  ExtractLine$ = ExtractSectionArroundExpression(*SearchString, ElementName$, PosInCode, #True)                  If ExtractLine$ = ElementName$  ; Check that there is nothing between the start of the line and the label.                    CompleteElementDeclaration$ = ElementName$ + ":"                    RealElement = 0                    ElementStartingPos = PosInCode                    ElementEndingPos = mps                  EndIf                EndIf              EndIf              PosInCode = mps            EndIf          EndIf        ElseIf TypeOfElement = #PBBConstante          ;          ; The identification of Constants is also specific,          ; but we can handle this case in a common flow with the other elements.          ;          PosInCode = FindString(*SearchString\s, "#", PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            pd = PosInCode - 1            ; Skip preceeding spaces:            If pd              FastSkipPrecSpaces(*SearchString\s, pd)            EndIf            ; Only constant declarations are relevant to us here.            ; Therefore, the "#" must be placed at the beginning of the line            ; otherwise, it's not of interest to us.            ;            If pd = 0 Or FastMid(*SearchString\s, pd, 1) = ":" Or FastMid(*SearchString\s, pd, 1) = #CR$              pf = PosInCode + 1              ; Look for the end of the constant name:              cont = 1              Repeat                If pf <= SStrLength And FindString(" :=;" + #CR$, FastMid(*SearchString\s, pf, 1)) = 0                  pf + 1                Else                  cont = 0                EndIf              Until cont = 0              ; Store the position of the end of the name.              pfe = pf              ; Skip the spaces that follow the name.              While pfe <= SStrLength And PeekC(@*SearchString\s + (pfe - 1) * SizeOf(CHARACTER)) = #Space : pfe + 1 : Wend              ; Only a line break, a comment, or the "=" character are allowed after the constant name              ; during its declaration.              If pfe > SStrLength Or FindString(":=;" + #CR$, FastMid(*SearchString\s, pfe, 1))                ElementName$ = FastMid(*SearchString\s, PosInCode, pf - PosInCode)                ; We will both extract the code segment containing the constant,                ; and verify that what we have found is not within quotes or in a comment:                CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementName$, PosInCode, #True)                If CompleteElementDeclaration$                  RealElement = 0                  ElementStartingPos = PosInCode                  PosInCode + Len(CompleteElementDeclaration$)                  ElementEndingPos = PosInCode - 1                EndIf              EndIf            EndIf          EndIf        Else          ;          ; From here on, handle all elements of type 'Element'....'EndElement' in the same way.          ;          UnNamed = 0          PosInCode = FindInPBPointedCode(*SearchString, PBBExtendedType$, PosInCode)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            mpo = PosInCode            PosInCode + Len(PBBType$)            mps = PosInCode            ; If the element has a name, there must be a space between the element's type declaration            ; (Procedure, Structure, Macro, etc.) and the element's name.            PosInCode = FindString(*SearchString\s, " ", PosInCode)            If PosInCode = 0 : PosInCode = SStrLength + 1 : EndIf            If TypeOfElement = #PBBProcedure              ; #PBBProcedure is the most common type, so let's save time              ; by looking for the only possible separator between the procedure name              ; and what follows ;              pf = FindString(*SearchString\s, "(", PosInCode)            Else              ; We will check if the element has a name, as enumerations              ; may not have one:              ;              ; Start by extending the area containing the type,              ; for the case where there is 'Procedure.s', for example.              ExtendedTypeName$ = ""              If PosInCode - mps > 0 And mps <= SStrLength                ExtendedTypeName$ = FastMid(*SearchString\s, mps, PosInCode - mps)              EndIf              tp = FirstOccurrenceOfChar(ExtendedTypeName$, ":;" + #CR$)              If tp                ; Just after the element type, there is a line break or a comment,                ; before any space. So the element doesn't have a name.                PosInCode = mps + tp                pf = PosInCode              Else                ; Look for the start of the name:                While PosInCode <= SStrLength And PeekC(@*SearchString\s + (PosInCode - 1) * SizeOf(CHARACTER)) = #Space : PosInCode + 1 : Wend                ; Then the end of the name:                pf = FirstOccurrenceOfCharPointed(*SearchString, " :(;" + #CR$, PosInCode)              EndIf            EndIf            ElementName$ = ""            If pf - PosInCode > 0              ElementName$ = Trim(FastMid(*SearchString\s, PosInCode, pf - PosInCode))            EndIf            If ElementName$ = ""              If PosInCode > SStrLength : PosInCode = SStrLength : EndIf              StartingLine = CountString(FastMid(*SearchString\s, 1, mpo), #CR$) + 1              ElementName$ = "UnNamed - Line " + Str(StartingLine)              UnNamed = 1            EndIf            ;            RealElement = 1            ElementStartingPos = mpo          EndIf        EndIf        If ElementStartingPos          If ElementStartingPos > SStrLength : ElementStartingPos = SStrLength : EndIf ; Au cas où...          If UnNamed = 0            StartingLine = CountString(FastMid(*SearchString\s, 1, ElementStartingPos), #CR$) + 1          EndIf          If RealElement            ElementEndingPos = FindInPBPointedCode(*SearchString, "End" + PBBType$, pf, #CheckAll | #CheckOneKeyWordOnly)            If ElementEndingPos              ElementEndingPos + Len("End" + PBBType$)            Else              ElementEndingPos = SStrLength + 1            EndIf            EndingLine = StartingLine + CountString(FastMid(*SearchString\s, ElementStartingPos, ElementEndingPos - ElementStartingPos), #CR$) + 1            If UnNamed              CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, PBBType$, ElementStartingPos, #True)            Else              CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementName$, ElementStartingPos, #True)            EndIf          Else            EndingLine = StartingLine          EndIf          ;          ; Set ElementEndingPos to the end of the line containing the end of the element,          ; in order to include any potential comment that may follow:          ElementEndingPos = FirstOccurrenceOfCharPointed(*SearchString, ":" + #CR$, ElementEndingPos)          If ElementEndingPos = 0 : ElementEndingPos = SStrLength + 1 : EndIf          ;          ElementNameLCase$ = LCase(ElementName$)          If CheckIfElementExistsInList(ElementNameLCase$, TypeOfElement) = -1            AddElement(ElementsList())            ElementsList()\Type = TypeOfElement            ElementsList()\Name = ElementName$            ElementsList()\NameLCase = ElementNameLCase$            ElementsList()\FileName = FileName$            ElementsList()\Declaration = CompleteElementDeclaration$            ElementsList()\StartingLine = StartingLine            ElementsList()\EndingLine = EndingLine            ElementsList()\StartingPos = ElementStartingPos            ElementsList()\EndingPos = ElementEndingPos            ElementsList()\VariableSpecies = ""            ElementsList()\Comment = PBBLComment$            ;            ElementsList()\Used = 0            ElementsList()\DeclarationDetails = ""            ElementsList()\Parents = ""            ElementsList()\Children = ""            ;                  ListOfAllElementsNbr(TypeOfElement) + 1            ;          EndIf          ;        EndIf        ;        reboot = 0        If PosInCode = 0  And PriorityMode = #FinishCompletionNow And TypeOfElement = #PBBVariable          VariableSpecies + 1          If StringField(#PBBVariableSpecies$, VariableSpecies, ",")            reboot = 1          EndIf        EndIf        ;      Until reboot = 0 And (PosInCode = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow))      ;    EndIf    ;    If PosInCode > 0 ; The exploration was interrupted, it will be resumed later.      ListCompletionAll(TypeOfElement) = #ListCompletion_Pending      ListCompletionStage(TypeOfElement) = PosInCode    Else      ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted    EndIf    ;  EndIf  ;EndProcedure;Procedure SetDeclarePositionsForProc(FileName$, *SearchString.String, PosInCode = 0, EndPos = 0)  ;  ; Searches for occurrences of "Declare" in the code contained in *SearchString,  ; and updates ElementsList() with the positions of the found occurrences.  ;  Protected CompleteElementDeclaration$, PosInLine, mPosInLine  Protected ElementNameLCase$, DeclareLine  ;  Repeat    PosInCode = FindString(*SearchString\s, "declare", PosInCode + 1)    If EndPos And PosInCode > EndPos : PosInCode = 0 : EndIf    ;    If PosInCode      CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, "declare", PosInCode, #True)      PosInCode + 7      ; Check if "declare" is at the beginning of the line:      If Left(CompleteElementDeclaration$, 7) = "declare"        ; The procedure name must be preceded by a space:        PosInLine = FindString(CompleteElementDeclaration$, " ", 7)        If PosInLine          mPosInLine = PosInLine + 1          ; The procedure name must be followed by a space or an opening parenthesis:          PosInLine = FirstOccurrenceOfChar(CompleteElementDeclaration$, "( ", mPosInLine)          If PosInLine            ; Everything seems correct. Let's search for the procedure in the element list:            ElementNameLCase$ = FastMid(CompleteElementDeclaration$, mPosInLine, PosInLine - mPosInLine)            If CheckIfElementExistsInList(ElementNameLCase$, #PBBProcedure) > -1              DeclareLine = CountString(FastMid(*SearchString\s, 1, PosInCode), #CR$) + 1              ElementsList()\DeclarationDetails = FileName$ + "/" + Str(DeclareLine)              ; The information just added to the list will be used by 'FillDetailREGadget'              ; which will display a mention 'Declared in XXXXXXXX at line XX' in the procedure description.            EndIf          EndIf        EndIf      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure.s ComputeConstanteValue(Declaration$)  ;  Protected ppv, pEqual, pVal$, pc, pcf, ElementName$, pValR$, ValConst  ;  ppv = FindString(Declaration$, ";")  If ppv : Declaration$ = FastLeft(Declaration$, ppv - 1) : EndIf  Declaration$ = Trim(Declaration$)  pEqual = FindString(Declaration$, "=")  If pEqual    ; Check if we can interpret this value:    pVal$ = Trim(Mid(Declaration$, pEqual + 1))    ; Check if the constant's value is calculated from the values of other constants.    ; If so, attempt to replace the constant names with their values.    pc = 0    Repeat      ; Search for a constant name in the value definition:      pc = FindString(pVal$, "#", pc + 1)      If pc        pcf = pc + 1        While FindString("+-*/() ", Mid(pVal$, pcf, 1)) = 0 And pcf <= Len(pVal$) : pcf + 1 : Wend        ElementName$ = FastMid(pVal$, pc, pcf - 1)        PushListPosition(ElementsList())        If CheckIfElementExistsInList(LCase(ElementName$), #PBBConstante) > -1          ; A constant name as been found in the value definition.          ; Replace the constant name with its value.          pValR$ = ElementsList()\Value          If pValR$ <> "UnResolved"            pVal$ = ReplaceString(pVal$, ElementName$, pValR$)          EndIf        EndIf        PopListPosition(ElementsList())      EndIf    Until pc = 0    ValConst = EvaluateExpression(pVal$)    If EvError      pVal$ = "UnResolved"    Else      pVal$ = Str(ValConst)    EndIf  EndIf  ProcedureReturn pVal$EndProcedure;Procedure EvaluateEnumConstantesValue(EnumerationName$, SourceFile$, ElementStartingPos, ElementEndingPos)  ;  ; This procedure examines the code of an enumeration found in  ; SourceFile$ at positions ElementStartingPos and ElementEndingPos.  ;  ; It details the constants in the enumeration and assigns them  ; a value when possible.  ;  Protected *SearchString.String, ValConst, ValConst$  Protected LineC$, ppv, pEqual, PosInEnum, mPosInEnum  Protected ECIndex$, Parents$, EPIndex$  Protected CompleteElementDeclaration$  ;  ; Extract the code corresponding to the enumeration.  *SearchString = GetPointedElementContentFromFile(SourceFile$, ElementStartingPos, ElementEndingPos, #False)  ;  ; Examine the code of the enumeration, line by line:  ValConst = -1  PosInEnum = FindString(*SearchString\s, #CR$, 1)  ;  Repeat    mPosInEnum = PosInEnum + 1    PosInEnum = FindString(*SearchString\s, #CR$, PosInEnum + 1)    If PosInEnum      ; Retrieve the constant declarations in the enumeration:      LineC$ = Trim(FastMid(*SearchString\s, mPosInEnum, PosInEnum - mPosInEnum))      If LCase(Left(Trim(LineC$), 14)) <> "endenumeration"        ; Remove any comment.        ppv = FindString(LineC$, ";")        If ppv : LineC$ = FastLeft(LineC$, ppv - 1) : EndIf        LineC$ = Trim(LineC$)        ; Check if the constant is assigned a value:        pEqual = FindString(LineC$, "=")        If pEqual          ValConst$ = ComputeConstanteValue(LineC$)          ValConst = Val(ValConst$)          LineC$ = Trim(FastLeft(LineC$, pEqual - 1))        ElseIf ValConst$ <> "UnResolved"          ; If an interpretable value was found in the previous lines,          ; increment it:          If FindString(CompleteElementDeclaration$, "EnumerationBinary")            If ValConst = -1              ValConst = 1            Else              ValConst * 2            EndIf          Else            ValConst + 1          EndIf          ValConst$ = Str(ValConst)        EndIf        ;        ; Search for the constant in the list of constants to        ; update its calculated value and its lineage:        ;        ECIndex$ = Str(ListIndex(ElementsList())) + "/"        ;        Parents$ = ElementsList()\Parents        If Parents$ = "" : Parents$ = "/" : EndIf        ;        PushListPosition(ElementsList())        ;        If CheckIfElementExistsInList(LCase(LineC$), #PBBConstante) > -1          ElementsList()\Value = ValConst$          ; Record the name of the enumeration to which the constant belongs:          ElementsList()\DeclarationDetails = EnumerationName$          ;          ; The information just added to the list will be used by 'FillDetailREGadget'          ; to display a mention giving the constant's value and the enumeration it belongs to,          ; in the constant's description.          ;          ; *******  Update the constant's lineage *******          ; For the special case of constants/enumerations lineage,          ; reverse the usual logic by considering that the enumeration          ; is the 'child' of its constants (even though the constants are          ; contained inside the enumeration's code).          ; Thus, the enumeration will be considered 'used' if at least          ; one of its constants is used.          If FindString(ElementsList()\Children, "/" + ECIndex$) = 0            If ElementsList()\Children = ""              ElementsList()\Children = "/"            EndIf            ElementsList()\Children + ECIndex$          EndIf          ;          EPIndex$ = Str(ListIndex(ElementsList())) + "/"          If FindString(Parents$, "/" + EPIndex$) = 0            Parents$ + EPIndex$          EndIf          ;        EndIf        ;        PopListPosition(ElementsList())        If Parents$ <> "/"          ElementsList()\Parents = Parents$        EndIf        ;      EndIf    EndIf  Until PosInEnum = 0EndProcedure;Procedure SetOneListOfAllElements(TypeOfElement, PriorityMode = #WorkInBackGround, OneFileOnly$ = "", *Limits.Point = 0)  ;  ; This procedure builds the complete list of elements  ; defined and contained in the 'PBBListOfFiles$' file list and updates  ; the ElementsList() based on the elements found.  ;  ; CompleteListOfFiles must have been called before calling this procedure  ; so that the global variable PBBListOfFiles$ is populated.  ;  ; This procedure is designed to work in the background and can interrupt  ; after 200 milliseconds, but it will continue the exploration if PriorityMode = '#FinishCompletionNow'.  ;  ; If the 'OneFileOnly$' parameter is provided, the exploration will be limited to the file  ; whose name appears in this parameter. This option is used for partial updates.  ;  ; To fully accomplish its task, this procedure is split into two distinct steps  ; which will be indicated in the code:  ; • Step 1: We repeatedly call 'CompleteListOfAllElements()' for each file and  ;           for each type of element, until everything is explored.  ; • Step 2: We re-examine the code files to check if procedures are  ;           mentioned with 'Declare' before their definition.  ; • Step 3: For constants, we will check if they are declared inside enumerations.  ;           If so, we will deduce the value assigned to them.  ;           We will also remember the names of the enumerations to which  ;           the constants belong (when applicable). Later, this  ;           will allow us to decide whether an enumeration is used or not.  ;           (We will consider it used if at least one of its constants is  ;            used).  ; • Step 4: For the special case of 'Shared' variables, we need to explore  ;           the code outside of procedures. Further explanations can be found  ;           under the mention 'Step 4' below.  ;  Shared PBBLComment$, ExplorationStep.f  ;  Static PosInFileList, PosInVarList  ;  Protected LineC$, FileName$, *SearchString.String, *SearchStringCS.string  Protected CLE_StartTime, PosInCode, EndPos   ;  Protected cont, OFileName$, CVal$   Protected AddTypePos, AddTypeEndPos, pp, ReplaceDefinition  ;  Protected VariableSpecies$, VariableSubSpecies$  ;  Protected ElementName$, ElementNameLCase$, SourceFile$, ElementStartingPos, ElementEndingPos  Protected ElementStartingLine, ElementEndingLine, CompleteElementDeclaration$  ;  ;  If PBBListOfFiles$ = ""    ; The application started with no files to explore.    ListCompletionAll(TypeOfElement) = #ListCompletion_Done  EndIf  ;  If ListCompletionAll(TypeOfElement) < #ListCompletion_Done ; No need to redo everything if it's already been done.    ;    CLE_StartTime = ElapsedMilliseconds()    ;    ; ---------------------------------------    ;                Step 1    ; ---------------------------------------    ;    ; Complete the lists:    ;    If ListCompletionAll(TypeOfElement) < #ListCompletion_StageCompleted      If ListCompletionAll(TypeOfElement) = #ListCompletion_Undone        ; Starting or restarting from zero. Some things need to be initialized:        PosInFileList = 0        ListCompletionReference$(TypeOfElement) = ""      EndIf      ;      Repeat        If OneFileOnly$          ;          CompleteListOfAllElements(OneFileOnly$, TypeOfElement, PriorityMode, CLE_StartTime, *Limits)          FileName$ = ""        ElseIf ListCompletionAll(TypeOfElement) = #ListCompletion_Pending          ;          ; Since we are in 'Pending' (continuing an already started exploration),          ; CompleteListOfAllElements() has memorized the name of the file being examined and          ; it is unnecessary to send it again.          ; So, call this procedure with the first parameter empty:          CompleteListOfAllElements("", TypeOfElement, PriorityMode, CLE_StartTime)          ;          FileName$ = "Loop" ; The value "Loop" is a decoy to continue the loop.          ;        ElseIf ListCompletionAll(TypeOfElement) = #ListCompletion_Undone Or ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted          ;          ; Exploration will begin for this type of element.          PosInFileList + 1          LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)          If LineC$            FileName$ = StringField(LineC$, 1, #TAB$)            ;            CompleteListOfAllElements(FileName$, TypeOfElement, PriorityMode, CLE_StartTime)            ;            ExplorationStep = Round(ExplorationStep, #PB_Round_Down) + PosInFileList / CountString(PBBListOfFiles$, #CR$)            ;          Else            FileName$ = ""          EndIf        EndIf      Until FileName$ = "" Or (ListCompletionAll(TypeOfElement) = #ListCompletion_Pending)      ;      If FileName$ = ""        If TypeOfElement = #PBBVariable          ; Since we only pass here once,          ; initialize the variables that will be needed to complete          ; step 4 shown below:          PosInVarList = 0        ElseIf TypeOfElement = #PBBProcedure          ; For step 2          PosInFileList = 0        EndIf      EndIf    EndIf    ;    ;    If ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted      ;      If TypeOfElement = #PBBProcedure        ; ---------------------------------------        ;                Step 2        ; ---------------------------------------        ;        ; To complete the available information about the        ; procedures, we will check if they are mentioned        ; as 'Declare' anywhere in the code.        ;        ; Go through the list of files to search for the 'Declare' mentions:        ;        If OneFileOnly$          *SearchString = GetPointedCodeFromFile(OneFileOnly$, #True)          If *Limits            PosInCode = *Limits\x            EndPos    = *Limits\y          Else            PosInCode = 0            EndPos    = 0          EndIf          SetDeclarePositionsForProc(OneFileOnly$, *SearchString.String, PosInCode, EndPos)        Else          Repeat            PosInFileList + 1            ; Extract a line from the list of files:            LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)            If LineC$              FileName$ = StringField(LineC$, 1, #TAB$)              *SearchString = GetPointedCodeFromFile(FileName$, #True)              PosInCode = 0              SetDeclarePositionsForProc(FileName$, *SearchString)            EndIf          Until LineC$ = "" Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)          ;          If LineC$            ProcedureReturn #Completion_Uncomplete          EndIf        EndIf        ;      ElseIf TypeOfElement = #PBBConstante        ; ---------------------------------------        ;                Step 3        ; ---------------------------------------        ;        ; For the specific case of constants, we will check if they        ; are declared inside enumerations. If so, we will deduce        ; the value assigned to them.        ;        ; Go through all the enumerations identified during        ; the exploration:        ;        ForEach ElementsList()          If ElementsList()\Type = #PBBEnumeration            ElementName$                = ElementsList()\Name            SourceFile$                 = ElementsList()\FileName            ElementStartingPos          = ElementsList()\StartingPos            ElementEndingPos            = ElementsList()\EndingPos            CompleteElementDeclaration$ = ElementsList()\Declaration            ;            cont = 0            If OneFileOnly$              If OneFileOnly$ = SourceFile$                If *Limits                  If (ElementStartingPos >= *Limits\x And ElementStartingPos <= *Limits\y) Or (ElementEndingPos >= *Limits\x And ElementEndingPos <= *Limits\y) Or (*Limits\x >= ElementStartingPos And *Limits\x <= ElementEndingPos)                    cont = 1                  EndIf                Else                  cont = 1                EndIf              EndIf            Else              cont = 1            EndIf            ;            If cont              EvaluateEnumConstantesValue(ElementName$, SourceFile$, ElementStartingPos, ElementEndingPos)            EndIf          EndIf        Next        ;        If OneFileOnly$          ; In the case where we are performing a partial data update,          ; we just checked if the modified part of the code contained enumerations          ; and if their constants needed updating.          ; Since this check is partial, we have not yet looked          ; if the modified part of the code contained constants whose value is          ; set in an enumeration located outside the modified area.          ; We will now do that:          ;          ForEach ElementsList()            If ElementsList()\Type = #PBBConstante              ElementNameLCase$           = ElementsList()\NameLCase              SourceFile$                 = ElementsList()\FileName              ElementStartingPos          = ElementsList()\StartingPos              ElementEndingPos            = ElementsList()\EndingPos              ;              cont = 0              If OneFileOnly$ = SourceFile$                If *Limits                  If (ElementStartingPos >= *Limits\x And ElementStartingPos <= *Limits\y) Or (ElementEndingPos >= *Limits\x And ElementEndingPos <= *Limits\y) Or (*Limits\x >= ElementStartingPos And *Limits\x <= ElementEndingPos)                    cont = 1                  EndIf                Else                  cont = 1                EndIf              EndIf              ;              If cont                ; The constant is in the modified part of the 'OneFileOnly$' file.                ; Check if it is part of an enumeration:                                PushListPosition(ElementsList())                ForEach ElementsList()                  If ElementsList()\Type = #PBBEnumeration                    ElementName$                = ElementsList()\Name                    SourceFile$                 = ElementsList()\FileName                    ElementStartingPos          = ElementsList()\StartingPos                    ElementEndingPos            = ElementsList()\EndingPos                    *SearchString = GetPointedElementContentFromFile(SourceFile$, ElementStartingPos, ElementEndingPos, #True)                    ;                    If FindInPBPointedCode(*SearchString, ElementNameLCase$)                      EvaluateEnumConstantesValue(ElementName$, SourceFile$, ElementStartingPos, ElementEndingPos)                    EndIf                  EndIf                Next                PopListPosition(ElementsList())              EndIf            EndIf          Next        ;        EndIf        ;        ; Now let's calculate the value of constants that are not part of an enumeration:        ;        ForEach ElementsList()          If ElementsList()\Type = #PBBConstante And ElementsList()\Value = ""            SourceFile$                 = ElementsList()\FileName            ElementStartingPos          = ElementsList()\StartingPos            ElementEndingPos            = ElementsList()\EndingPos            ;            cont = 0            If OneFileOnly$              If OneFileOnly$ = SourceFile$                If *Limits                  If (ElementStartingPos >= *Limits\x And ElementStartingPos <= *Limits\y) Or (ElementEndingPos >= *Limits\x And ElementEndingPos <= *Limits\y) Or (*Limits\x >= ElementStartingPos And *Limits\x <= ElementEndingPos)                    cont = 1                  EndIf                Else                  cont = 1                EndIf              EndIf            Else              cont = 1            EndIf            ;            If cont              PushListPosition(ElementsList())              CVal$ = ComputeConstanteValue(ElementsList()\Declaration)              PopListPosition(ElementsList())              ElementsList()\Value = CVal$            EndIf          EndIf        Next        ;      ElseIf TypeOfElement = #PBBVariable        ;        ; ---------------------------------------------------        ;                       Step 4        ; ---------------------------------------------------        ;        ; For the particular case of variables, we need to resolve a problem        ; that is specific to them: 'Shared' variables may have been defined        ; in the main code before being declared as 'Shared' by one or        ; more procedures.        ;        ; The recent exploration, which identified the 'Shared' variables,        ; was only based on information within the procedures and macros.        ; Therefore, it is possible that the type of these variables        ; (array, list, or structured) has not yet been established.        ;        ; Here's an example of a program where it is impossible to know the type        ; of 'MyString' without searching for it outside the procedures:        ;        ;               MyString.string\s = "This is a test"        ;               Procedure test()        ;                 Shared MyString  ; The type of 'MyString' is not indicated here.        ;                 Debug MyString\s ; Yet, this program works.        ;               EndProcedure        ;               test()        ;        ; To be sure to retrieve the type of 'Shared' variables, we need        ; to re-examine the code to see if it contains information        ; that will allow us to complete our list.        ;        ForEach ElementsList()          If ElementsList()\Type = #PBBVariable            ; Extract a line from the list of variables:            ElementName$        = ElementsList()\Name            ElementNameLCase$   = ElementsList()\NameLCase            OFileName$          = ElementsList()\FileName            VariableSpecies$    = ElementsList()\VariableSpecies            ElementStartingPos  = ElementsList()\StartingPos            ElementStartingLine = ElementsList()\StartingLine            ;            ;            If Left(VariableSpecies$, 6) = "Shared" And (FindString(ElementName$, ".") = 0 Or FindString(VariableSpecies$, " Var"))              ; The line declaring the variable as 'Shared' did not necessarily specify the type              ; of the variable (if it's a structured variable) nor that it might be              ; an array or a list. These are the pieces of information we will look for              ; at the beginning of the code.                            ; Go through the list of files to search for the variable:              PosInFileList = 0              Repeat                PosInFileList + 1                ; Extract a line from the list of files:                LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)                If LineC$                  FileName$ = StringField(LineC$, 1, #TAB$)                  *SearchString = GetPointedCodeFromFile(FileName$, #True)                  ; Logically, it is the very first time the variable will be mentioned in the code                  ; that it will be defined in the most complete way possible.                  ; Therefore, we only perform one search inside each file:                  PosInCode = FindInPBPointedCode(*SearchString, ElementNameLCase$, 1, #CheckAll | #CheckOneKeyWordOnly)                  ;                  ; Continue only if we have found the variable in a file different from the one where                  ; it was previously located, or at an earlier position in the code:                  If PosInCode And (OFileName$ <> FileName$ Or PosInCode < ElementStartingPos)                    CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementNameLCase$, PosInCode, #True)                    ;                    ReplaceDefinition = 0                    ;                    AddTypePos = 0                    AddTypeEndPos = 0                    If FindString(ElementNameLCase$, ".") = 0                      pp = PosInCode + Len(ElementNameLCase$)                      If FastMid(*SearchString\s, pp, 1) = "."                        ; We have found a type definition that our variable did not have.                        ReplaceDefinition = 1                      ElseIf Left(CompleteElementDeclaration$, 7) = "define."                        AddTypePos = 8                        AddTypeEndPos = AddTypePos                        While AddTypeEndPos <= Len(CompleteElementDeclaration$) And FindString(ListPBSep$, PeekS(@CompleteElementDeclaration$ + (AddTypeEndPos - 1) * SizeOf(CHARACTER), 1)) = 0                          AddTypeEndPos + 1                        Wend                        ReplaceDefinition = 1                      EndIf                    EndIf                    If Left(CompleteElementDeclaration$, 3) = "dim"                      VariableSubSpecies$ = "Array"                      ReplaceDefinition = 1                    ElseIf Left(CompleteElementDeclaration$, 7) = "newlist"                      VariableSubSpecies$ = "List"                      ReplaceDefinition = 1                    ElseIf Left(CompleteElementDeclaration$, 7) = "newmap"                      VariableSubSpecies$ = "Map"                      ReplaceDefinition = 1                    Else                      VariableSubSpecies$ = "Var"                    EndIf                    ;                    If ReplaceDefinition                      pp = PosInCode + Len(ElementNameLCase$)                      While FindString(",:=\(" + #CR$, FastMid(*SearchString\s, pp, 1)) = 0 : pp + 1 : Wend                      ;                      ; The search was conducted on the code in LCase version.                      ; Retrieve the version with uppercase letters:                      *SearchStringCS.string = GetPointedCodeFromFile(FileName$)                      ElementName$ = Trim(FastMid(*SearchStringCS\s, PosInCode, pp - PosInCode))                      ;                      ElementStartingLine = CountString(FastMid(*SearchString\s, 1, PosInCode), #CR$) + 1                      ElementEndingLine = ElementStartingLine                      ; Perform another search for the full declaration (not just the variable name)                      ; to determine where it is located in the code, in order to get ElementStartingPos                      ; and ElementEndingPos.                      ElementStartingPos = FindInPBPointedCode(*SearchString, CompleteElementDeclaration$, 1, #CheckAll | #CheckOneKeyWordOnly)                      ElementEndingPos = ElementStartingPos + Len(CompleteElementDeclaration$)                      ; and retrieve its copy with uppercase letters:                      CompleteElementDeclaration$ = Trim(FastMid(*SearchStringCS\s, ElementStartingPos, Len(CompleteElementDeclaration$)))                      ; If 'Define' is encountered, add the type given by 'Define':                      If AddTypePos And FindString(ElementName$, ".") = 0                        ElementName$ + "." + FastMid(CompleteElementDeclaration$, AddTypePos, AddTypeEndPos - AddTypePos)                      EndIf                      ElementsList()\Type = #PBBVariable                      ElementsList()\Name = ElementName$                      ElementsList()\NameLCase = PurifyElementName(ElementName$)                      ElementsList()\FileName = FileName$                      ElementsList()\Declaration = CompleteElementDeclaration$                      ElementsList()\StartingLine = ElementStartingLine                      ElementsList()\EndingLine = ElementEndingLine                      ElementsList()\StartingPos = ElementStartingPos                      ElementsList()\EndingPos = ElementEndingPos                      ElementsList()\VariableSpecies = "Shared " + VariableSubSpecies$                      ElementsList()\Comment = PBBLComment$                    EndIf                  EndIf                EndIf              Until LineC$ = ""            EndIf          EndIf        Next        ;              EndIf      ;      ; The exploration is complete for this element.      ListCompletionAll(TypeOfElement) = #ListCompletion_Done      ProcedureReturn #Completion_Completed      ;    Else      ; The exploration is incomplete.      ProcedureReturn #Completion_Uncomplete    EndIf    ;  EndIf  ProcedureReturn #Completion_CompletedEndProcedure;Procedure SetAllListsOfAllElements(PriorityMode = #WorkInBackGround, OneFileOnly$ = "", *Limits = 0)  ;  ; This procedure goes through all types of elements and completes  ; the ElementsList() based on the found elements.  ;  ; This procedure is designed to work in the background  ; and will stop after 200 milliseconds, but it will continue  ; the exploration if PriorityMode = '#FinishCompletionNow'.  ;  Protected TypeOfElement  ;  For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)    If OneFileOnly$      ListCompletionAll(TypeOfElement) = #ListCompletion_Pending    EndIf    If ListCompletionAll(TypeOfElement) < #ListCompletion_Done      SetOneListOfAllElements(TypeOfElement, PriorityMode, OneFileOnly$, *Limits)      If PriorityMode <> #FinishCompletionNow        ProcedureReturn #Completion_Uncomplete      EndIf    EndIf  Next  ProcedureReturn #Completion_CompletedEndProcedure;; ----------------------------------------------------------------------------------;-                 Procedures for the second phase of exploration;Procedure FindElementInCode(*SearchString.String, PosInCode, FileName$)  ;  ; Searches in the code contained in *SearchString if the current  ; element from the ElementsList() is found there.  ; *SearchString must be in LCase format.  ;  CLOU_SearchElementAgain:   PosInCode = FindInPBPointedCode(*SearchString, ElementsList()\NameLCase, PosInCode, #CheckAll | #CheckOneKeyWordOnly)  If PosInCode And ElementsList()\FileName = FileName$ And PosInCode >= ElementsList()\StartingPos And PosInCode <= ElementsList()\EndingPos    ; We just found the element's declaration. We are not interested in this.    ; We only track cases where the element appears in another element or in    ; the main body of the program (outside of elements).    PosInCode = ElementsList()\EndingPos + 1    Goto CLOU_SearchElementAgain  EndIf  ;  If PosInCode    ;    ; The element name was found in the code contained in *SearchString\s.    ;    ; Proceed with additional checks:    ;    If ElementsList()\Type = #PBBProcedure      ; For procedures, check that the procedure name      ; is followed by an opening parenthesis.      PosInCode + Len(ElementsList()\NameLCase)      ; Skip the spaces that follow:      While PeekC(@*SearchString\s + (PosInCode - 1) * SizeOf(CHARACTER)) = #Space : PosInCode + 1 : Wend      If FastMid(*SearchString\s, PosInCode, 1) <> "("        Goto CLOU_SearchElementAgain      EndIf    ElseIf ElementsList()\Type = #PBBStructure      ; For structures, check that the structure name      ; is preceded by a backslash or a period.      If PosInCode > 1 And FastMid(*SearchString\s, PosInCode - 1, 1) <> "\" And FastMid(*SearchString\s, PosInCode - 1, 1) <> "."        PosInCode + Len(ElementsList()\NameLCase)        Goto CLOU_SearchElementAgain      EndIf    EndIf  EndIf  ;  ProcedureReturn PosInCodeEndProcedure;Procedure FindElementAndUpdateFiliation(*SearchString.String, FileName$, StartPos = 0, EndPos = 0)  ;  ; Searches in the code contained in *SearchString if the current  ; element from the ElementsList() is found there.  ; If so, it checks if it is inside another element.  ; If that's the case, the containing element will be set as 'Parent'  ; and the contained element will be set as "Child", except for the  ; special case of enumerations (not handled in this procedure).  ;  ; *SearchString must be in LCase format.  ;  Protected found, OutOfElementLinePos$, LinePos, OOELinePos$  Protected Parents$, ECIndex$, EPIndex$  ;  If StartPos : StartPos - 1 : EndIf  ;  If ElementsList()\Type <> #PBBEnumeration    ; The special case of enumerations has already been handled by the procedure    ; EvaluateEnumConstantesValue() which was called by SetOneListOfAllElements().    Repeat      StartPos = FindElementInCode(*SearchString.String, StartPos + 1, FileName$)      If EndPos And StartPos > EndPos        StartPos = 0      EndIf      ;      ; Search for the element inside which the found position lies:      If StartPos        PushListPosition(ElementsList())        ;        ECIndex$ = Str(ListIndex(ElementsList())) + "/"        ;        Parents$ = ElementsList()\Parents        If Parents$ = "" : Parents$ = "/" : EndIf        OutOfElementLinePos$ = ElementsList()\OutOfElementLinePos        ;        found = 0        ForEach ElementsList()          If ElementsList()\FileName = FileName$ And StartPos >= ElementsList()\StartingPos And StartPos <= ElementsList()\EndingPos            ;            EPIndex$ = Str(ListIndex(ElementsList())) + "/"            ;            found = 1            If FindString(Parents$, "/" + EPIndex$) = 0              Parents$ + EPIndex$            EndIf            If FindString(ElementsList()\Children, "/" + ECIndex$) = 0              If ElementsList()\Children = ""                ElementsList()\Children = "/"              EndIf              ElementsList()\Children + ECIndex$            EndIf          EndIf        Next        ;        PopListPosition(ElementsList())        ;        If found = 0          ; The element was not found inside another element.          ; It has been found in the main body of the program.          EPIndex$ = "-1/"          If FindString(Parents$, "/" + EPIndex$) = 0            Parents$ + EPIndex$          EndIf          ;          ; Calculate the line number where it was found:          LinePos = CountString(FastMid(*SearchString\s, 1, StartPos), #CR$) + 1          ; Record the file name and line number in the 'OutOfElementLinePos' field          ; of the element if it's not already there:          OOELinePos$ = FileName$ + "," + Str(LinePos) + "/"          If FindString(ElementsList()\OutOfElementLinePos, OOELinePos$) = 0            ElementsList()\OutOfElementLinePos + OOELinePos$          EndIf          ;          If ElementsList()\Used = #False            ; If the element was found in the main code (outside procedures and elements),            ; consider it as 'Used'.            ElementsList()\Used = #True            ListOfUsedElementsNbr(ElementsList()\Type) + 1          EndIf        EndIf        If Parents$ <> "/"          ElementsList()\Parents = Parents$        EndIf        ;      EndIf    Until StartPos = 0  EndIf  ;EndProcedure;Procedure UpdateElementsUse()  ;  ; Loops through the ElementsList() looking for used elements  ; and marks all 'Children' of these elements as used.  ; The operation is repeated until there are no more changes.  ;  Protected Changes, IChildPos, IChild$, ChildrenList$  ;  Repeat    ;    Changes = #False    ;    ForEach ElementsList()      If ElementsList()\Used And ElementsList()\Children        PushListPosition(ElementsList())        ;        ChildrenList$ = ElementsList()\Children        IChildPos = 1 ; Skip the first "/".        ;        Repeat          IChildPos + 1          IChild$ = StringField(ChildrenList$, IChildPos, "/")          If IChild$            SelectElement(ElementsList(), Val(IChild$))            If ElementsList()\Used = #False              ElementsList()\Used = #True              ListOfUsedElementsNbr(ElementsList()\Type) + 1              Changes = #True            EndIf          EndIf        Until IChild$ = ""        ;        PopListPosition(ElementsList())      EndIf    Next  Until Changes = #FalseEndProcedure;Procedure SetUsageOfElements(PriorityMode, Reset = 0)  ;  ; This procedure is designed to work in the background  ; and will interrupt after 200 milliseconds, but it will complete  ; the exploration if PriorityMode = '#FinishCompletionNow'.  ;  Shared ExplorationStep.f  ;  Static PosInFileList, PosInElementList  ;  Protected TypeOfElement, *SearchString.String, lineC$, FileName$  ;  If Reset    PosInFileList = 1    PosInElementList = 0  EndIf  ;  Protected TimeSOOEC = ElapsedMilliseconds()  ;  Repeat    lineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)    If lineC$      FileName$ = StringField(lineC$, 1, #TAB$)      ManageWaitingWindow(PriorityMode, GetFilePart(FileName$), GetFilePart(FileName$))      If FileName$        *SearchString = GetPointedCodeFromFile(FileName$, #True)        If PosInElementList          SelectElement(ElementsList(), PosInElementList)          PosInElementList = 0        Else          ResetList(ElementsList())        EndIf        While NextElement(ElementsList())          FindElementAndUpdateFiliation(*SearchString.String, FileName$)          If PriorityMode <> #FinishCompletionNow And ElapsedMilliseconds() - TimeSOOEC > 200            PosInElementList = ListIndex(ElementsList())            ExplorationStep = Round(ExplorationStep, #PB_Round_Down) + ListIndex(ElementsList()) / ListSize(ElementsList())            Break          EndIf        Wend        If PosInElementList = 0          PosInFileList + 1          ExplorationStep = Round(ExplorationStep, #PB_Round_Down) + 1        EndIf      EndIf    EndIf  Until lineC$ = "" Or (PriorityMode <> #FinishCompletionNow And ElapsedMilliseconds() - TimeSOOEC > 100)  ;  If lineC$ = ""    PosInFileList = 1    UpdateElementsUse()    For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)      ListCompletionAll(TypeOfElement)  = #ListCompletion_Done      ListCompletionUsed(TypeOfElement) = #ListCompletion_Done    Next    ProcedureReturn #Completion_Completed  Else    ProcedureReturn #Completion_Uncomplete  EndIfEndProcedure;; **********************************************************************************;;-             Procedures related to partial updates of element lists;; **********************************************************************************;Procedure FindStartOfDifference(*OldContent.String, *NewContent.String, EndExam = 0)  ;  ; Searches for the position where the strings *OldContent\s and *NewContent\s  ; differ.  ;  ; The string is first split into sections, and each section is examined one by one.  ; When a section differs between the two strings, it is further split into smaller  ; sections for examination, continuing this process until the position where the   ; differences begin is found.  ;  Protected  StartExam, maxpos, BlockDivider, mDiff, Diff, Fork, Pos  ;  StartExam = 1  If EndExam = 0    EndExam = Len(*OldContent\s) + 1  EndIf  maxpos = EndExam  BlockDivider = EndExam / 1000 ; Start with sections of 1000 characters by default.  If BlockDivider < 6 : BlockDivider = 6 : EndIf ; But divide into at least 6 sections.  mDiff = 0  Repeat    Diff = 0    Fork = (EndExam - StartExam + 1) / BlockDivider    If Fork >= 1      For Pos = 1 To (BlockDivider + 1) ; BlockDivider + 1 -> To make an extra pass due to rounding on 'Fork'.        If FastMid(*OldContent\s, StartExam, Fork) <> FastMid(*NewContent\s, StartExam, Fork)          Diff = 1          mDiff = 1          Break        EndIf        StartExam + Fork      Next      If Diff        ; A difference has been found.        ; The fork become the section to split and to examine in detail :        EndExam = StartExam + Fork        If EndExam > maxpos : EndExam = maxpos : EndIf      EndIf    EndIf  Until Diff = 0  If mDiff    ; Finish the search by comparing character by character until    ; the first differing character is found:    While FastMid(*OldContent\s, StartExam, 1) = FastMid(*NewContent\s, StartExam, 1) And StartExam < maxpos      StartExam + 1    Wend    ;    If StartExam <= maxpos      ProcedureReturn StartExam    EndIf  EndIf  ProcedureReturn 0EndProcedure;Procedure FindIDENotations(*Content.String)  ;  ; Examine the last 1000 characters of the string  ; to locate the position of the IDE annotations.  ;  ; Go back through the code until something other  ; than a line starting with ";" is found.  ;  Protected ExamString$, ns, nst  ;  ExamString$ = ReverseString(Mid(*Content\s, Len(*Content\s) - 2000, 2000))  ns = 1  nst = 2 ; If the entire string ends with a carriage return, skip it.  Repeat    nst = FindString(ExamString$, #CR$, nst)    If nst And FastMid(ExamString$, nst - 1, 1) = ";"      ns = nst      nst + 1    Else      nst = 0    EndIf  Until nst = 0  ;;   If ns And FindString(Mid(*Content\s, Len(*Content\s) - ns), "IDE Options") = 0;     alert("FindIDENotations Error : ''IDE Options'' is not in text." + #CR$ + FastMid(*Content\s, Len(*Content\s) - ns));   EndIf  ;  ProcedureReturn Len(*Content\s) - ns + 2EndProcedure;Procedure.s UpdateIndexList(IndexList$, PosElement, AddSup)  ;  ; This procedure is intended to update the ElementsList()\Parents  ; and ElementsList()\Children fields when an element needs to be deleted or added,  ; and these fields have already been indexed.  ;  Protected IndexPos, Index$, Index  Protected NIndexList$ ; Return value.  ;  If AddSup < 0    ; An element has been deleted.    IndexList$ = ReplaceString(IndexList$, "/" + Str(PosElement) + "/", "/")  EndIf  ;  NIndexList$ = ""  IndexPos = 1 ; Skip the first "/".  ;  Repeat    IndexPos + 1    Index$ = StringField(IndexList$, IndexPos, "/")    If Index$      Index = Val(Index$)      If Index >= PosElement        Index$ = Str(Index + AddSup)      EndIf      NIndexList$ + Index$ + "/"    EndIf  Until Index$ = ""  ProcedureReturn "/" + NIndexList$EndProcedure;Procedure PartialUpdateOfElementsList(*OldContent.String, *NewContent.String, FileName$)  ;  ; To avoid performing a full exploration of the files each time one of them is modified,  ; we will isolate the part of the code that has changed, and then update our data based on the changes.  ;  ; Specifically, this involves:  ; • Updating the 'OutOfElementContent\s' string, which contains a compilation  ;   of all the files stripped of their elements, keeping only the 'outside element' code  ;   (excluding procedures, macros, structures, etc.)  ; • Updating the start and end positions of the elements in the code  ;   for all elements that are located after the modified section.  ; • Removing elements that no longer appear in the modified section.  ; • Marking as 'unused' all elements that were used by code in the modified section.  ; • Creating or recreating the elements that now belong to the modified section  ;   (some may have been permanently deleted, others may have been added).  ; • Rechecking the usage of elements based on the new code.  ;  Shared BackgroundTasksCompletion ; To know if the deep exploration is complete.  ;  ; Variable to determine which part of the code has been modified:  Protected ModStartPos, EndExamOld, EndExamNew, DiffInverse  Protected ROldContent.String, RNewContent.String  Protected ModOldEndPos, ModNewEndPos, ModStartingLine, ModOldEndingLine, ModNewEndingLine  ;  ; Variable for updating elements based on the detected change:  Protected MustBeUpdated$, ExtendedStartingPos, ExtendedEndingPos, PosElement$, PosElement  Protected ChildrenList$, IChildPos, IChild$, IndexPos, IIndex$  Protected *SearchString.String, PosInFileList, line$  Protected pc, mpc, pcd, LinePosInOutOfElement, NewContentLCase.String  ;  ;  If BackgroundTasksCompletion <> #BackgroundTasksCompleted    ; The deep exploration is still in progress.    ; Restart the exploration from the beginning:    BackgroundTasksCompletion = #BackgroundTasksMustRestart    ProcedureReturn #False  EndIf  ;  ; Determine which part of the file has been modified:  ;  EndExamOld = FindIDENotations(*OldContent) - 1  EndExamNew = FindIDENotations(*NewContent) - 1  ;  ModStartPos = FindStartOfDifference(*OldContent, *NewContent, min(EndExamOld, EndExamNew))  If ModStartPos    ;    ; The file has really been modified.    ; Determine the end of the modified section:    ;    ModOldEndPos = EndExamOld    ModNewEndPos = EndExamNew    ;    ; Search for the ending of differences between the two files:    ROldContent.String\s = ReverseString(FastMid(*OldContent\s, ModStartPos, EndExamOld - ModStartPos + 1))    RNewContent.String\s = ReverseString(FastMid(*NewContent\s, ModStartPos, EndExamNew - ModStartPos + 1))    DiffInverse = FindStartOfDifference(ROldContent, RNewContent)    ;    If DiffInverse      ; DiffInverse can be null if differences go to the end of the files.      ModOldEndPos - DiffInverse + 2      ModNewEndPos - DiffInverse + 2    EndIf    ;    ; Expand the modified section to cover at least one full line:    While ModStartPos > 2 And FastMid(*OldContent\s, ModStartPos - 1, 1) <> #CR$ : ModStartPos - 1 : Wend    While ModOldEndPos < EndExamOld And FastMid(*OldContent\s, ModOldEndPos, 1) <> #CR$ : ModOldEndPos + 1 : ModNewEndPos + 1 : Wend    ;    ; ______________________________________________________________________________________________________    ;    ; The identification of the modified section and its new version is complete.    ; We can now proceed to update the ElementsList().    ;    If ModOldEndPos > ModStartPos Or ModNewEndPos > ModStartPos      ModStartingLine = CountString(FastMid(*OldContent\s, 1, ModStartPos), #CR$) + 1      ModOldEndingLine = ModStartingLine + CountString(FastMid(*OldContent\s, ModStartPos, ModOldEndPos - ModStartPos), #CR$) + 1      ModNewEndingLine = ModStartingLine + CountString(FastMid(*NewContent\s, ModStartPos, ModNewEndPos - ModStartPos), #CR$) + 1      ;      ; The positions of the elements in the code may have changed,      ; due to the modifications we've just detected in the code.      ; Update ElementsList() to reflect the new positions:      ;      ExtendedStartingPos = ModStartPos      ExtendedEndingPos = ModNewEndPos      ;      ForEach ElementsList()        ; Check if the element is mentioned in the 'out-of-element' code of the file        ; that was just modified, and adjust the reference positions:        pc = 0        Repeat          pc = FindString(ElementsList()\OutOfElementLinePos, FileName$ + ",", pc + 1)          If pc            mpc = pc            pc + Len(FileName$ + ",")            pcd = FindString(ElementsList()\OutOfElementLinePos, "/", pc)            LinePosInOutOfElement = Val(FastMid(ElementsList()\OutOfElementLinePos, pc, pcd - pc))            If LinePosInOutOfElement < ModStartingLine              ; The element is mentioned before the modified section. Do nothing.            ElseIf LinePosInOutOfElement >= ModOldEndingLine              ; The element is mentioned after the modified section. Adjust the position              ; of the line where it is mentioned.              LinePosInOutOfElement - ModOldEndingLine + ModNewEndingLine              ElementsList()\OutOfElementLinePos = FastLeft(ElementsList()\OutOfElementLinePos, pc - 1) + Str(LinePosInOutOfElement) + FastMid(ElementsList()\OutOfElementLinePos, pcd)            Else              ; The element is mentioned inside the old version of the modified section.              ; Remove the reference to this mention. It will be recreated if this element              ; is still mentioned in the new version of the code:              ElementsList()\OutOfElementLinePos = FastLeft(ElementsList()\OutOfElementLinePos, mpc - 1) + FastMid(ElementsList()\OutOfElementLinePos, pcd + 1)              If ElementsList()\OutOfElementLinePos = ""                ; This was the only place the element was mentioned in the 'out-of-element' code.                ; Therefore, indicate that the element is no longer mentioned there:                ElementsList()\Parents = ReplaceString(ElementsList()\Parents, "/-1/", "/")                If ElementsList()\Parents = "/" : ElementsList()\Parents =  "" : EndIf              EndIf              pc = mpc - 1            EndIf          EndIf        Until pc = 0        ;        ; Check if the element is defined into the file that was just modified:        If ElementsList()\FileName = FileName$          ;          If ElementsList()\EndingPos < ModStartPos            ;            ; The element is entirely before the modified part.            ; Do nothing.          ElseIf ElementsList()\StartingPos > ModOldEndPos            ;            ; The element is entirely after the modified part.            ; Update the start and end positions of the element in the code:            ElementsList()\StartingPos = ElementsList()\StartingPos + ModNewEndPos - ModOldEndPos            ElementsList()\StartingLine = CountString(FastMid(*NewContent\s, 1, ElementsList()\StartingPos), #CR$) + 1            ElementsList()\EndingPos = ElementsList()\EndingPos + ModNewEndPos - ModOldEndPos            ElementsList()\EndingLine = ElementsList()\StartingLine + CountString(FastMid(*NewContent\s, ElementsList()\StartingPos, ElementsList()\EndingPos - ElementsList()\StartingPos), #CR$) + 1            ;          ElseIf ElementsList()\StartingLine < ModStartingLine And ElementsList()\EndingPos >= ModStartPos            ;            ; The start of the element is above the modified area, but the end            ; is inside or after the modified area. We need to adjust its            ; end position and we will need to update its 'Children' list.            ElementsList()\EndingPos = ElementsList()\EndingPos + ModNewEndPos - ModOldEndPos            ElementsList()\EndingLine = ElementsList()\StartingLine + CountString(FastMid(*NewContent\s, ElementsList()\StartingPos, ElementsList()\EndingPos - ElementsList()\StartingPos), #CR$) + 1            ;            ; If the element overflows the modified area, adjust the ExtendedStartingPos            ; and ExtendedEndingPos, so everything can be re-examined in a later phase.            If ElementsList()\StartingPos < ExtendedStartingPos : ExtendedStartingPos = ElementsList()\StartingPos : EndIf            If ElementsList()\EndingPos > ExtendedEndingPos : ExtendedEndingPos = ElementsList()\EndingPos : EndIf            ;            PushListPosition(ElementsList())            ;            PosElement$ = "/" + Str(ListIndex(ElementsList())) + "/"            ;            PushListPosition(ElementsList())            ;            ChildrenList$ = ElementsList()\Children            IChildPos = 1 ; Skip the first "/".            ;            Repeat              IChildPos + 1              IChild$ = StringField(ChildrenList$, IChildPos, "/")              If IChild$                SelectElement(ElementsList(), Val(IChild$))                ElementsList()\Parents = ReplaceString(ElementsList()\Parents, PosElement$, "/")              EndIf            Until IChild$ = ""            ;            PopListPosition(ElementsList())            ;            ElementsList()\Children = ""                        ;          Else            ; The element is fully or partially within the modified area.            ; The following will temporarily remove it from the list.            ; It may be reintegrated and updated when analyzing            ; the modified code that will take place later.            PushListPosition(ElementsList())            PosElement = ListIndex(ElementsList())            ;            ; If the element overflows the modified area, adjust the ExtendedStartingPos            ; and ExtendedEndingPos, so everything can be re-examined in a later phase.            If ElementsList()\StartingPos < ExtendedStartingPos : ExtendedStartingPos = ElementsList()\StartingPos : EndIf            If ElementsList()\EndingPos > ExtendedEndingPos : ExtendedEndingPos = ElementsList()\EndingPos : EndIf            ;            ForEach ElementsList()              ElementsList()\Parents = UpdateIndexList(ElementsList()\Parents, PosElement, -1)              ElementsList()\Children = UpdateIndexList(ElementsList()\Children, PosElement, -1)            Next            ;            PopListPosition(ElementsList())            ListOfAllElementsNbr(ElementsList()\Type) - 1            If ElementsList()\Used              ListOfUsedElementsNbr(ElementsList()\Type) - 1            EndIf            ;            DeleteElement(ElementsList())            ;          EndIf        EndIf        ;      Next      ;      ; ___________________________________________________________________________________      ;      ; The removal and updating of positions for the elements that were      ; in the old code is finished.      ;      ; Now use the new code to create/recreate the elements it contains:      ;      ;      If ModNewEndPos > ModStartPos And ModStartPos < EndExamNew        ; The code has been modified and not just deleted.        ; A re-exploration of the modified file between the ModStartPos and ModNewEndPos boundaries is requested        ; in order to integrate (create or recreate) the elements defined in the modified section into ElementsList().        ;        Protected Limits.Point\x = ModStartPos        Limits\y = ModNewEndPos        ;        LastElement(ElementsList())        PushListPosition(ElementsList())        ;        SetAllListsOfAllElements(#FinishCompletionNow, FileName$, @Limits)        ;        PopListPosition(ElementsList())        ;        ; Compile the list of (re)created elements:        MustBeUpdated$ = ""        While NextElement(ElementsList())          MustBeUpdated$ + Str(ListIndex(ElementsList())) + "/"        Wend        ;                   EndIf      ;      ;      ; Update the 'Parents' field for the (re)created elements. To do this,      ; examine the entire code and search for references to these elements.      PosInFileList = 1      ;      Repeat        line$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)        If line$          FileName$ = StringField(line$, 1, #TAB$)          If FileName$            *SearchString = GetPointedCodeFromFile(FileName$, #True)            IndexPos = 0            Repeat              IndexPos + 1              IIndex$ = StringField(MustBeUpdated$, IndexPos, "/")              If IIndex$                SelectElement(ElementsList(), Val(IIndex$))                FindElementAndUpdateFiliation(*SearchString.String, FileName$)              EndIf            Until IIndex$ = ""            PosInFileList + 1          EndIf        EndIf      Until line$      ;      ; Update the 'Children' field for the elements included in the modified code section.      ; To do this, go through this excerpt and check which elements are referenced in it      ; (for example, which procedures are called):      ;      NewContentLCase.String\s = LCase(*NewContent\s)      ForEach ElementsList()        FindElementAndUpdateFiliation(NewContentLCase, FileName$, ExtendedStartingPos, ExtendedEndingPos)        ;        ; Take the opportunity to reset the 'Used' field, as update it        ; just afterward:        If ElementsList()\Used And FindString(ElementsList()\Parents, "/-1/") = 0          ElementsList()\Used = 0          ListOfUsedElementsNbr(ElementsList()\Type) - 1        EndIf      Next      ;      ; Updating the 'Used' fields of all elements:      UpdateElementsUse()      ;      ;      CloseWaitingWindow()      ;          ProcedureReturn #True      ;    EndIf  EndIf  ;  ProcedureReturn #False  ;EndProcedure;Procedure UpdateOneFileInMemory(FileName$, TestOnly = #False)  ;  ; This procedure checks if the file 'FileName$' has been  ; modified on disk since its last read. If so, it updates the memory  ; and triggers an update of the 'ElementsList()'.  ;  Shared PBB_FileListing()  Shared ExactValueSearch  Shared RefreshEPanel  Protected OldContent.String  ;  If IsFileInMemory(FileName$)    If FindString(PBBListOfFiles$, FileName$ + #TAB$) = 0      DeleteElement(PBB_FileListing(), 1)      EraseObsoleteElementsContents(FileName$)      ProcedureReturn #FileHasBeenDeleted    Else      ;      If GetFileDate(FileName$, #PB_Date_Modified) = PBB_FileListing()\FileLastModInList        ProcedureReturn #FileWasUpToDate      ElseIf TestOnly        ProcedureReturn #FileMustBeUpdated      Else        ; The file’s last modified date has changed. Update it:        PBB_FileListing()\FileLastModInList = GetFileDate(FileName$, #PB_Date_Modified)        ; Clear the codes of the elements that were in the cache:        EraseObsoleteElementsContents(FileName$)        ; Now check if the file itself has been modified or if it was simply        ; saved again without changes:        OldContent\s = PBB_FileListing()\FileContentInList\s        PBB_FileListing()\FileContentInList\s = GetCodeFromFile(FileName$)        PBB_FileListing()\FileLCaseContentInList\s = "" ; This content will be regenerated if needed.        ;        ; 'PartialUpdateOfElementsList()' compares the old and new version of the file.        ; If it returns '#True', it means the file has actually been modified.        ;    (in that case, this procedure will also update the 'ElementsList()').        If PartialUpdateOfElementsList(OldContent, PBB_FileListing()\FileContentInList, FileName$)          ; The content has changed, refresh the display of the panels:          ExactValueSearch = #DoProgrammedSearch          RefreshEPanel  = #True          ;          ProcedureReturn #FileIsUpDated        Else          ProcedureReturn #FileWasUpToDate        EndIf      EndIf    EndIf  EndIf  ProcedureReturn #FileDoesntExistEndProcedure;Procedure UpdateAllFilesInMemory(TestOnly = #False)  ;  ; This procedure goes through the list of files and  ; updates the memory if any of them have been modified.  ; If a modification has occurred or must be done (if TestOnly),  ; the return value is #True. #False is returned otherwise.  ;  ; The update involves:  ; • The content of the files in cache memory,  ; • The code snippets related to the elements,  ; • The 'ElementsList()' list.  ;  Shared PBB_FileListing()  Shared BackgroundTasksCompletion  ;  Protected RetValue = #False  Protected Cont = #True  Protected PosInFileList, LineC$, TypeOfElement  ;  ; Check if any of the files in the PBBListOfFiles$  ; has been deleted or moved since the last call,  ; and update PBBListOfFiles$ if necessary:  If PBBListOfFiles$    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)      If LineC$        If FileSize(StringField(LineC$, 1, #TAB$)) < 1          ; A file has been deleted or moved.          ; Request to restart the exploration:          PBBFicPrincipalPB$ = SetListOfFiles(PBBFicPrincipalPB$, #ShowCompletionWindow)          BackgroundTasksCompletion = #BackgroundTasksMustRestart          Break        EndIf      EndIf    Until LineC$ = ""  EndIf  ;  ; If no valid files remain, clean up:  If PBBListOfFiles$ = "" And PBBFicPrincipalPB$    PBBFicPrincipalPB$ = ""    Protected FileREGadget = NoREGadgetOfPBBPanel(#FilePBBPanel)    If GetGadgetText(GPBBGadgets\Adr_gadget)      SetGadgetText(FileREGadget, "")      SetGadgetText(GPBBGadgets\Adr_gadget, "")      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, "")      ExactValueSearch = #DoProgrammedSearch      RefreshEPanel  = #True    EndIf  Else    ; Only perform a partial update if    ; the first phase of exploration is completed.    For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)      If ListCompletionAll(TypeOfElement) < #ListCompletion_Done        Cont = #False        Break      EndIf    Next    ;    If Cont And BackgroundTasksCompletion <> #BackgroundTasksMustRestart      If ListSize(PBB_FileListing())        ForEach PBB_FileListing()          If UpdateOneFileInMemory(PBB_FileListing()\FileNameInList$, TestOnly) <> #FileWasUpToDate            RetValue = #True          EndIf        Next      EndIf    EndIf  EndIf  ;  ProcedureReturn RetValueEndProcedure;Procedure EraseAllCodeInMemory()  ;  Shared PBB_FileListing()  ;  If ListSize(PBB_FileListing())    ForEach PBB_FileListing()      DeleteElement(PBB_FileListing())    Next  EndIf  ;  Shared ElementContentListing()  ;  If ListSize(ElementContentListing())    ForEach ElementContentListing()      DeleteElement(ElementContentListing())    Next  EndIfEndProcedure;; **********************************************************************************;;-              Procedures related to displaying results in panels;; **********************************************************************************;Procedure.s ComputePrefix(*SearchString.String, SStrLength, PosInCode, NoLine$, Expression$, FileName$, TypeOfElement, Init = 0)  ;  ; This procedure is only called by the 'SetListFoundInFiles' procedure.  ; Its role is to determine, for a given position in the code,  ; whether we are inside an element (a procedure, for example)  ; or not.  ;   ; The line prefix will be calculated based on what was found.  ;  Shared ProcNameMem$  ;  Protected StartKeyWord$, EndKeyWords$, ElementName$  Protected StartOfElementPos, mStartOfElementPos  Protected CatTxt_CodeMismatchAlert$, pPar, TOE  Protected prefix$ ; Return value.  Protected PBB_LineBreak$ = #CR$ + GetPBBStringParameter("PBB_Bullet") + #NonBreakableSpace$  ;  If Init    ; Initialize an array to keep track of what we will find    ; during the following search. The goal is to avoid    ; redoing a search unnecessarily. If we find that we are    ; still inside an already identified element, we don't need    ; to check again.    Static Dim EndOfElementPosMem(#EndEnumPBBElementTypes - 1)    ; Even though we use 'Dim' and not 'Redim', PureBasic    ; may keep previously assigned values in the array lines.    ; So set them to zero.    For TOE = 0 To #EndEnumPBBElementTypes - 1      EndOfElementPosMem(TOE) = 0    Next    ProcNameMem$ = ""    ; Pass the string to the ReverseFindInPBCode() procedure    ; which will store it. This way, we won't need to do it again:    ReverseFindInPBCode(*SearchString\s, "", 0)  Else    ;    StartKeyWord$ = PBBTypeNames$(TypeOfElement)    If TypeOfElement = #PBBEnumeration      StartKeyWord$ + ",EnumerationBinary"    EndIf    If TypeOfElement = #PBBProcedure      StartKeyWord$ + ",ProcedureC"    EndIf    EndKeyWords$ = "End" + PBBTypeNames$(TypeOfElement)    ;    If PosInCode > EndOfElementPosMem(TypeOfElement) And Expression$ <> EndKeyWords$      EndOfElementPosMem(TypeOfElement) = 0    EndIf    ;    If EndOfElementPosMem(TypeOfElement) = 0      ;      ; Until now, we were not inside an element of type 'TypeOfElement'.      ;      ; We will determine if we just entered the element...      ;      ; To do this, search simultaneously for the start and end of the element:      EndOfElementPosMem(TypeOfElement) = FindInPBPointedCode(*SearchString, StartKeyWord$ + "," + EndKeyWords$, PosInCode)      If EndOfElementPosMem(TypeOfElement)        ;        ; If something is found, check if it's the start or end:        If EndOfElementPosMem(TypeOfElement) + Len(EndKeyWords$) <= SStrLength And FastMid(*SearchString\s, EndOfElementPosMem(TypeOfElement), Len(EndKeyWords$)) = EndKeyWords$          ; 'EndElement' is found before finding 'Element'.          ; So, search backward for the start of the element:          ;          ; The search string was passed to ReverseFindInPBCode() during          ; initialization (see above). No need to do it again.          StartOfElementPos = ReverseFindInPBCode("", StartKeyWord$, PosInCode)          ;          If StartOfElementPos            mStartOfElementPos = StartOfElementPos            StartOfElementPos + 1            ; Look for a separator after the element type name            ; (after 'Procedure', for example).            StartOfElementPos = FirstOccurrenceOfCharPointed(*SearchString, " :;" + #CR$, StartOfElementPos)            ;            ; For enumerations, we don't know if we found 'Enumeration' or 'EnumerationBinary',            ; as we searched for both at once. So we adjust 'StartKeyWord$' with the found value.            If TypeOfElement = #PBBEnumeration              StartKeyWord$ = FastMid(*SearchString\s, mStartOfElementPos, StartOfElementPos - mStartOfElementPos)            EndIf            ;            ; The separator found after 'Element' must be a space to decide that a name exists.            If StartOfElementPos And FastMid(*SearchString\s, StartOfElementPos, 1) = " "              ; Skip spaces following:              While StartOfElementPos <= SStrLength And PeekC(@*SearchString\s + (StartOfElementPos - 1) * SizeOf(CHARACTER)) = #Space : StartOfElementPos + 1 : Wend              ;              ; Now search for the first separator after the element name:              pPar = FirstOccurrenceOfCharPointed(*SearchString, " (;:" + #CR$, StartOfElementPos)              If pPar And pPar - StartOfElementPos                ; Extract the element name:                ElementName$ = Trim(FastMid(*SearchString\s, StartOfElementPos, pPar - StartOfElementPos))              EndIf            EndIf            If ElementName$ = "" ; Enumerations don't necessarily have a name.              ; Generate one:              ElementName$ = "UnNamed_Line_" + NoLine$            EndIf          Else            ; Found 'EndElement' without finding 'Element' upstream.            ; Either the code is non-compliant, or our program got confused.            NoLine$ = Str(CountString(Mid(*SearchString\s, 1, EndOfElementPosMem(TypeOfElement)), #CR$) + 1)            CatTxt_CodeMismatchAlert$ = GetTextFromCatalogPB("CodeMismatchAlert")            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%EndString$%", EndKeyWords$)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%StartString$%", StartKeyWord$)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%SearchString\s%", *SearchString\s)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%nFile$%", FileName$)            AlertInPBBWindow(CatTxt_CodeMismatchAlert$ + #CR$ + NoLine$)          EndIf        Else          ; Found 'Element' before finding 'EndOfElement'.          ; Thus, we are outside an element of type 'TypeOfElement'.          EndOfElementPosMem(TypeOfElement) = 0        EndIf      Else        ; Found neither the start nor end of an element of type 'TypeOfElement'.        ; Therefore, we are outside an element of this type.        EndOfElementPosMem(TypeOfElement) = 0      EndIf    EndIf    ;    If TypeOfElement = #PBBProcedure Or TypeOfElement = #PBBMacro      If ElementName$        If TypeOfElement = #PBBProcedure          ProcNameMem$ = ElementName$          prefix$ = PBB_LineBreak$ + "In" + #NonBreakableSpace$ + "Procedure" + #NonBreakableSpace$ + ElementName$ + "()"        Else          ProcNameMem$ = ""          prefix$ = PBB_LineBreak$ + "In" + #NonBreakableSpace$ + "Macro" + #NonBreakableSpace$ + ElementName$ + " "        EndIf                ElseIf EndOfElementPosMem(#PBBProcedure) = 0 And EndOfElementPosMem(#PBBMacro) = 0 And ProcNameMem$ <> #OutOfElementsName        ; We are outside of a procedure and macro and have not yet mentioned        ; "OutOfElementsName" in the line presenting search results.        ProcNameMem$ = #OutOfElementsName        prefix$ = PBB_LineBreak$ + ProcNameMem$      Else        prefix$ = ""      EndIf    ElseIf ElementName$      ; Just entered an element of type 'TypeOfElement'.      If TypeOfElement = #PBBStructure Or TypeOfElement = #PBBEnumeration        If EndOfElementPosMem(#PBBProcedure) Or EndOfElementPosMem(#PBBMacro)          ; Structures and enumerations can be declared inside          ; macros or procedures. If so, don't add LineBreak$.          prefix$ = " In" + #NonBreakableSpace$ + StartKeyWord$ + #NonBreakableSpace$ + ElementName$ + " "        Else          prefix$ = PBB_LineBreak$ + "In" + #NonBreakableSpace$ + StartKeyWord$ + #NonBreakableSpace$ + ElementName$ + " "        EndIf      Else        Alert("Unsupported Element in ComputePrefix: " + Str(TypeOfElement) + #CR$ + StartKeyWord$)      EndIf    EndIf    ProcedureReturn prefix$  EndIfEndProcedure;Procedure.s SetListFoundInFiles(Expression$, Reset = 1)  ;  ; This procedure scans the list of files and records the positions  ; where the expression 'Expression$' was found in their code.  ;  ; It can identify the element in which the expression was found,  ; but also, if 'Expression$' contains the name of a variable,  ; whether this variable is assigned a value at that point. It also notes the  ; type of declaration made for the variable (if a type is declared).  ;  ; CompleteListOfFiles must have been called before this procedure,  ; so that the global variable PBBListOfFiles$ is set.  ;  ; The list 'ElementsList()' is optional, although its existence allows  ; for a more detailed result.  ; Things were designed so that the user can (almost) immediately  ; obtain relevant information about the searched expression (its positions in the code,  ; in particular), even if PBBrowser has just started and even if the machine  ; on which it runs is not very fast.  ; Then, as seconds pass, the displayed results are enriched with more details.  ;  ; This procedure is designed to interrupt after 100 ms. It will be called repeatedly  ; by FillFoundInREGadget() which will display, as it goes, the search results until  ; the entire code has been examined.  ;  Shared ProcNameMem$ ; Variable updated by 'ComputePrefixe()'.  Shared VarWithArguments  ;  ; Keep track of the progress through the files:  Static *SearchString.String      ; Code currently being processed.  Static *SearchStringLCase.String ; Lowercase version of the previous string.  Static SStrLength                ; To avoid recalculating the length of SearchString too often.  Static PosInFileList, LineC$     ; Position in the file list and the current line under examination.  Static PosInCode                 ; Position in the code.  ;  Protected FileName$, BatchListFoundInFiles$, PosAfter  Protected LineInProgress$, PreceedingChar$, PreceedingWord$  Protected StartTime, ExpressionLCase$, FirstLoopInFile, LineOfCode$, LenLOC, PosInCodeLine  Protected tPosAfter, InQuote, InParenthesis, Pos, CChar, BeforeExpression$, AfterEqual  Protected mBeforeExpression$, ppt, PosOfPreceedingWord, Declaration$, Element, variable  Protected Parametre, Argument, VDefine, Sprefix$, NoLine$, prefix$, PeekOrPoke$  Protected FollowedBy$, FirstWordInLine$  Protected PBB_LineBreak$ = #CR$ + GetPBBStringParameter("PBB_Bullet") + #NonBreakableSpace$  ;  If PBBListOfFiles$    ;    BatchListFoundInFiles$ = ""    StartTime = ElapsedMilliseconds()    ;    If Reset      PosInFileList = 0      PosInCode     = 0    EndIf    ;    ExpressionLCase$ = LCase(Expression$)    ;    Repeat       ; Scanning the file list to retrieve content.      If PosInCode = 0        PosInFileList + 1        LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)        If LineC$          FileName$ = StringField(LineC$, 1, #TAB$)          ; Retrieve both versions of the code: original version          ; and entirely in lowercase.          *SearchString = GetPointedCodeFromFile(FileName$)          *SearchStringLCase = GetPointedCodeFromFile(FileName$, #True)          SStrLength = Len(*SearchString\s)          LineInProgress$ = ""          FirstLoopInFile = 1          PosInCode = 0          ;          ; Initialize the 'ComputePrefix()' variables:          ComputePrefix(*SearchString, 0, 0, "", "", "", 0, 1)          ;        EndIf      EndIf      If LineC$        ;        Repeat          PosInCode = FindInPBPointedCode(*SearchStringLCase, ExpressionLCase$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)          If PosInCode            ; The expression was found in the code.            ; Deciding what type of expression it is based on            ; what precedes and follows it in the code.            ;            ; From here, we work with *SearchString\s, even though the search was conducted            ; on *SearchStringLCase\s, but that poses no issue as the two strings            ; are identical, except *SearchStringLCase\s is lowercase.            ;            ; Retrieve the expression with the case used at this point in the code:            Expression$ = FastMid(*SearchString\s, PosInCode, Len(Expression$))            ;            ; Extract the code section containing the expression:            LineOfCode$ = ExtractSectionArroundExpression(*SearchString, Expression$, PosInCode)            If LineOfCode$              ;              LenLOC = Len(LineOfCode$)              ;              ; Position of the expression in the code section:              PosInCodeLine = FindInPBStringCode(LineOfCode$, Expression$)              ;              ; Start by looking at what follows:              PosAfter = PosInCodeLine + Len(Expression$)              ;              If PosAfter <= LenLOC And FastMid(LineOfCode$, PosAfter) = "." ; If the expression is followed by a dot,                PosAfter + 1     ; look after the dot and what follows it.                                 ; (to skip type declarations).                While PosAfter <= LenLOC And FindString(ListPBSep$, FastMid(LineOfCode$, PosAfter, 1)) = 0 : PosAfter + 1 : Wend              EndIf              ;              If VarWithArguments                ; For arrays, lists, and maps, the character we are interested in                ; is the one that follows the parentheses. So, we skip over the                ; parentheses, considering that the included argument could                ; itself consist of a function with parentheses.                ;                tPosAfter = FindInPBStringCode(LineOfCode$, "(", PosAfter, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                If tPosAfter                  InQuote = 0                  InParenthesis = 0                  For Pos = tPosAfter To Len(LineOfCode$)                    CChar = PeekC(@LineOfCode$ + (Pos - 1) * SizeOf(CHARACTER))                    If CChar = 34 ; Quote                      If InQuote = 1 : InQuote = 0 : Else : InQuote = 1 : EndIf                    EndIf                    If InQuote = 0                      If CChar = Asc("(")                        InParenthesis + 1                      ElseIf CChar = Asc(")")                        InParenthesis - 1                      EndIf                      If InParenthesis = 0                        PosAfter = Pos + 1                        Break                      EndIf                    EndIf                  Next                EndIf              EndIf              ;              ; Skip any spaces after the found expression:              While PosAfter <= LenLOC And PeekC(@LineOfCode$ + (PosAfter - 1) * SizeOf(CHARACTER)) = #Space : PosAfter + 1 : Wend              If PosAfter <= LenLOC                FollowedBy$ = FastMid(LineOfCode$, PosAfter, 1)  ; Extract the first character following the expression.              Else                FollowedBy$ = ""              EndIf              ;              ; Now examine what is before the found expression by analyzing everything in it:              ;              BeforeExpression$ = ""              If PosInCodeLine > 1                BeforeExpression$ = Trim(FastMid(LineOfCode$, 1, PosInCodeLine - 1))              EndIf              If BeforeExpression$ = ""                PreceedingChar$ = #CR$                PreceedingWord$ = ""                FirstWordInLine$ = ""                AfterEqual = 0                InParenthesis = 0              Else                PreceedingChar$ = Right(BeforeExpression$, 1)                ;                AfterEqual = 0                InParenthesis = 0                InQuote = 0                ;                For Pos = 0 To Len(BeforeExpression$) - 1                  ; Replace all separator characters with spaces,                  ; except the dot (".") character which will be kept.                  ; Also replace all content within quotation marks with spaces,                  ; counting the number of opening and closing parentheses,                  ; and noting the presence of the "=" sign.                  CChar = PeekC(@BeforeExpression$ + Pos * SizeOf(CHARACTER))                  If CChar = 34 ; Quote.                    If InQuote = 0                      InQuote = 1                    Else                      InQuote = 0                      PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                    EndIf                  EndIf                  If InQuote                    PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                  Else                    If CChar = Asc("=") : AfterEqual = 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                    ElseIf CChar = Asc("(") : InParenthesis + 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                    ElseIf CChar = Asc(")") : InParenthesis - 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                    ElseIf FindString(ListPBSep$, Chr(CChar)) And CChar <> Asc(".") : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), #Space)                    EndIf                  EndIf                Next                ;                Repeat                  ; Remove double spaces:                  mBeforeExpression$ = BeforeExpression$                  BeforeExpression$ = ReplaceString(BeforeExpression$, "  ", " ")                Until mBeforeExpression$ = BeforeExpression$                ;                ; Save the first word of 'BeforeExpression$'.                FirstWordInLine$ = StringField(BeforeExpression$, 1, " ")                ; This is where we remove the dot and the type declaration that follows:                ppt = FindString(FirstWordInLine$, ".")                If ppt : FirstWordInLine$ = Left(FirstWordInLine$, ppt - 1) : EndIf                ;                ; Search for the last word of 'BeforeExpression$'.                PosOfPreceedingWord = Len(BeforeExpression$)                FastFindPrecSpaces(BeforeExpression$, PosOfPreceedingWord)                PreceedingWord$ = FastMid(BeforeExpression$, PosOfPreceedingWord + 1)                ; This is where we remove the dot and the type declaration that follows:                ppt = FindString(PreceedingWord$, ".")                If ppt : PreceedingWord$ = Left(PreceedingWord$, ppt - 1) : EndIf                ;              EndIf              ;              Declaration$ = ""              ;              ; Check if the found expression is an argument or a parameter:              ;              Element = 0              variable = 0              Parametre = 0              Argument = 0              VDefine = 0              ;              ; NoREGadget    GetImageNameFromSelectionPos              ;              If InParenthesis                If Left(FirstWordInLine$, 9) = "Procedure" Or FirstWordInLine$ = "Macro"                  Parametre = 1                Else                  Argument = 1                EndIf              EndIf              ;              ; If the expression is declared at the found position, save its declaration.              If Argument = 0                If FindString(" Procedure, ProcedureC, ProcedureDLL, ProcedureCDLL, Declare, Structure, Macro, Enumeration,", " " + PreceedingWord$ + ",", 0, #PB_String_NoCase)                  Declaration$ = PBB_LineBreak$ + PreceedingWord$ + " " + #ItsHereChar$ + " "                  Element = 1                ElseIf FindString(" Define, Global, Protected, Static, Shared, ReDim, Dim, NewList, NewMap,", " " + PreceedingWord$ + "," , 0 , #PB_String_NoCase)                  Declaration$ = PreceedingWord$ + " "                  Variable = 1                  If FindString("ReDim, Dim, NewList, NewMap", PreceedingWord$)                    VarWithArguments = 1                  EndIf                EndIf                ;                If AfterEqual = 0 And FindString(" Define, Global, Protected, Static, Shared,", " " + FirstWordInLine$ + "," , 0 , #PB_String_NoCase)                  VDefine = 1                EndIf                ;                If VDefine Or FindString(" Dim, NewList, NewMap,", " " + FirstWordInLine$ + "," , 0 , #PB_String_NoCase)                  If FirstWordInLine$ <> PreceedingWord$                    Declaration$ = FirstWordInLine$ + " " + Declaration$                  EndIf                  Variable = 1                EndIf                If Declaration$ And Right(Declaration$, 1) <> " "                  Declaration$  + " "                EndIf              EndIf              ;              If Variable = 0  And FindString(".=+-*/", FollowedBy$) And (PreceedingChar$ = #CR$ Or PreceedingChar$ = "\")                Variable = 1              EndIf              ;              ;              If Left(PreceedingWord$, 9) <> "Procedure" And PreceedingWord$ <> "Macro" And PreceedingWord$ <> "Declare"                 ;                ; We are not in a procedure or macro declaration.                ; We will check if the expression appears within an element.                ;                ; Check if the expression was found inside a procedure.                Sprefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBProcedure)                ; If we are outside a procedure and this has not yet been noted,                ; Sprefix$ now contains the mention #OutOfElementsName                ;                If ProcNameMem$ = #OutOfElementsName Or ProcNameMem$ = ""                  ; Check if the expression was found inside a structure, enumeration, or macro.                  prefix$ = ""                  If PreceedingWord$ <> "Structure"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBStructure)                  EndIf                  If prefix$ = "" And PreceedingWord$ <> "Enumeration"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBEnumeration)                  EndIf                  If prefix$ = "" And PreceedingWord$ <> "Macro"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBMacro)                  EndIf                  If prefix$ = "" And (Element = 0 Or ProcNameMem$ <> #OutOfElementsName)                    prefix$ = Sprefix$                  Else                    ProcNameMem$ = ""                  EndIf                Else                  prefix$ = Sprefix$                EndIf                If prefix$ And Right(prefix$, 1) <> " "                  prefix$  + " "                EndIf              Else                prefix$ = ""              EndIf              ;              If FirstWordInLine$ = "ProcedureReturn"                prefix$ + "Return" + #ThisPlaceChar$              EndIf              ;              If FirstWordInLine$ And FindString(" If, ElseIf, While, For, Case, Until, Select,", " " + FirstWordInLine$ + ",")                prefix$ + "Test" + #ThisPlaceChar$              EndIf              ;              PeekOrPoke$ = Left(PreceedingWord$, 4)              If PeekOrPoke$ = "Poke" Or PeekOrPoke$ = "Peek"                prefix$ + PeekOrPoke$ + #ThisPlaceChar$              EndIf              ;              If PreceedingWord$ = "Read"                prefix$ + "Read" + #ThisPlaceChar$              EndIf              ;              If Parametre                Declaration$ + "Param" + #ThisPlaceChar$              Else                If Argument Or (VDefine = 0 And (PreceedingChar$ = "(" Or PreceedingChar$ = ","))                  If PeekOrPoke$ <> "Poke" And PeekOrPoke$ <> "Peek"                    prefix$ + "Arg" + #ThisPlaceChar$                  EndIf                EndIf              EndIf              ;              If PreceedingWord$ = "For" Or (variable And (FollowedBy$ = "=" Or FollowedBy$ = "+" Or FollowedBy$ = "-") And AfterEqual = 0)                If Declaration$                  Declaration$ + "& Set" + #ThisPlaceChar$                Else                  Declaration$ + "Set" + #ThisPlaceChar$                EndIf              EndIf              ;              NoLine$ = Str(CountString(FastMid(*SearchString\s, 1, PosInCode), #CR$) + 1)              LineInProgress$ + prefix$ + Declaration$ + "(" + NoLine$ + "), "              ;            EndIf          EndIf        Until PosInCode = 0 Or (ElapsedMilliseconds() - StartTime) > 100        ;        If LineInProgress$          LineInProgress$ = ReplaceString(LineInProgress$, ", " + #CR$, #CR$)          ; Place #NonBreakableSpace$ just after the file name.          ; This will serve as a reference point in 'ClickOverREGadget'.          If FirstLoopInFile            If Right(BatchListFoundInFiles$, 2) = ", "              BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, Len(BatchListFoundInFiles$) - 2)            EndIf            BatchListFoundInFiles$ + #CR$ + GetFilePart(FileName$) + #NonBreakableSpace$            FirstLoopInFile = 0          EndIf          BatchListFoundInFiles$ + LineInProgress$          LineInProgress$ = ""        EndIf      EndIf    Until LineC$ = "" Or (ElapsedMilliseconds() - StartTime) > 100  EndIf  ;  If LineC$ <> "" And BatchListFoundInFiles$ = ""    ; The expression has not been found yet, but not all files    ; have been explored. Return 'Pending' to indicate    ; that the search should continue.    BatchListFoundInFiles$ = "Pending"  EndIf  ;  ProcedureReturn BatchListFoundInFiles$EndProcedure;Procedure PBBRichEditCallback(hWnd, Msg, wParam, lParam)  ;  ; Intercepts the 'Events' of a RichEdit Gadget and replaces the text  ; cursor with an arrow (standard cursor).  ; The 'Events' of type '#WM_LBUTTONUP' and '#WM_RBUTTONUP' are  ; intercepted to update the variables 'PBBRichEditMessage',  ; 'PBBREGadgetID' and 'RangeOfClic'.  ; The 'Events' of type '#WM_LBUTTONDBLCLK' are cancelled because  ; double-click handling will be done in the main loop of 'PBBrowserMainProc()'.  ; Other 'Events' are not modified, but we take the opportunity to  ; hide the blinking cursor of the gadget.  ;  Shared OldREProc, PBBRichEditMessage, RangeOfClic.CHARRANGE, PBBREGadgetID  ;  Protected txtrange.CHARRANGE  ;  If Msg = #WM_LBUTTONUP Or Msg = #WM_RBUTTONUP    If Msg = #WM_RBUTTONUP      ; Make sure to handle #WM_RBUTTONUP like #WM_LBUTTONUP      CallWindowProc_(OldREProc, hWnd, #WM_RBUTTONUP, wParam, lParam)      CallWindowProc_(OldREProc, hWnd, #WM_LBUTTONDOWN, wParam, lParam)    EndIf    ; Let OldProc calculate the corresponding selection.    CallWindowProc_(OldREProc, hWnd, #WM_LBUTTONUP, wParam, lParam)    ; Retrieve the selection    SendMessage_(hWnd, #EM_EXGETSEL, 0, @RangeOfClic)    ;    PBBRichEditMessage = Msg ; To signal #WM_LBUTTONUP or #WM_RBUTTONUP                             ; to the main procedure.    PBBREGadgetID = hWnd    ProcedureReturn #True  ElseIf Msg = #WM_LBUTTONDOWN Or Msg = #WM_RBUTTONDOWN    SendMessage_(hWnd, #EM_HIDESELECTION, #False, 0)    ;  ElseIf Msg = #WM_LBUTTONDBLCLK Or Msg = #WM_RBUTTONDBLCLK    PBBRichEditMessage = #WM_LBUTTONDBLCLK    PBBREGadgetID = hWnd    ProcedureReturn #True    ;  ElseIf Msg = #WM_SETCURSOR    ; Show the arrow cursor    SetCursor_(PBBDefaultCursor)    ; Hide the cursor, since our gadgets are 'Read Only',    ; but leave the selection visible, if its size    ; is greater than 0.    SendMessage_(hWnd, #EM_EXGETSEL, 0, @txtrange)    If txtrange\cpMin = txtrange\cpMax      SendMessage_(hWnd, #EM_HIDESELECTION, #True, 0)    Else      SendMessage_(hWnd, #EM_HIDESELECTION, #False, 0)    EndIf    ; Here, return without calling 'OldREProc'.    ProcedureReturn #True    ;  EndIf  ; Here, call 'OldREProc' to handle all other 'Events'.  ProcedureReturn CallWindowProc_(OldREProc, hWnd, Msg, wParam, lParam)EndProcedure;Procedure SetREGadgetParam(NoREGadget)  ;  ; Defines the attributes of the RichEdit gadgets for the various panels.  ;  Shared OldREProc  ;  SetGadgetColorEx(NoREGadget, #PB_Gadget_BackColor, GetValueFromBPPrefFile("BackgroundColor"))  SendMessage_(GadgetID(NoREGadget), #EM_SETTARGETDEVICE, #Null, 0);<<--- Automatic carriage return.  SendMessage_(GadgetID(NoREGadget), #EM_LIMITTEXT, -1, 0)             ; Set unlimited content size.  SendMessage_(GadgetID(NoREGadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0) ; Set gadget to 'RichEdit' type.  ; Set up a procedure to intercept 'Events' from the gadget.  ; to display a standard arrow cursor over the REGadgets.  OldREProc = SetWindowLongPtr_(GadgetID(NoREGadget), #GWL_WNDPROC, @PBBRichEditCallback())  ;EndProcedure;Procedure ReSizeREMenu()  ;  ; (Re)positions the hamburger menu for the panels.  ;  Protected REGadget  Protected REMenuX = GadgetX(GPBBGadgets\MainPanelGadget) + GadgetWidth(GPBBGadgets\MainPanelGadget) - 27  ;  REGadget = GetREGadgetNbrFromActivePBBPanel()  If REGadget    If GetWindowLong_(GadgetID(REGadget), #GWL_STYLE) & #WS_VSCROLL      ; The scrollbar is visible. Move the button to the left.      REMenuX - 18    EndIf  EndIf  Protected REMenuY = GadgetY(GPBBGadgets\MainPanelGadget) + 26  If GetActivePBBPanel() >= #ProcPBBPanel    REMenuX - 4    REMenuY + 24  EndIf  ResizeGadget(GPBBGadgets\BREMenu, REMenuX, REMenuY, #PB_Ignore, #PB_Ignore)EndProcedure;Procedure PBBResetContentAndStyles(GadgetID)  ; Suspend drawing for the gadget to reset its content and styles.  PBB_SuspendRedraw(GadgetID, #True)  TOM_InsertText(GadgetID, "", 0, -1) ; Remove old content.  TOM_ResetFontStyles(GadgetID, 0, -1); Remove all styles.                                      ; Set default font and size:  PBBPanelsDefaultFontStyle$ = AddNormalColorToTextStyle(GetPBBStringParameter("PBBPanelsDefaultFontStyle"))  PBBCodeFontStyle$ = AddNormalColorToTextStyle(GetPBBStringParameter("PBBCodeFontStyle"))  TOM_SetFontStyles(GadgetID, PBBPanelsDefaultFontStyle$, 0, -1)EndProcedure;Procedure FillFileREGadget()  ;  ; Fills a RichEdit Gadget with the list of files from PBBListOfFiles$.  ;  ; Before calling this procedure, PBBListOfFiles$ must be declared  ; and should contain the list of files related to the main file.  ; CompleteListOfFiles() should have already handled this.  ;  Protected PosInFileList, LineC$, Addr$, Result$, Result2$, FileREGadget  Protected ContenerFile$, Intro$, Intro2$, NoLine$, posbin  ;  Result$ = ""  If PBBListOfFiles$    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)      If LineC$        Addr$ = StringField(LineC$, 1, #TAB$)        ContenerFile$ = GetFilePart(StringField(LineC$, 2, #TAB$))        If ContenerFile$ = ""          ContenerFile$ = "(" + GetTextFromCatalogPB("mainFile") + ")"        Else          NoLine$ = GetFilePart(StringField(LineC$, 3, #TAB$))          ; Handles non-breaking spaces to ensure that the phrase "included by 'Filename'"           ; is split correctly when the window width cannot accommodate it on one line.          ContenerFile$ = ReplaceString(GetTextFromCatalogPB("includedBy"), " ", #NonBreakableSpace$) + #NonBreakableSpace$ + ContenerFile$ + "," + #NonBreakableSpace$ + ReplaceString(GetTextFromCatalogPB("AtLine"), " ", #NonBreakableSpace$) + #NonBreakableSpace$ + NoLine$ + "."        EndIf        Result$ + GetFilePart(StringField(LineC$, 1, #TAB$)) + " " + ContenerFile$ + #CR$      EndIf    Until LineC$ = ""  EndIf  If Result$    Intro$ = GetTextFromCatalogPB("IncludedFilesIntro")    Result$ = Intro$ + #CR$ + Result$  EndIf  ;  Result2$ = ""  If PBBListOfBinaries$    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfBinaries$, PosInFileList, #CR$)      If LineC$        Addr$ = StringField(LineC$, 1, #TAB$)        ContenerFile$ = GetFilePart(StringField(LineC$, 2, #TAB$))        NoLine$ = GetFilePart(StringField(LineC$, 3, #TAB$))        ; Handles non-breaking spaces to ensure that the phrase "included by 'Filename'"         ; is split correctly when the window width cannot accommodate it on one line.        ContenerFile$ = ReplaceString(GetTextFromCatalogPB("includedBy"), " ", #NonBreakableSpace$) + #NonBreakableSpace$ + ContenerFile$ + "," + #NonBreakableSpace$ + ReplaceString(GetTextFromCatalogPB("AtLine"), " ", #NonBreakableSpace$) + #NonBreakableSpace$ + NoLine$ + "."        Result2$ + GetFilePart(StringField(LineC$, 1, #TAB$)) + " " + ContenerFile$ + #CR$      EndIf    Until LineC$ = ""  EndIf  If Result2$    posbin = Len(Result$) + 1    Intro2$ = #CR$ + GetTextFromCatalogPB("IncludedBinaries")    Result$ + Intro2$ + #CR$ + Result2$  EndIf      FileREGadget = NoREGadgetOfPBBPanel(#FilePBBPanel)  ;  PBBResetContentAndStyles(FileREGadget)  ;  TOM_InsertText(FileREGadget, Result$, -1)  ;  TOM_SetFontStyles(FileREGadget, "Bold, ForeColor(" + GetPBBStringParameter("PBBTitleColor") + ")", 0, Len(Intro$))  TOM_SetParaStyles(FileREGadget, "SpaceAfter(10)", 0, Len(Intro$))  ;  If posbin    TOM_SetFontStyles(FileREGadget, "Bold, ForeColor(" + GetPBBStringParameter("PBBTitleColor") + ")", posbin, posbin + Len(Intro2$))    TOM_SetParaStyles(FileREGadget, "SpaceAfter(10)", posbin, posbin + Len(Intro2$))  EndIf  ;    UnderlineFNamesAndLinks(FileREGadget)  PBB_SuspendRedraw(FileREGadget, #False)  ReSizeREMenu()  ;EndProcedure;Procedure FillElementREGadget(TypeOfElement)  ;  ; Fills a RichEdit Gadget with the list of elements corresponding  ; to 'TypeOfElement' in the 'ElementsList()' List.  ;  ;  Protected tnl, PosInElementList, Result$, txa$, NoREGadget  Protected MSpecies$, MSubSpecies$, Species$, SubSpecies$  Protected EName$, SetInBold$, PosInCode, pf  Protected TOE, Pos  Protected scrollPos.Point ; Scroll position before redisplaying the content.  Protected PBB_Bullet$ = GetPBBStringParameter("PBB_Bullet") + #NonBreakableSpace$  ;  If ListCompletionAll(TypeOfElement) >= #ListCompletion_Done    ; Look for the REGadget number corresponding to TypeOfElement.    For TOE = 0 To (#EndEnumPBBPanels - 1)      If TypeElementOfPBBPanel(TOE) = TypeOfElement        NoREGadget = NoREGadgetOfPBBPanel(TOE)        Break      EndIf    Next    ;    If NoREGadget = 0      ; This should not happen! There's a design error.      txa$ = GetTextFromCatalogPB("UnfoundGadgetNumber") + PBBTypeNames$(TypeOfElement)      AlertInPBBWindow(txa$)    Else      SendMessage_(GadgetID(NoREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)    EndIf    ;    tnl = ListOfAllElementsNbr(TypeOfElement)    If tnl      Protected Dim pLine$(tnl)      ;      PosInElementList = 0      ;      ForEach ElementsList()        If ElementsList()\Type = TypeOfElement          PosInElementList + 1          If ElementsList()\Type = #PBBVariable            pLine$(PosInElementList) = ElementsList()\VariableSpecies + " " + ElementsList()\Name          Else            pLine$(PosInElementList) = ElementsList()\Name          EndIf        EndIf      Next      ;      ; Alphabetical sort of the list:      ;      SortArray(pLine$(), #PB_Sort_NoCase)      ;      ; Fill the gadget:      ;      Result$ = ""      MSpecies$ = ""      MSubSpecies$ = ""      For Pos = 1 To PosInElementList                If TypeOfElement = #PBBProcedure          Result$ + pLine$(Pos) + "()"        ElseIf TypeOfElement = #PBBVariable          Species$ = StringField(pLine$(Pos), 1, " ")          SubSpecies$ = StringField(pLine$(Pos), 2, " ")          EName$ = StringField(pLine$(Pos), 3, " ")          ;          If Species$ <> MSpecies$            If Result$              Result$ + #CR$            EndIf            Result$ + Species$ + #CR$            Result$ + " " + PBB_Bullet$ + SubSpecies$ + #CR$            MSpecies$    = Species$            MSubSpecies$ = SubSpecies$          ElseIf SubSpecies$ <> MSubSpecies$            Result$ + #CR$ + " " + PBB_Bullet$ + SubSpecies$ + #CR$            MSubSpecies$ = SubSpecies$          EndIf          Result$ + "   " + EName$        Else          Result$ + pLine$(Pos)        EndIf        If SubSpecies$ = "Array" Or SubSpecies$ = "List" Or SubSpecies$ = "Map"          Result$ + "()"        EndIf        If Pos <> PosInElementList          Result$ + #CR$        EndIf      Next      ;      PBBResetContentAndStyles(NoREGadget)      ;      TOM_InsertText(NoREGadget, Result$, -1)      ;      ; Colorize and underline element names.      ;      ColorizeElementsNames(NoREGadget, 0, 0, #ListPBBPanel)      ;      If TypeOfElement = #PBBVariable        ;        SetInBold$ = "Global,Shared,Array,List,Map,Var"        ;        For Pos = 1 To 5          PosInCode = 0          Repeat            PosInCode = FindInPBStringCode(Result$, StringField(SetInBold$, Pos, ","), PosInCode + 1)            If PosInCode              pf = PosInCode + Len(StringField(SetInBold$, Pos, ","))              TOM_SetFontStyles(NoREGadget, "Bold,ForeColor(" + Str(GetValueFromBPPrefFile("NormalTextColor")) + ")", PosInCode - 1, pf)            EndIf          Until PosInCode = 0        Next      EndIf      ;      ; Restore the scroll position:      SendMessage_(GadgetID(NoREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)      ; Redisplay content in the gadget.      PBB_SuspendRedraw(NoREGadget, #False)      ;    Else      SetGadgetText(NoREGadget, GetTextFromCatalogPB("NoElementFound"))      TOM_SetFontStyles(NoREGadget, "ForeColor(" + Str(GetValueFromBPPrefFile("NormalTextColor")) + ")", 0, -1)    EndIf    ;    ListCompletionAll(TypeOfElement) = #ListCompletion_Printed    ReSizeREMenu()  EndIf  ;EndProcedure;Procedure DrawSearchHistoryButtons(*LastSearch.LastSearchDetails, NoREGadget)  ;  ; Updates the navigation history when displaying a page.  ; Also displays the [<-] and [->] buttons in the 'NoREGadget' gadget.  ;  ; This procedure is called by FillDetailREGadget() and FillFoundInREGadget().  ;  Shared SearchNavigationIndex ; For navigation in the search history.  ;  Protected SepSpace$, IButton$, BMarker$, TotLen  ;  ; Search for the expression in the navigation history (ListOfSearchs()).  ; If it exists, get its position.  ; If it does not exist, add an element to ListOfSearchs().  ;  Protected Found = 0  ;  ForEach ListOfSearchs()    If PurifyElementName(ListOfSearchs()\Search_Details\ElementName$) = PurifyElementName(*LastSearch\ElementName$) And (ListOfSearchs()\Search_Details\ElementType = *LastSearch\ElementType Or ListOfSearchs()\Search_Details\ElementType = -1 Or *LastSearch\ElementType = -1)      SearchNavigationIndex = ListIndex(ListOfSearchs()) + 1      If ListOfSearchs()\Search_Details\ElementType = -1        ListOfSearchs()\Search_Details\ElementType = *LastSearch\ElementType      EndIf      If ListOfSearchs()\Search_Details\TypeName$ = ""        ListOfSearchs()\Search_Details\TypeName$ = *LastSearch\TypeName$      EndIf      If Len(*LastSearch\ElementName$) > Len(ListOfSearchs()\Search_Details\ElementName$)        ListOfSearchs()\Search_Details\ElementName$ = *LastSearch\ElementName$      EndIf      Found = 1      Break    EndIf  Next  ;  If Found = 0    ;    ; Display a new page that was not in the history of displayed pages.    ;    ; From the index point of view, insert the page just after the current position,    ; which means shifting the indexes after the current position    ; and assigning (the current position + 1) to the newly created page.    ;    AddElement(ListOfSearchs())    SearchNavigationIndex = ListIndex(ListOfSearchs()) + 1    ListOfSearchs()\Search_Details\ElementName$ = *LastSearch\ElementName$    ListOfSearchs()\Search_Details\ElementType  = *LastSearch\ElementType    ListOfSearchs()\Search_Details\TypeName$    = *LastSearch\TypeName$    ListOfSearchs()\Search_DetailScrollPos\x = 0    ListOfSearchs()\Search_DetailScrollPos\y = 0    ListOfSearchs()\Search_FoundInScrollPos\x = 0    ListOfSearchs()\Search_FoundInScrollPos\y = 0  EndIf  ;  ; Displaying the '<< Previous' and 'Next >>' buttons:  ;  SepSpace$ = "  "  PBB_SuspendRedraw(NoREGadget, #True) ; Suspend the display in the Gadget,                                       ; to prevent scrolling, as colors are updated.  ;  PBBResetContentAndStyles(NoREGadget)  ;  WLightness = Lightness(GetGadgetColorEx(NoREGadget, #PB_Gadget_BackColor))  If SearchNavigationIndex > 1    If WLightness < 128      IButton$ = "DarkPrevious.jpg"    Else      IButton$ = "Previous.jpg"    EndIf    ; Insert a marker in the image to track what the user    ; clicked when they click on this image-button.    BMarker$ = #PBBRTFMarker$ + #PBBLeftArrowMarker$  Else    If WLightness < 128      IButton$ = "DarkNoPrevious.jpg" ; (inactive button).    Else      IButton$ = "NoPrevious.jpg" ; (inactive button).    EndIf    BMarker$ = #PBBRTFMarker$ + "none"  EndIf  ;  If CharButtons    ; The program is running on Windows 7 or earlier,    ; unable to display an image in the RichEdit. As a solution,    ; display the left arrow character instead.    If BMarker$      TOM_InsertText(NoREGadget, #PBBLeftArrow$, -1)    EndIf  Else    TOM_InsertTaggedJPGImageFromFile(NoREGadget, MyAppDataFolder$ + IButton$, BMarker$, -1)  EndIf  ;  ; Add spaces after the first button.  TOM_InsertText(NoREGadget, SepSpace$, -1)  ;  If SearchNavigationIndex < ListSize(ListOfSearchs())    If WLightness < 128      IButton$ = "DarkNext.jpg"    Else      IButton$ = "Next.jpg"    EndIf    ; Insert a marker in the image to track what the user    ; clicked when they click on this image-button.    BMarker$ = #PBBRTFMarker$ + #PBBRightArrowMarker$  Else    If WLightness < 128      IButton$ = "DarkNoNext.jpg" ; (inactive button).    Else      IButton$ = "NoNext.jpg" ; (inactive button).    EndIf    BMarker$ = #PBBRTFMarker$ + "none"  EndIf  If CharButtons    ; The program is running on Windows 7 or earlier,    ; unable to display an image in the RichEdit. As a solution,    ; display the right arrow character instead.    If BMarker$      TOM_InsertText(NoREGadget, #PBBRightArrow$, -1)    EndIf  Else    TOM_InsertTaggedJPGImageFromFile(NoREGadget, MyAppDataFolder$ + IButton$, BMarker$, -1)  EndIf  ;  TOM_InsertText(NoREGadget, SepSpace$, -1)  ;  TotLen = TOM_GetRealPos(NoREGadget, -1)  ;  If CharButtons    TOM_SetFontStyles(NoREGadget, #PBBArrowsFontStyle$, 0, TotLen - 1)  EndIf  ;  TOM_SetParaStyles(NoREGadget, "LeftIndent(40), FirstLineIndent(-40), RightIndent(20)", 0, 1)  ;  ProcedureReturn TotLenEndProcedure;Procedure FillDetailREGadget(*LastSearch.LastSearchDetails)  ;  ; Fills a RichEdit Gadget with the details of an element (name, parameters, and code),  ; then assigns colors to different parts of the PureBasic code of the element.  ;   ; Before calling this procedure, the list 'ElementsList()' must have been completed.  ; The 'CompleteListOfAllElements()' procedure should have handled this.  ; If the second phase of exploration is finished, the element names will be  ; displayed in their normal colors or in gray, depending on whether they are used or not.  ;  Shared VList.VariableListings, ListOfMacro$  ;  Protected REContentString.string  ;  Protected ElementName$, FSource$, CompleteElementDeclaration$                   ; Properties of the displayed element.  Protected EComment$, ElementNameLCase$, ElementUsed, DeclarationDetails$  Protected ElementParent$, ElementStartingPos, ElementEndingPos, ElementTitle$  ;    Protected EndNamePos, EndCommentPos, EndIntroPos, posa, posb, LenButtonsIntro   ; Positions in the text for coloring.  Protected *EContent.String, NEContent$  Protected CurrentDecal, ListDecal$, pEnd, pR, pRef, pRet, Decal, mDecal, nl     ; For managing indentations.  Protected UseByMention$                                                         ; For the "used by..." mention.  Protected scrollPos.Point                                                       ; Scroll position before re-displaying the content.  ;  ; Other variables:  Protected EValue$, EndDeclarPos, IParentPos, IParent$, EEnumeration$, pEqual  Protected LenToDelete, PosInCode, Line$, ext$, mp, Introtext$, NoDetail, PValue$  ;  Protected DetailREGadget = NoREGadgetOfPBBPanel(#DetailPBBPanel)  ;  Protected SExpression$  = PurifyElementName(*LastSearch\ElementName$)  Protected TypeOfElement = *LastSearch\ElementType  Protected PBBUnusedElementColor = GetPBBNumParameter("PBBUnusedElementColor")  Protected PBBElementNameColor = GetPBBNumParameter("PBBElementNameColor")  Protected PBBElementDetailsColor = GetPBBNumParameter("PBBElementDetailsColor")  Protected PBB_Bullet$ = GetPBBStringParameter("PBB_Bullet") + #NonBreakableSpace$  ;  ;  If TypeOfElement = #PBBProcedure    SetGadgetColorEx(DetailREGadget, #PB_Gadget_BackColor, GetValueFromBPPrefFile("ProcedureBackColor"))  Else    SetGadgetColorEx(DetailREGadget, #PB_Gadget_BackColor, GetValueFromBPPrefFile("BackgroundColor"))  EndIf  ;  LenButtonsIntro = DrawSearchHistoryButtons(*LastSearch, DetailREGadget)  ;  If SExpression$    ;     If TypeOfElement = #PBBProcedure And ListCompletionAll(#PBBVariable) = #ListCompletion_Done      ; "ListCompletionAll(#PBBVariable) = #ListCompletion_Done" is tested because the exploration      ; of procedure variables is only reliable once the 'Shared' and 'Global' variables have been identified.      ListVariables(SExpression$, VList)    EndIf    ;    If TypeOfElement > -1      ;      ; *************************************************      ; Introduction text      ;      If TypeOfElement < #EndEnumPBBElementTypes        If ListCompletionAll(TypeOfElement) < #ListCompletion_Done          ; Ensure that all elements have already been inventoried,          ; and if not, do so as a priority.          SetOneListOfAllElements(TypeOfElement, #FinishCompletionNow)          CloseWaitingWindow()        EndIf        If CheckIfElementExistsInList(SExpression$, TypeOfElement) > -1          ElementName$       = ElementsList()\Name          ElementNameLCase$  = ElementsList()\NameLCase          ElementParent$     = ElementsList()\Parents          ElementUsed        = ElementsList()\Used          ElementStartingPos = ElementsList()\StartingPos          ElementEndingPos   = ElementsList()\EndingPos          FSource$           = ElementsList()\FileName          CompleteElementDeclaration$ = ElementsList()\Declaration          DeclarationDetails$ = ElementsList()\DeclarationDetails          ;          ElementTitle$      = CompleteElementDeclaration$          If ElementTitle$ = ElementName$ Or ElementTitle$ = ElementName$ + ":" Or FastLeft(ElementName$, 1) = "#"            ElementTitle$    = GetTextFromCatalogPB(PBBTypeNames$(TypeOfElement)) + " " + ElementTitle$          EndIf          ElementTitle$      = ReplaceString(ElementTitle$, "(", " (")          While FindString(ElementTitle$, "  ")            ElementTitle$    = ReplaceString(ElementTitle$, "  ", " ")          Wend          ElementTitle$      = Trim(ElementTitle$)          :           If TypeOfElement = #PBBConstante            EValue$ = ElementsList()\Value            If EValue$              ; For constants, particularly when no value has been declared at              ; the time of declaration, or when the value is derived from any calculation,              ; check if it(s possible to deduce or interpret this value              ; during the exploration. The procedure 'SetOneListOfAllElements()' attempts,              ; in fact, an interpretation of the value of constants in an enumeration.              ; (See this procedure for more details).              pEqual = FindString(ElementTitle$, "=")              If pEqual = 0                ElementTitle$ + " = " + EValue$              Else                PValue$ = Trim(FastMid(ElementTitle$, pEqual + 1))                If EValue$ = "UnResolved"                  ElementTitle$ + " (" + EValue$ + ")"                ElseIf Val(PValue$) <> Val(EValue$) Or FindString(PValue$, "#")                  ElementTitle$ + " (=" + EValue$ + ")"                EndIf              EndIf            EndIf            EndDeclarPos = Len(ElementTitle$)            EEnumeration$ = DeclarationDetails$            If EEnumeration$              ElementTitle$ + " (" + PBBTypeNames$(#PBBEnumeration) + " " + EEnumeration$ + ")" + #CR$            EndIf          Else            EndDeclarPos = Len(ElementTitle$)          EndIf          ;          REContentString\s = ElementTitle$          EndNamePos = Len(REContentString\s)          If TypeOfElement > #PBBInterface            ; There is no code to display for labels and constants.            ; The user will therefore not have the opportunity to see the accompanying comments            ; So, display them after the declaration of the element.            EComment$ = ElementsList()\Comment            If EComment$              REContentString\s + " " + EComment$            EndIf          EndIf          If Right(REContentString\s, 1) <> #CR$            REContentString\s + #CR$          EndIf          EndCommentPos = Len(REContentString\s)          If TypeOfElement = #PBBProcedure And DeclarationDetails$            REContentString\s + PBB_Bullet$ + GetTextFromCatalogPB("declaredIn") + " "            REContentString\s + GetFilePart(StringField(DeclarationDetails$, 1, "/")) + ", " + GetTextFromCatalogPB("AtLine") + " " + StringField(DeclarationDetails$, 2, "/") + "." + #CR$          EndIf          REContentString\s + PBB_Bullet$ + GetTextFromCatalogPB("definedIn") + " "          REContentString\s + GetFilePart(FSource$) + ", " + GetTextFromCatalogPB("AtLine") + " " + ElementsList()\StartingLine + "." + #CR$          ;          If ElementParent$ And ElementParent$ <> "/"            IParentPos = 1            Repeat              IParentPos + 1              IParent$ = StringField(ElementParent$, IParentPos, "/")              If IParent$                If Val(IParent$) <> -1                  SelectElement(ElementsList(), Val(IParent$))                  UseByMention$ + ElementsList()\Name + ", "                Else                  UseByMention$ + GetTextFromCatalogPB(#OutOfElementsName) + ", "                EndIf              EndIf            Until IParent$ = ""            ;            If Right(UseByMention$, 2) = ", "              UseByMention$ = FastLeft(UseByMention$, Len(UseByMention$) - 2)            EndIf            ;            REContentString\s + PBB_Bullet$ + GetTextFromCatalogPB("usedBy") + ": " + UseByMention$ + "." + #CR$            ;          ElseIf ListCompletionUsed(TypeOfElement) = #ListCompletion_Done            REContentString\s + PBB_Bullet$ + GetTextFromCatalogPB("Unused") + "." + #CR$          EndIf          ;          ; List of unprotected or protected variables:          If TypeOfElement = #PBBProcedure And VList\Unused            REContentString\s + PBB_Bullet$ + VList\Unused + "." + #CR$          EndIf          If TypeOfElement = #PBBProcedure And VList\Unprotected            REContentString\s + PBB_Bullet$ + VList\Unprotected + "." + #CR$          EndIf          If TypeOfElement = #PBBProcedure And VList\CompleteList            REContentString\s + GetTextFromCatalogPB("SeeVariablesList") + "." + #CR$          EndIf          ;          If TypeOfElement = #PBBProcedure And ListOfMacro$            ; Remove the final tabulation from ListOfMacro$ and            ; replace the tabs with commas:            ListOfMacro$ = ReplaceString(FastLeft(ListOfMacro$, Len(ListOfMacro$) - 1), #TAB$, ", ")            REContentString\s + PBB_Bullet$ + GetTextFromCatalogPB("CalledMacros") + ListOfMacro$ + "." + #CR$          EndIf          ;          REContentString\s + #CR$          ;          ; Replace #CR$ with #CRLF$ (#CR$ + #LF$) to avoid display bugs.          ; NOTE: The text inserted in a RichEdit Gadget should always end with #CRLF$          ; (#CR$ + #LF$) in the line endings. However, when retrieving the cursor position          ; in such a gadget (SendMessage_(GadgetID(RE_gadget), #EM_EXGETSEL, 0, *txtrange))          ; or when modifying the selection (SendMessage_(GadgetID(RE_Gadget), #EM_EXSETSEL, 0, @txtrange)),          ; line breaks only occupy a single character position.          ; In what follows, we manage this peculiarity as follows:          ; • The text inserted in the gadget always contains #CR$ + #LF$.          ; • The 'REContentString\s' reference chain, which is used for position calculations,          ;   contains only #CR$ at the end of lines.          TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, #CR$, #CRLF$), -1)          ;          ; The use of bullet points in the text interferes with the behavior of REGadget under Windows          ; and alters the font defined for their contents. Therefore, reapply it          ; to the content that has just been added.          TOM_SetFontStyles(DetailREGadget, PBBPanelsDefaultFontStyle$, LenButtonsIntro, -1)          TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(0)", LenButtonsIntro + 1, -1)          ;          EndIntroPos = TOM_GetRealPos(DetailREGadget, -1) ; Mark the position in the text.          ;          REContentString\s = Space(LenButtonsIntro) + REContentString\s ; REContentString\s will serve as a reference          ; for the various formatting and color functions that will follow, in order to know the          ; content of the DetailREGadget text at specific locations. Therefore, the space          ; occupied by the 'Previous' and 'Next' buttons, as well as by the markers and spaces around them,          ; must be integrated into its content.          ;          EndNamePos + LenButtonsIntro  ; same for EndNamePos, which marks the end of the element name.          EndCommentPos + LenButtonsIntro ; same for the end of the comment position.          EndDeclarPos + LenButtonsIntro  ; same for the declaration end position.          ;          ; Now add the content (the code) of the element:          ;          *EContent = GetPointedElementContentFromFile(FSource$, ElementStartingPos, ElementEndingPos, #False)          ;          ; ************************************************************          ;   Replacement of left spaces with 'OffsetIndent'          ;          ; It may happen that the element code is not aligned to the left          ; (for example, when retrieving the content of a structure declared in a procedure).          ; Check how the 'EndElement' ('EndStructure', for example) is aligned          ; and shift everything to the left accordingly:          ;          pEnd = ReverseFindString(*EContent\s, "End")          pRet = ReverseFindString(*EContent\s, #CR$, pEnd)          LenToDelete = pEnd - pRet - 1          ;          ; Now read the content of the element line by line,          ; remove the spaces at the beginning of each line,          ; and store their count, so we can later apply an OffsetIndent (left shift) to these lines.          ;          CurrentDecal = 0          ListDecal$ = ""          NEContent$ = ""          ;            If pEnd            pR = 0            pRef = 1            Repeat              PosInCode = pR + 1              If PosInCode < Len(*EContent\s)                pR = FindString(*EContent\s, #CR$, pR + 1)                If pR = 0 : pR = Len(*EContent\s) + 1 : EndIf                ; Count the spaces at the beginning of the line.                Decal = 0                While FastMid(*EContent\s, PosInCode, 1) = " " : PosInCode + 1 : Decal + 1 : Wend                Line$ = FastMid(*EContent\s, PosInCode, pR - PosInCode)                ;                ; If the element's text was not left-aligned, correct it.                If Decal >= LenToDelete                  Decal - LenToDelete                EndIf                ;                ; To save time, only memorize changes in alignment                ; (positive or negative).                Decal - CurrentDecal                CurrentDecal + Decal                If Decal                  ; Memorize the changes in a string that will contain a series of                  ; 'position in the text' + #TAB$ + Str(shift) + #TAB$.                  ListDecal$ + Str(pRef - 1) + #TAB$ + Str(Decal) + #TAB$                EndIf                pRef + (pR - PosInCode) + 1                ; Store the line without the left spaces.                NEContent$ + Line$ + #CR$              EndIf            Until PosInCode >= Len(*EContent\s)            ; Don't forget to memorize the last shift position.            ListDecal$ + Str(pRef - 1) + #TAB$ + Str(Decal) + #TAB$          EndIf          ; Update the reference string with the element content.          REContentString\s + NEContent$          ; Update the RE_Gadget with the content of the item:          TOM_InsertText(DetailREGadget, ReplaceString(#CR$ + NEContent$, #CR$, #CRLF$), -1)          ;          TOM_SetFontStyles(DetailREGadget, PBBCodeFontStyle$, EndIntroPos, -1)          ;          ; Apply an 'offset' (shift the lines following the first line)          ; across the entire code. Since the gadget will be displayed in 'Wrap' mode, this helps          ; visually align when a line is split into several pieces.          TOM_SetParaStyles(DetailREGadget, "LeftIndent(5.5), FirstLineIndent(-5.5)", EndIntroPos + 1, -1)          ;          ; Now, apply 'LeftIndent' (left shifts)          ; according to what is listed in the 'ListDecal$' string.          nl = 0          PosInCode = EndIntroPos + 1 ; Position of the beginning of the code wich has been inserted into the RE_Gadget.          Decal = 0          Repeat            nl + 1            ext$ = StringField(ListDecal$, nl, #TAB$)            If ext$              mp = PosInCode              PosInCode = Val(ext$) + EndIntroPos + 1              nl + 1              mDecal + Decal              Decal = Val(StringField(ListDecal$, nl, #TAB$))              ; For each shift read, apply the previous shift              ; to everything before the given position.              TOM_SetParaStyles(DetailREGadget, "LeftIndent(" + Str(5.5 * (mDecal + 1)) + ")", mp, PosInCode - 1)              ; This ensures the desired effect, where each shift              ; is applied to all the text, up to the next shift.              ; It may seem complicated, but it reduces the number              ; of operations by two or three times compared to a method              ; that would adjust the shift line by line for all              ; the lines.            EndIf          Until ext$ = ""          ;          ;          ; Convert the reference string to lowercase so that the searches          ; that follow are 'NoCase' (case-insensitive).          ;          REContentString\s = LCase(REContentString\s)          ;          ; ************************************************************          ;                Coloring and styles          ;          ;          ; Color the name of the element placed as a title, as well as its arguments:          ;          If ElementUsed Or ListCompletionUsed(TypeOfElement) < #ListCompletion_Done            ; If deep exploration is not finished, display the element            ; by default as if it were used.            TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(PBBElementNameColor) + ")", LenButtonsIntro, EndDeclarPos)          Else            TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(PBBUnusedElementColor) + ")", LenButtonsIntro, EndDeclarPos)          EndIf          TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(-40)", 0, EndDeclarPos)          ;          ; Make the name of the element bold.          posa = FindString(REContentString\s, ElementNameLCase$) - 1          posb = FindString(REContentString\s, ".", posa)          If posb = 0 Or posb > posa + Len(ElementNameLCase$)            posb = posa + Len(ElementNameLCase$)          EndIf          ;          If posa            TOM_SetFontStyles(DetailREGadget, "Bold", posa, posb)          EndIf          ;          ; Display all other details in gray          ; in the presentation of the element:          TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(PBBElementDetailsColor) + ")", EndDeclarPos, EndIntroPos)          ;          ; Apply a left margin to all details          ; that follow the line where the name of the element is located.          ; in the presentation of the element:          posa = FindString(REContentString\s, #CR$)          TOM_SetParaStyles(DetailREGadget, "LeftIndent(40)", posa, EndIntroPos)          ;          ; Underline the links          ;          UnderlineFNamesAndLinks(DetailREGadget, 0, REContentString, 1)          ;          ; Color the comments          ;          ColorizeComments(DetailREGadget, 0, 0, REContentString)          ;          ; Display the result which has been achieved so far to reduce          ; the waiting time for the user:          SendMessage_(GadgetID(DetailREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)          PBB_SuspendRedraw(DetailREGadget, #False)          PBB_SuspendRedraw(DetailREGadget, #True)          ;          ; Color the names of the elements.          ;          ColorizeElementsNames(DetailREGadget, EndDeclarPos, 0, #DetailPBBPanel, REContentString, ElementNameLCase$)          ;          ; Color the keywords of PureBasic (if, endif, while, wend, etc.)          ; and make them bold.          ;          ColorizeBasicKeyWords(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; Color the names of native constants (or Windows constants).          ;          ColorizeNativeConstants(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; Color the text between quotes.          ;          ColorizeInQuote(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; Color the names of native PureBasic functions          ; (this takes the most time, as there are almost 2000 functions).          ;          ColorizeNativePBFunctions(DetailREGadget, EndIntroPos, 0, REContentString)          ;        EndIf        ;      ElseIf TypeOfElement = #PBBNativeFunction Or TypeOfElement = #PBBBasicKeyword        If TypeOfElement = #PBBNativeFunction          Introtext$ = *LastSearch\ElementName$ + "() " + GetTextFromCatalogPB("AboutNativeFunction")        ElseIf TypeOfElement = #PBBBasicKeyword          Introtext$ = *LastSearch\ElementName$ + " " + GetTextFromCatalogPB("AboutBasicKeyword")        EndIf        ;        TOM_InsertText(DetailREGadget, ReplaceString(Introtext$, #CR$, #CRLF$), -1)        Introtext$ = Space(LenButtonsIntro) + Introtext$        ;        ; Colorize the expression name        TOM_SetFontStyles(DetailREGadget, "ForeColor(" + Str(PBBElementNameColor) + "), Underline(Single), Bold", LenButtonsIntro, LenButtonsIntro + Len(SExpression$))        ; Create a left indent for the second line:        posa = FindString(Introtext$, #CR$) + 1        TOM_SetParaStyles(DetailREGadget, "LeftIndent(40)", posa + 1, posa + 2)      Else        ; We should never arrive here. So, if that's the case,        ; display an error:        AlertInPBBWindow("Error in procedure FillDetailREGadget : TypeOfElement is unknown (" + Str(TypeOfElement) + ").")      EndIf    Else      NoDetail = 1    EndIf  Else    NoDetail = 1  EndIf  If NoDetail    If SExpression$      REContentString\s = ReplaceString(GetTextFromCatalogPB("NoDetailFound"), "%SExpression$%", "'" + SExpression$ + "'")      TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, #CR$, #CRLF$), -1)      ;          ; Color the expression name      PosInCode = FindString(REContentString\s, SExpression$)      TOM_SetFontStyles(DetailREGadget, "ForeColor(" + Str(PBBElementNameColor) + "), Bold", LenButtonsIntro + PosInCode - 1, LenButtonsIntro + PosInCode - 1 + Len(SExpression$))    Else      REContentString\s = GetTextFromCatalogPB("NoDetailNoExpression")      TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, #CR$, #CRLF$), -1)    EndIf    PosInCode = FindString(REContentString\s, #CR$)    If PosInCode And PosInCode < Len(REContentString\s)      TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(0), RightIndent(20)", LenButtonsIntro + PosInCode + 1, -1)    EndIf  EndIf  ;  ; Reset the scroll position to its initial state:    scrollPos\x = ListOfSearchs()\Search_DetailScrollPos\x  scrollPos\y = ListOfSearchs()\Search_DetailScrollPos\y  SendMessage_(GadgetID(DetailREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)  ;  ; Restore the display in the gadget:  PBB_SuspendRedraw(DetailREGadget, #False)  ;  ReSizeREMenu()EndProcedure;Procedure FillFoundInREGadget(*LastSearch.LastSearchDetails)  ;  ; Fills the FoundInFilesREGadget with the items found in the file list  ; after searching for the expression contained in *LastSearch\ElementName$.  ;  Shared VarWithArguments  ;  Static LastPrintedExpression$ ; Last expression displayed in the panel.                                ;  Protected REContentString.string  Protected PosInCode, mp, LenButtonsIntro, IsUnused, PrintedExpression$  Protected FoundInFilesREGadget, BatchListFoundInFiles$, Reset  Protected scrollPos.Point ; Scroll position before redisplaying the content  Protected mSExpression$, SExpression$, RemainingString$, LastCRPos, StartPos  Protected PBBElementNameColor = GetPBBNumParameter("PBBElementNameColor")  Protected PBB_Bullet$ = GetPBBStringParameter("PBB_Bullet") + #NonBreakableSpace$  ;  FoundInFilesREGadget = NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel)  ;  ; Now proceeding with the search for the expression,  ; to complete the "Found In..." panel.  ;  ; Keep only what's before the #SpecialSpace$ character.  ; (See 'BSearchExpression' for details).  ;  mSExpression$ = *LastSearch\ElementName$  SExpression$ = PurifyElementName(*LastSearch\ElementName$)  ;  ; DrawSearchHistoryButtons() will draw the << and >> buttons in the REGadget  ; by adding markers so that ClickOverREGadget can recognize them  ; when the user clicks on them:  LenButtonsIntro = DrawSearchHistoryButtons(*LastSearch, FoundInFilesREGadget)  ;  REContentString\s = ""  BatchListFoundInFiles$ = "Pending"  If SExpression$    If LastPrintedExpression$ = SExpression$      ; We are about to refresh content that is already displayed.      ; Memorize the scroll position to restore it      ; at the end of the procedure.      SendMessage_(GadgetID(FoundInFilesREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)    Else      LastPrintedExpression$ = SExpression$      scrollPos\x = 0      scrollPos\y = 0    EndIf    ;    ; If the lists have already been populated, check if the expression    ; matches the name of a list, array, or map:    If FindString(*LastSearch\TypeName$, "Array") Or FindString(*LastSearch\TypeName$, "List") Or FindString(*LastSearch\TypeName$, "Map")      VarWithArguments = 1    Else      VarWithArguments = 0    EndIf    ; Initiate the search in the code files,    ; to see if anything is found:    Reset = #True    Repeat      RemainingString$ = SetListFoundInFiles(SExpression$, Reset)      ; SetListFoundInFiles() stops after 100 milliseconds.      ; It returns "Pending" if it hasn't managed to      ; find anything during this time, but the entire      ; file set hasn't been explored yet.      Reset = #False    Until RemainingString$ <> "Pending"    ;    If RemainingString$      ; The expression was found.      ;      RemainingString$ = #CR$ + RemainingString$      ;      ; Display the title and introductory text:      PrintedExpression$ = SExpression$      ; Add the type of the expression, if any, and restore the case, if necessary:      If *LastSearch\TypeName$ And PrintedExpression$ = LCase(*LastSearch\ElementName$) Or PrintedExpression$ + "." = Left(LCase(*LastSearch\ElementName$), Len(PrintedExpression$ + "."))        PrintedExpression$ = *LastSearch\ElementName$ + " (" + *LastSearch\TypeName$ + ")"      Else        PrintedExpression$ = mSExpression$      EndIf      REContentString\s = PrintedExpression$ + #CR$ + GetTextFromCatalogPB("FoundListIntro") + #CR$ + GetTextFromCatalogPB("MoreInfo") + " "      TOM_InsertText(FoundInFilesREGadget, ReplaceString(REContentString\s, #CR$, #CRLF$), -1)      ;      TOM_SetFontStyles(FoundInFilesREGadget, PBBPanelsDefaultFontStyle$, LenButtonsIntro, -1)      ;      ; Add spaces to REContentString\s corresponding to the space      ; occupied by the buttons and markers, so that searches      ; made later on this string will return a position identical to      ; what is actually in the gadget.      REContentString\s = Space(LenButtonsIntro) + LCase(REContentString\s)      ;      ; Making the expression's name bold and colored      ; in the following three lines might seem redundant      ; with the coloring done by ColorizeElementsNames()      ; right after. However, ColorizeElementsNames() only colors      ; element names and only when the exploration has gone far enough      ; to allow elements to be identified. If our expression is not      ; a recognized element, these two lines will still ensure      ; that it is well presented.      TOM_SetFontStyles(FoundInFilesREGadget, "ForeColor(" + Str(PBBElementNameColor) + ")", LenButtonsIntro, LenButtonsIntro + Len(PrintedExpression$))      TOM_SetFontStyles(FoundInFilesREGadget, "Bold", LenButtonsIntro, LenButtonsIntro + Len(SExpression$))      ;      ; Color the title gray if it is an unused element,      ; or in 'PBBElementNameColor' otherwise.      ; ColorizeElementsNames() returns a value telling us      ; if the expression is used.      IsUnused = ColorizeElementsNames(FoundInFilesREGadget, 1, PBBElementNameColor, #FoundInFilesPBBPanel, REContentString, SExpression$)      ; Underline "More info..."      UnderlineFNamesAndLinks(FoundInFilesREGadget, 1, REContentString)      ;      ; Set a left margin for the "More info..." mention      PosInCode = FindString(REContentString\s, #CR$, 0)      TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(40), FirstLineIndent(0)", PosInCode, -1)      ;    EndIf  EndIf  ;  If REContentString\s    Repeat      ;      If BatchListFoundInFiles$                If FindString(BatchListFoundInFiles$, #CR$) = 0          ; There is no line break in the result string. This means SetListFoundInFiles()          ; is producing a long result string that has been segmented into several parts.          ; Store the results found in RemainingString$ until the line          ; is completed.          If BatchListFoundInFiles$ <> "Pending"            RemainingString$ = RemainingString$ + BatchListFoundInFiles$            ; And set "Pending" to BatchListFoundInFiles$ to continue processing:            BatchListFoundInFiles$ = "Pending"          EndIf        Else          ; If RemainingString$ contains a portion of text from the previous pass,          ; integrate it with the newly obtained results:          If Right(RemainingString$, 2) = ", " And FastLeft(BatchListFoundInFiles$, 1) = #CR$            RemainingString$ = FastLeft(RemainingString$, Len(RemainingString$) - 2)          EndIf          BatchListFoundInFiles$ = RemainingString$ + BatchListFoundInFiles$          ; Look for the last line break character in the string:          LastCRPos = Len(BatchListFoundInFiles$)          While LastCRPos And PeekC(@BatchListFoundInFiles$ + (LastCRPos - 1) * SizeOf(CHARACTER)) <> #CR            LastCRPos - 1          Wend          ;          If (Len(BatchListFoundInFiles$) - LastCRPos) > 1            ; Set aside (in RemainingString$) everything after the last line break found.            ; This way, styles will be applied to entire paragraphs:            RemainingString$ = FastMid(BatchListFoundInFiles$, LastCRPos)            BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, LastCRPos - 1)          Else            RemainingString$ = ""          EndIf        EndIf      Else        BatchListFoundInFiles$ = RemainingString$        RemainingString$ = ""      EndIf      If Right(BatchListFoundInFiles$, 2) = ", "        BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, Len(BatchListFoundInFiles$) - 2)      EndIf            If BatchListFoundInFiles$ And BatchListFoundInFiles$ <> "Pending"                ;        ; Insert the results just obtained into the gadget:        ;        StartPos = Len(REContentString\s) + 1        TOM_InsertText(FoundInFilesREGadget, ReplaceString(BatchListFoundInFiles$, #CR$, #CRLF$), -1)        TOM_SetFontStyles(FoundInFilesREGadget, PBBPanelsDefaultFontStyle$, StartPos, -1)        ;        REContentString\s + LCase(BatchListFoundInFiles$)        ;        ; Set an offset for lines starting with a bullet:        ;        PosInCode = StartPos        Repeat          mp = PosInCode          While FastMid(REContentString\s, mp, 1) = #CR$ : mp + 1 : Wend          If mp <> PosInCode            ; The text to format starts with a carriage return.            ; Stop any previous indentation applied to the previous line:            TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(0), FirstLineIndent(0)", mp, mp + 1)          EndIf          ;          ; Search for the end of the line:          PosInCode = FindString(REContentString\s, #CR$, mp)          If PosInCode = 0 : PosInCode = Len(REContentString\s) : EndIf          ;          If FastMid(REContentString\s, mp, 2) = PBB_Bullet$            ; The line starts with a bullet. Apply an indentation and an offset:            TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(10), FirstLineIndent(-5)", mp, PosInCode - 1)          EndIf        Until PosInCode = Len(REContentString\s)        ;        ColorizeElementsNames(FoundInFilesREGadget, StartPos, 0, #FoundInFilesPBBPanel, REContentString)        ColorizeBasicKeyWords(FoundInFilesREGadget, StartPos, 0, REContentString, IsUnused)        UnderlineFNamesAndLinks(FoundInFilesREGadget, StartPos, REContentString)        ;        ; Refresh the display:        SendMessage_(GadgetID(FoundInFilesREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)        PBB_SuspendRedraw(FoundInFilesREGadget, #False)        PBB_SuspendRedraw(FoundInFilesREGadget, #True)      EndIf      ;      BatchListFoundInFiles$ = SetListFoundInFiles(SExpression$, #False)      ;    Until BatchListFoundInFiles$ = "" And RemainingString$ = ""    ;  Else    ;    TOM_InsertText(FoundInFilesREGadget, ReplaceString(GetTextFromCatalogPB("ShouldSearchForSomething"), #CR$, #CRLF$), -1)  EndIf  ;  ; Reset the scroll position to its initial position:  scrollPos\x = ListOfSearchs()\Search_FoundInScrollPos\x  scrollPos\y = ListOfSearchs()\Search_FoundInScrollPos\y  SendMessage_(GadgetID(FoundInFilesREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)  ; Restore the gadget's display:  PBB_SuspendRedraw(FoundInFilesREGadget, #False)  ReSizeREMenu()  ;EndProcedure;Procedure OpenFileWithPureBasic(FNameWithoutPath$, LineNumber$)  ;  ; Searches for FNameWithoutPath$ in PBBListOfFiles$ and opens the file  ; in the PureBasic editor if a result is found.  ;  ; Uses global variables PBBListOfFiles$ and PureBasicProgAddr$  ;  Shared MustStayActive  ;  Protected PosInList, pf, FFile$, FParam$, FPath$  ;  PosInList = FindString(PBBListOfFiles$, "\" + FNameWithoutPath$, 0) ; Searches for the expression in PBBListOfFiles$.  If PosInList    pf = PosInList + Len(FNameWithoutPath$) + 1    While PosInList > 1 And Mid(PBBListOfFiles$, PosInList - 1, 1) <> #TAB$ And Mid(PBBListOfFiles$, PosInList - 1, 1) <> #CR$ : PosInList - 1 : Wend    FFile$ = Mid(PBBListOfFiles$, PosInList, pf - PosInList)    If FindString(FFile$, "\Temp\PureBasic_TempFile") ; This is a temporary file. Its address is not passed.      FParam$ = ""      FPath$ = ""      AlertInPBBWindow(GetTextFromCatalogPB("SaveFilePrompt"))    Else      FPath$  = #DOUBLEQUOTE$ + GetPathPart(FFile$) + #DOUBLEQUOTE$      FParam$ = #DOUBLEQUOTE$ + FFile$ + #DOUBLEQUOTE$    EndIf    If LineNumber$      If #PB_Compiler_OS = #PB_OS_Windows        FParam$ + " /L " + LineNumber$ ; This addition to the parameters positions the PureBasic editor on a specific line.      Else        FParam$ + " -line " + LineNumber$ ; This addition to the parameters positions the PureBasic editor on a specific line.      EndIf    EndIf    ;    ; In case of double-click by the user, avoid    ; overwhelming the editor with too many requests:    ; there must be at least 500 ms since the last    ; click for it to be taken into account.    If PureBasicProgAddr$ And (ElapsedMilliseconds() - MustStayActive) > 500      RunProgram(#DOUBLEQUOTE$ + PureBasicProgAddr$ + #DOUBLEQUOTE$, FParam$, FPath$)      MustStayActive = ElapsedMilliseconds()    EndIf  EndIfEndProcedure;; ***********************************************************;;-                  Main Window Management;; ***********************************************************;Procedure.s ComputeExpressionField(*LastSearch.LastSearchDetails)  Protected RetValue$ = *LastSearch\ElementName$  If *LastSearch\TypeName$    RetValue$ + #SpecialSpace$ + " (" + *LastSearch\TypeName$ + ")"  EndIf  ProcedureReturn RetValue$EndProcedure;Procedure WalkOverPages(NextOrPreviewAsked)  ;  Shared SearchNavigationIndex  ;  Protected mNavigationIndex, ExpressionInList$  ;  mNavigationIndex = SearchNavigationIndex  ;  If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel    ; The user just clicked on the 'Next' or 'Previous' button.    ; (These two buttons are located in the 'Details' and 'Found in...' panels)    ;    ; The page to display will be searched by exploring the history    ; of previously displayed pages.    If ListSize(ListOfSearchs())      SearchNavigationIndex + NextOrPreviewAsked      If SearchNavigationIndex < 1        SearchNavigationIndex = 1      EndIf      If SearchNavigationIndex > ListSize(ListOfSearchs())        SearchNavigationIndex = ListSize(ListOfSearchs())      EndIf      ForEach ListOfSearchs()        If ListIndex(ListOfSearchs()) = SearchNavigationIndex - 1          ExpressionInList$ = ComputeExpressionField(ListOfSearchs()\Search_Details)          Break        EndIf      Next      ;      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, ExpressionInList$)      If GetActivePBBPanel() = #DetailPBBPanel        FillDetailREGadget(ListOfSearchs()\Search_Details)      ElseIf GetActivePBBPanel() = #FoundInFilesPBBPanel        FillFoundInREGadget(ListOfSearchs()\Search_Details)      EndIf    EndIf  EndIf  If mNavigationIndex <> SearchNavigationIndex    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure WalkOverPannels(PStep)  ; Switches from one panel to another based on  ; shortcut key presses.  ;  Shared RefreshEPanel  ;  Protected ActPannel  ;  ActPannel = GetActivePBBPanel()  If PStep = 1    If ActPannel = #FoundInFilesPBBPanel      ActPannel = #FilePBBPanel    ElseIf ActPannel = #FilePBBPanel      ActPannel = #ProcPBBPanel    ElseIf ActPannel = #EndEnumPBBPanels - 1      ActPannel = #DetailPBBPanel    Else      ActPannel + 1    EndIf  Else    If ActPannel = #FilePBBPanel      ActPannel = #FoundInFilesPBBPanel    ElseIf ActPannel = #DetailPBBPanel      ActPannel = #EndEnumPBBPanels - 1    ElseIf ActPannel = #ProcPBBPanel      ActPannel = #FilePBBPanel    Else      ActPannel - 1    EndIf  EndIf  SetActivePBBPanel(ActPannel)  ReSizeREMenu()  If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel    WalkOverPages(0)  Else    RefreshEPanel = #True  EndIfEndProcedure;Procedure.s GetImageNameFromSelectionPos(NoREGadget)  ;  ; This procedure examines the RTF content just before the start of the selection  ; to see if it contains the image marker that is typically located just before an image-button.  ;  Protected PosInText, pf, ExpressionUnderCursor$  Protected ImageButtonName$ ; Return value.                             ;  ; Retrieve the cursor position in the text.  PosInText = TOM_GetRealPos(NoREGadget)  ;  If CharButtons ; CharButtons is a global variable set in 'PBBrowserDeclarations.pb'.    ; The program is running under Windows 7 or an earlier version.    ; The buttons are not displayed as images but as one or more characters.    If FindString(TOM_GetText(NoREGadget, "", max(0, PosInText - Len(#PBBLeftArrow$)), PosInText + Len(#PBBLeftArrow$)), #PBBLeftArrow$)      ProcedureReturn #PBBLeftArrowMarker$    ElseIf FindString(TOM_GetText(NoREGadget, "", max(0, PosInText - Len(#PBBRightArrow$)), PosInText + Len(#PBBRightArrow$)), #PBBRightArrow$)      ProcedureReturn #PBBRightArrowMarker$    EndIf  Else    ; Retrieve the RTF code of the previous 20 characters:    ExpressionUnderCursor$ = TOM_GetText(NoREGadget, "RTF", PosInText - 20, PosInText)    ;    PosInText = FindString(ExpressionUnderCursor$, #PBBRTFMarker$, 0)    If PosInText      ; A marker has been found. It is indeed a click on an image-button.      ; Extract the marker name to identify the button.      ImageButtonName$ = ""      PosInText + Len(#PBBRTFMarker$)      pf = FirstOccurrenceOfChar(ExpressionUnderCursor$, " }\", PosInText)      If pf = 0 : pf = Len(ExpressionUnderCursor$) + 1 : EndIf      ImageButtonName$  = FastMid(ExpressionUnderCursor$, PosInText, pf - PosInText)      ProcedureReturn ImageButtonName$    EndIf  EndIfEndProcedure;Procedure ClickOverREGadget(Button)  ;  ; Link handling (underlined parts of the text or image-buttons)  ; in the Gadgets of different panels.  ;  ; This procedure requires the global variable PureBasicProgAddr$ to be declared  ; and contain the address of the PureBasic.exe executable.  ; The procedure UpDatePureBasicExeAdr() should have handled this.  ; PBBListOfFiles$ should have been declared and contain the list of files linked  ; to the main file. CompleteListProc() should have handled this.  ; The 'ElementsList()' should be completed. SetAllListsOfAllElements()  ; should have handled this.  ;  ;  Static LastClickPos ; Stores the position of the last click, to avoid repeating the same action.  ;  Shared NextOrPreviewAsked ; For navigation in the search history.  Shared ExactValueSearch   ; To trigger a search if needed.  Shared VList.VariableListings  ;  Protected StrRef$, cpos, txtrange.CHARRANGE, ExpressionUnderCursor$ ; For exploring the content of the RE_Gadget.  Protected *pTextFont.ITextFont2  Protected *pTextRange.ITextRange2  Protected PageAddr$                    ; For clicking on the name of a native PureBasic function.  Protected p, pd, pf, NoLine$           ; For clicking on a filename or a native function name.  Protected FNameWithoutPath$            ; For clicking on a line number in the "Found in..." list.  Protected ImageButtonName$             ; For clicking on an image-button.  Protected NoREGadget, pl, ElementType, PosInText, Underlined, pChar  Protected PosInList, FFile$, FPath$  ;  NoREGadget = GetREGadgetNbrFromActivePBBPanel()  ;  If NoREGadget    StrRef$ = ReplaceString(GetGadgetText(NoREGadget), #LF$, "")    ;    TOM_GetSelectionPos(NoREGadget, @txtrange.CHARRANGE)    Underlined = FindString(TOM_GetFontStyles(NoREGadget), "Underline")    cpos = txtrange\cpMin    ;    If Underlined = 0 And txtrange\cpMax - txtrange\cpMin <= 1      ; The cursor is in an ununderlined area, and the selection consists of only one character or none.      ; It's possible that the user clicked on a button.      ; Let's check that:      LastClickPos = 0      ImageButtonName$ = GetImageNameFromSelectionPos(NoREGadget)      If ImageButtonName$        If ImageButtonName$ = #PBBLeftArrowMarker$          NextOrPreviewAsked = -1        ElseIf ImageButtonName$ = #PBBRightArrowMarker$          NextOrPreviewAsked = 1        EndIf        ; Deselect the image.        TOM_SetSelectionPos(NoREGadget, txtrange\cpMin, txtrange\cpMin)        ; Navigate based on the clicked image.        WalkOverPages(NextOrPreviewAsked)      EndIf      ;    ElseIf cpos <> LastClickPos And Underlined      LastClickPos = cpos      ;      ; Find the boundaries of the underlining, left and right,      ; but stop if a carriage return (Ch(13)) is encountered,      ; on either side.      Repeat        txtrange\cpMin - 1        *pTextRange = TOM_GetTextRangeObj(NoREGadget, txtrange\cpMin, txtrange\cpMin + 1)        If *pTextRange          *pTextRange\GetChar(@pChar)          If *pTextRange\GetFont(@*pTextFont) = #S_OK            *pTextFont\GetUnderline(@pl)            *pTextFont\Release()          EndIf          *pTextRange\Release()        EndIf      Until txtrange\cpMin <= -1 Or pl = #TomNone Or pChar = #CR      txtrange\cpMin + 1      ;      Repeat        *pTextRange = TOM_GetTextRangeObj(NoREGadget, txtrange\cpMax, txtrange\cpMax + 1)        If *pTextRange          *pTextRange\GetChar(@pChar)          If *pTextRange\GetFont(@*pTextFont) = #S_OK            *pTextFont\GetUnderline(@pl)            *pTextFont\Release()            If pl <> #TomNone              txtrange\cpMax + 1            EndIf            *pTextRange\Release()          EndIf        EndIf      Until txtrange\cpMax >= Len(StrRef$) Or pl = #TomNone Or pChar = #CR      ;      TOM_SetSelectionPos(NoREGadget, txtrange\cpMin, txtrange\cpMax) ; Select the entire underlined portion.      ;      ExpressionUnderCursor$ = TOM_GetText(NoREGadget) ; This is equivalent to Mid(StrRef$,txtrange\cpMin+1,txtrange\cpMax-txtrange\cpMin).      ;      ; React to the click      ;      If ExpressionUnderCursor$        ;        SendMessage_(GadgetID(NoREGadget), #EM_SETREADONLY, #False, 0)        TOM_SetFontStyles(NoREGadget, "Underline(Wave)")        SendMessage_(GadgetID(NoREGadget), #EM_SETREADONLY, #True, 0)        ;        ElementType = GetTypeOfExpression(ExpressionUnderCursor$)        ;        If FindString(ExpressionUnderCursor$, ".") And FindString(PBBListOfFiles$, "\" + ExpressionUnderCursor$, 0)          ;          ; The click happened on a filename.          ;          NoLine$ = ""          If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FilePBBPanel            ; We are in the details of an element, or in the 'Files' pannel, and the click just happened on the filename            ; containing this element. The task is to ask the PureBasic editor to open the file            ; in question and place the cursor on the correct line.            ; Let's retrieve the line number which is usually at the end of the text line.            PosInText = FindString(StrRef$, #CR$, txtrange\cpMax)            If PosInText              PosInText - 1              While FastMid(StrRef$, PosInText, 1) = "." Or FastMid(StrRef$, PosInText, 1) = ")" : PosInText - 1 : Wend              pf = PosInText + 1              While PosInText And FindString(ListPBSep$ + #NonBreakableSpace$, FastMid(StrRef$, PosInText, 1)) = 0 : PosInText - 1 : Wend              PosInText + 1              If Val(FastMid(StrRef$, PosInText, pf - PosInText))                NoLine$ = FastMid(StrRef$, PosInText, pf - PosInText)              EndIf            EndIf          EndIf          OpenFileWithPureBasic(ExpressionUnderCursor$, NoLine$)          ;        ElseIf FindString(ExpressionUnderCursor$, ".") And FindString(PBBListOfBinaries$, "\" + ExpressionUnderCursor$, 0)          ;          ; The click happened on a binary filename.          ;          PosInList = FindString(PBBListOfBinaries$, "\" + ExpressionUnderCursor$, 0)          pf = PosInList + Len(ExpressionUnderCursor$) + 1          While PosInList > 1 And Mid(PBBListOfBinaries$, PosInList - 1, 1) <> #TAB$ And Mid(PBBListOfBinaries$, PosInList - 1, 1) <> #CR$ : PosInList - 1 : Wend          FFile$ = Mid(PBBListOfBinaries$, PosInList, pf - PosInList)          FPath$  = #DOUBLEQUOTE$ + GetPathPart(FFile$) + #DOUBLEQUOTE$          ; Open the folder containing the file:          OpenFolderIfNotOpen(FPath$)          ;        ElseIf ElementType = #PBBNativeFunction Or ElementType = #PBBBasicKeyword          ;          ; There has been a click on the name of a native PureBasic function.          ; Open the help file provided with PureBasic:          ;          TOM_SetSelectionPos(NoREGadget, 0, 0)          ;          If ElementType = #PBBNativeFunction            p = FindString(PBFunctionListLCase$, "/" + LCase(ExpressionUnderCursor$) + #CR$)            pd = ReverseFindString(PBFunctionList$, #CR$, p) + 1            pf = FindString(PBFunctionList$, #CR$, p)            PageAddr$ = Mid(PBFunctionList$, pd, pf - pd)            PageAddr$ = GetPathPart(PureBasicProgAddr$) + "PureBasic.chm::/" + PageAddr$ + ".html"            RunProgram("hh.exe", #DOUBLEQUOTE$ + PageAddr$ + #DOUBLEQUOTE$, GetPathPart(PageAddr$))          Else            RunProgram("https://www.google.com/search?q=purebasic+" + ExpressionUnderCursor$)          EndIf          LastClickPos = 0          ;        ElseIf ExpressionUnderCursor$ = GetTextFromCatalogPB("MoreInfo")          ;          ; There has been a click on "More info...".          ;          AlertInPBBWindow(GetTextFromCatalogPB("HelpClickInstruction"))                  ElseIf ExpressionUnderCursor$ = GetTextFromCatalogPB("SeeVariablesList")          ;          ; There has been a click on "View full variables list".          ;          AlertInPBBWindow(VList\CompleteList, VList\ProcedureName + ": variables", 1, 0, 1, 500, "100,250")          ;        ElseIf GetActivePBBPanel() = #FoundInFilesPBBPanel And Val(ExpressionUnderCursor$) > 0          ;          ; Click on a line number in the "Found in..." list          ;          NoLine$ = ExpressionUnderCursor$          ;          ; Retrieve the name of the element that appears before.          pf = ReverseFindString(StrRef$, #NonBreakableSpace$ + #CR$, txtrange\cpMin) ; The character 160 (non-breaking space) was placed                                                                     ; at the end of the file name by 'CompleteFoundInFiles'                                                                     ; to serve as a reference point.          PosInText = pf          FastFindPrecReturn(StrRef$, PosInText) ; Move back to the beginning of the line.          PosInText + 1               FNameWithoutPath$ = Mid(StrRef$, PosInText, pf - PosInText)          OpenFileWithPureBasic(FNameWithoutPath$, NoLine$)          ;        ElseIf GetActivePBBPanel() >= #ProcPBBPanel Or GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel          ;          ; The click occurred on the name of an element, in a list,          ; in the details panel or in the "Found in..." panel.          ;          If Button = #WM_LBUTTONUP            ; Left click:            ; Display the "Details" panel:            SetActivePBBPanel(#DetailPBBPanel)          Else            ; Right click:            ; Display the "Found in..." panel:            SetActivePBBPanel(#FoundInFilesPBBPanel)          EndIf          ;          ; Display the clicked name in the search field          SetGadgetText(GPBBGadgets\SearchedExpression_gadget, ExpressionUnderCursor$)          ;          ; Trigger a search to complete what is displayed in "Details":          ExactValueSearch = #DoProgrammedSearch          ;        Else          ;          ; If none of the previous cases have occurred...          ;          ; (I don't know what to do for now).          ;        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure ResizePBBGadgets()  ;  ; Sizing and resizing of the gadgets in the main window.  ;  ; Calculation variables for resizing:  Protected MainPanelGadgetWidth, MainPanelGadgetHeight, ResultInsideHeightDecal, ResultInsideWidthDecal  Protected REGadgetsHeight, REGadgetsWidth, PBarWidth, TypeOfElement  ;  ; Resize the gadgets based on the window size.  ;  ; This procedure is only called in two situations: when the window is created,  ; and during a #PB_Event_SizeWindow event.  ;  ; The 'GPBBGadgets' structure that contains all the gadget numbers is a global variable.  ;  Protected BWidth = 70  Protected ExternalMargin = 6  Protected SpaceInterFields = 4  ResizeGadget(GPBBGadgets\Adr_gadget, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - GadgetX(GPBBGadgets\Adr_gadget) - BWidth - ExternalMargin - SpaceInterFields, #PB_Ignore)  ResizeGadget(GPBBGadgets\BChangeAdresse, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)    ResizeGadget(GPBBGadgets\SearchedExpression_gadget, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - GadgetX(GPBBGadgets\SearchedExpression_gadget) - BWidth - ExternalMargin - SpaceInterFields, #PB_Ignore)  ResizeGadget(GPBBGadgets\BSearchExpression, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)  ;  ResizeGadget(GPBBGadgets\GLine, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - ExternalMargin * 2 - 2, #PB_Ignore)  ;  MainPanelGadgetHeight = (WindowHeight(GPBBGadgets\PBBWindow) - GadgetY(GPBBGadgets\MainPanelGadget) - 27)  MainPanelGadgetWidth = (WindowWidth(GPBBGadgets\PBBWindow) - 2 * ExternalMargin + 1)  ResizeGadget(GPBBGadgets\MainPanelGadget, #PB_Ignore, #PB_Ignore, MainPanelGadgetWidth, MainPanelGadgetHeight)  ResizeGadget(GPBBGadgets\ListsPGadget, #PB_Ignore, #PB_Ignore, MainPanelGadgetWidth - 7, MainPanelGadgetHeight - 29)  ;  PBarWidth = WindowWidth(GPBBGadgets\PBBWindow) / 8  ResizeGadget(GPBBGadgets\EProgressBar, WindowWidth(GPBBGadgets\PBBWindow) - PBarWidth - ExternalMargin - 1, #PB_Ignore, PBarWidth, #PB_Ignore)  ResizeGadget(GPBBGadgets\TProgressBar, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin - 36, #PB_Ignore, #PB_Ignore, #PB_Ignore)  ;  ResizeGadget(GPBBGadgets\BStats, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)  ResizeGadget(GPBBGadgets\BRefresh, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin - 21 - SpaceInterFields, #PB_Ignore, #PB_Ignore, #PB_Ignore)  ;  ResultInsideHeightDecal = 30  ResultInsideWidthDecal = 8  REGadgetsHeight = MainPanelGadgetHeight - ResultInsideHeightDecal  REGadgetsWidth = MainPanelGadgetWidth - ResultInsideWidthDecal  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    If TypeOfElement = #ProcPBBPanel      REGadgetsWidth - 7      REGadgetsHeight - 29    EndIf    If IsGadget(NoREGadgetOfPBBPanel(TypeOfElement))      ResizeGadget(NoREGadgetOfPBBPanel(TypeOfElement), #PB_Ignore, #PB_Ignore, REGadgetsWidth, REGadgetsHeight)    EndIf  Next  ;  ReSizeREMenu()  ;  ResizeGadget(GPBBGadgets\BStick, #PB_Ignore, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BAbout, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - GadgetWidth(GPBBGadgets\BAbout) - ExternalMargin - SpaceInterFields, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BLanguage, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - GadgetWidth(GPBBGadgets\BAbout) - GadgetWidth(GPBBGadgets\BLanguage) - ExternalMargin - SpaceInterFields * 2, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BQuit, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - ExternalMargin, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ;  ; Redraw the WhiteBox with the new window dimensions:  GPBBGadgets\IWhiteOver = WhiteBoxOverWindow(GPBBGadgets\PBBWindow)  ;EndProcedure;Macro PBBUpdateMainFile(NewSFile = "", Refresh = 0)  ;  ; This macro is called by OpenPBBMainWindow(), ManagePipeMessages(), and PBBrowserMainProc()  ; It updates the main file name and (re)starts deep exploration if necessary.  ;  Shared BackgroundTasksCompletion  Shared ExactValueSearch, SearchNavigationIndex  ;  mPBBListOfFiles$ = PBBListOfFiles$  ;  If NewSFile = ""    NewSFile = PBBFicPrincipalPB$  EndIf  ;  NewSFile = SetListOfFiles(NewSFile, #ShowCompletionWindow)  ;  If mPBBListOfFiles$ <> PBBListOfFiles$    ClearList(ListOfSearchs())    SearchNavigationIndex = 0  EndIf  ;  If NewSFile = "ListOfFiles error"    NewSFile = ""    PBBListOfFiles$ = ""    SetGadgetText(GPBBGadgets\SearchedExpression_gadget, "")  EndIf  ;  If mPBBListOfFiles$ <> PBBListOfFiles$ Or Refresh    ; The file list has been modified, or something requests an update (if 'Refresh' > 0).    ; Then, update:    If PBBFicPrincipalPB$ <> NewSFile      PBBFicPrincipalPB$ = NewSFile    EndIf    ;    If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ is a global variable.      WritePreferenceString("FicPrincipalPB", PBBFicPrincipalPB$)      ClosePreferences()    EndIf    ;    FillFileREGadget()    ;    If FileSize(PBBFicPrincipalPB$) > 2      BOText$ = GetTextFromCatalogPB("Change")    Else      BOText$ = GetTextFromCatalogPB("Open")    EndIf    SetGadgetText(GPBBGadgets\BChangeAdresse, BOText$)    ;    If FileSize(PBBFicPrincipalPB$) > 2      BackgroundTasksCompletion = #BackgroundTasksMustRestart ; This will trigger the (re)start of element's exploration.    EndIf  Else    ; Some files may have been modified.    ; Update the memory.    UpdateAllFilesInMemory()  EndIf  ;EndMacro;#PBBMenu_CommandOffset = 200 ; Command offset value in the menus.                             ; This value is intended to prevent overlap between                             ; the shortcuts assigned directly in the program                             ; and those chosen by the user for each                             ; of the tools..;Procedure UpdatePBBMenus()  ;  ; Builds the hamburger menu for the Gadgets in the list managed by PBBrowserMainProc()  ;  If IsMenu(GPBBGadgets\REMenu)    FreeMenu(GPBBGadgets\REMenu)  EndIf  GPBBGadgets\REMenu = CreatePopupMenu(#PB_Any)  MenuItem(#REM_ZoomIn,       GetTextFromCatalogPB("ZoomIn")       + #TAB$ + "CTRL + '+'")  MenuItem(#REM_ZoomOut,      GetTextFromCatalogPB("ZoomOut")      + #TAB$ + "CTRL + '-'")  MenuItem(#REM_ZoomReset,    GetTextFromCatalogPB("ZoomReset")    + #TAB$ + "CTRL + 0")  MenuBar()  MenuItem(#REM_FindInPannel, GetTextFromCatalogPB("FindInPannel") + #TAB$ + "CTRL + F")  MenuBar()  MenuItem(#REM_CopyAll,      GetTextFromCatalogPB("CopyAll"))  MenuItem(#REM_SaveAsText,   GetTextFromCatalogPB("SaveAsText")   + #TAB$ + "CTRL + S")  MenuItem(#REM_SaveAsRTF,    GetTextFromCatalogPB("SaveAsRTF")    + #TAB$ + "CTRL + R")  ;  ApplyThemesToMenu(GPBBGadgets\REMenu)  ;  ; Builds the main window menu managed by PBBrowserMainProc()  ;  Protected MenuLine$  ;  If IsMenu(GPBBGadgets\Menu)    FreeMenu(GPBBGadgets\Menu)  EndIf  GPBBGadgets\Menu = CreatePopupMenu(#PB_Any)  MenuItem(#PBBMenu_THAT, GetTextFromCatalogPB("OpenTHATWindow") + #TAB$ + "CTRL + I")  MenuBar()  MenuItem(#PBBMenu_Prefs, GetTextFromCatalogPB("Preferences"))  MenuBar()  ForEach CommandList()    If CommandList()\CommandDontShow = 0      MenuLine$ = GetTranslatedCommandName(CommandList()\CommandNo)      If CommandList()\CommandShortCut        MenuLine$ + #TAB$ + ComputeShortcutString(CommandList()\CommandShortCut)      EndIf      MenuItem(CommandList()\CommandNo + #PBBMenu_CommandOffset, MenuLine$)    EndIf    If CommandList()\CommandShortCut      AddKeyboardShortcut(GPBBGadgets\PBBWindow, CommandList()\CommandShortCut, CommandList()\CommandNo + #PBBMenu_CommandOffset)    EndIf  Next  ApplyThemesToMenu(GPBBGadgets\Menu)EndProcedure;Procedure SetPBBGadgetsTitles()  ;   Shared PBBCustomLinks$ ; List of clickable links in the displayed texts.    PBBCustomLinks$ = GetTextFromCatalogPB("MoreInfo") + #CR$ + GetTextFromCatalogPB("SeeVariablesList") + #CR$  ;  Protected txa$, Panel  ;  SetGadgetText(GPBBGadgets\AdrTitle, GetTextFromCatalogPB("MainFileLabel"))  SetGadgetText(GPBBGadgets\BChangeAdresse, GetTextFromCatalogPB("Open"))  SetGadgetText(GPBBGadgets\SearchedExpressionTitle, GetTextFromCatalogPB("Expression"))  SetGadgetText(GPBBGadgets\BSearchExpression, GetTextFromCatalogPB("Search"))  txa$ = GetTextFromCatalogPB("SearchInstructions")  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget, txa$)  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression, txa$)  SetGadgetText(GPBBGadgets\TProgressBar, GetTextFromCatalogPB("Exploration"))  SetGadgetText(GPBBGadgets\BStats, GetTextFromCatalogPB("Statistics"))  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BRefresh)  AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BRefresh, GetTextFromCatalogPB("RefreshEx"))  SetGadgetItemText(NoGadgetPBBPanel(#FilePBBPanel), NoPBBPanel(#FilePBBPanel), GetTextFromCatalogPB(PBBPanelNames$(#FilePBBPanel)))  SetGadgetItemText(NoGadgetPBBPanel(#ListPBBPanel), NoPBBPanel(#ListPBBPanel), GetTextFromCatalogPB(PBBPanelNames$(#ListPBBPanel)))  For Panel = #ProcPBBPanel To #EndEnumPBBPanels - 1    SetGadgetItemText(GPBBGadgets\ListsPGadget, NoPBBPanel(Panel), GetTextFromCatalogPB(PBBPanelNames$(Panel)))  Next  SetGadgetItemText(NoGadgetPBBPanel(#DetailPBBPanel), NoPBBPanel(#DetailPBBPanel), GetTextFromCatalogPB(PBBPanelNames$(#DetailPBBPanel)))  SetGadgetItemText(NoGadgetPBBPanel(#FoundInFilesPBBPanel), NoPBBPanel(#FoundInFilesPBBPanel), GetTextFromCatalogPB(PBBPanelNames$(#FoundInFilesPBBPanel)))    SetGadgetText(GPBBGadgets\BStick, GetTextFromCatalogPB("AlwaysOnTop"));     If OpenPreferencesWithPatience(PBBrowserPrefile$);       PBBLanguageFolder$ = ReadPreferenceString ("PBBLanguageFolder", "");       ClosePreferences();       PBBLanguageFolder$ = ReplaceString(PBBLanguageFolder$, GetParentFolder(PBBLanguageFolder$), "");       PBBLanguageFolder$ = Trim(ReplaceString(PBBLanguageFolder$, "\", ""));       SetGadgetText(GPBBGadgets\BLanguage, PBBLanguageFolder$);     EndIf  SetGadgetText(GPBBGadgets\BAbout, GetTextFromCatalogPB("About"))  SetGadgetText(GPBBGadgets\BQuit , GetTextFromCatalogPB("Quit"))    ;  UpdatePBBMenus()  ;EndProcedure;Procedure ColorizeAndSetFontsForPBBGadgets()  ;  Protected *GadgetAdress  ;  ; Colorize gadgets  SetWindowColor(GPBBGadgets\PBBWindow, InterfaceColorPresets()\BackGroundColor)  *GadgetAdress = @GPBBGadgets\AdrTitle  Repeat    If PeekI(*GadgetAdress) = GPBBGadgets\AdrTitle Or PeekI(*GadgetAdress) = GPBBGadgets\SearchedExpressionTitle      SetGadgetColorEx(PeekI(*GadgetAdress), #PB_Gadget_FrontColor, GetPBBNumParameter("PBBTitleColor"))    Else      SetGadgetColorEx(PeekI(*GadgetAdress), #PB_Gadget_FrontColor, InterfaceColorPresets()\TextColor, 1)    EndIf    ;    SetGadgetColorEx(PeekI(*GadgetAdress), #PB_Gadget_BackColor , InterfaceColorPresets()\BackGroundColor, 1)    ;    If PeekI(*GadgetAdress) = GPBBGadgets\BRefresh      SetGadgetFont(PeekI(*GadgetAdress), PBBBRefreshFont)    ElseIf PeekI(*GadgetAdress) = GPBBGadgets\AdrTitle Or PeekI(*GadgetAdress) = GPBBGadgets\SearchedExpressionTitle      SetGadgetFont(PeekI(*GadgetAdress), PBBTitleFont)    Else      SetGadgetFont(PeekI(*GadgetAdress), PBBAllGadgetsFont)    EndIf    If PeekI(*GadgetAdress) = GPBBGadgets\GLine      RepaintCanvasSeparator(GPBBGadgets\GLine, CalculateBorderColor(InterfaceColorPresets()\TextColor, InterfaceColorPresets()\BackGroundColor))    EndIf    *GadgetAdress + SizeOf(Integer)  Until *GadgetAdress > @GPBBGadgets\BREMenu  ;      SetGadgetFont(GPBBGadgets\TProgressBar, PBBProgressLegendFont)  SetGadgetColorEx(GPBBGadgets\TProgressBar, #PB_Gadget_FrontColor, GetPBBNumParameter("PBBTitleColor"))  SetGadgetColorEx(GPBBGadgets\EProgressBar, #PB_Gadget_FrontColor, GetPBBNumParameter("PBBTitleColor"))EndProcedure;Procedure OpenPBBMainWindow(WSticky)  ;  ; Opens the main window and creates its gadgets.  ;  Protected VPos, txa$, Panel  ;  GPBBGadgets\PBBWindow = OpenWindowFromPrefCoordonnates(PBBrowserPrefile$, "PureBasic Browser " + PBB_NumVersion$, 430, 400, #PB_Window_Invisible | #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar)  ;  If IsWindow(GPBBGadgets\PBBWindow)    ;    GetColorThemesFromPreferences(PBBrowserPrefile$)    SetWindowColor(GPBBGadgets\PBBWindow, InterfaceColorPresets()\BackGroundColor)    ApplyDarkModeToWindow(GPBBGadgets\PBBWindow)    ;    WindowBounds(GPBBGadgets\PBBWindow, 430, 400, #PB_Ignore, #PB_Ignore)    StickyWindow(GPBBGadgets\PBBWindow, WSticky)    BindEvent(#PB_Event_SizeWindow, @ResizePBBGadgets(), GPBBGadgets\PBBWindow)    ;________________________________________________________    ;    ;     Creation of the gadgets in the main window    ;________________________________________________________    ;    ; In the following, many gadget dimensions are simply set to '1',    ; because the ResizePBBGadgets() procedure will resize them anyway.    ;    Protected ExternalMargin = 6    Protected UpMargin = 5    Protected TWidth = 115    ;    GPBBGadgets\AdrTitle = TextGadget(#PB_Any, ExternalMargin, UpMargin + 2, TWidth, 18, "")        GPBBGadgets\Adr_gadget = StringGadget(#PB_Any, TWidth + 1 + ExternalMargin, UpMargin + 1, 1, 20, "", #PB_Editor_ReadOnly)        GPBBGadgets\BChangeAdresse = ButtonGadget(#PB_Any, 1, UpMargin, 1, 22, "")        ;    VPos = UpMargin + 20 + 5    ;    GPBBGadgets\SearchedExpressionTitle = TextGadget(#PB_Any, ExternalMargin, VPos + 2, TWidth, 20, "")            GPBBGadgets\SearchedExpression_gadget = StringGadget(#PB_Any, TWidth + 1 + ExternalMargin, VPos + 1, 1, 20, "")        GPBBGadgets\BSearchExpression = ButtonGadget(#PB_Any, 1, VPos, 1, 22, "")        GPBBGadgets\Tooltip = InitBalloonToolTip(GPBBGadgets\PBBWindow)        AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget, txa$)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression, txa$)    ;    VPos + 20 + 5    ;    ; Horizontal line of separation:    GPBBGadgets\GLine = CanvasGadget(#PB_Any, ExternalMargin, VPos, 1, 1)    ;    VPos + 4    ;    GPBBGadgets\TProgressBar = TextGadget(#PB_Any, 1, VPos - 1, 105, 15, "", #PB_Text_Right)        GPBBGadgets\EProgressBar = ProgressBarGadget(#PB_Any, 1, VPos + 14, 1, 8, 0, 100, #PB_ProgressBar_Smooth)    ;    GPBBGadgets\BStats = ButtonGadget(#PB_Any, 1, VPos, 70, 22, "")    ;    GPBBGadgets\BRefresh = ButtonGadget(#PB_Any, 1, VPos, 22, 22, #RefreshSymbol$) ; "⟳"    HideGadget(GPBBGadgets\BRefresh, #True)    ;    ; The creation of the panels for the PanelGadgets uses the arrays created in PBBrowserDeclarations.pb.    ; For each panel:    ; PBBPanelNames$() contains the name of the panel. This array has been updated in PBBrowserDeclarations.pb.    ; NoPBBPanel() will contain the panel number in its PanelGadget.    ;   For all panels of 'MainPanelGadget', we have NoPBBPanel(x) = x, but for the panels    ;   of 'ListsPGadget', for example, NoPBBPanel(#ProcPBBPanel) = 0, even though #ProcPBBPanel = 4.    ; NoGadgetPBBPanel() will contain the gadget number of the PanelGadget containing the panel,    ;   that is, 'MainPanelGadget' or 'ListsPGadget'.    ; NoREGadgetOfPBBPanel() will contain the number of the RichEdit gadget (EditorGadget) that will be created in the panel    ; TypeElementOfPBBPanel() in the case where the panel is a list panel of elements (procedures, structures, etc.),    ;   this array contains the corresponding element type (#PBBProcedure, #PBBStructure, #PBBMacro, etc.)    ; TypeElementOfPBBPanel() has been initialized in PBBrowserDeclarations.pb.    ;    GPBBGadgets\MainPanelGadget = PanelGadget(#PB_Any, ExternalMargin, Vpos, 1, 1)      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoGadgetPBBPanel(#FilePBBPanel) = GPBBGadgets\MainPanelGadget      NoPBBPanel(#FilePBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1        NoREGadgetOfPBBPanel(#FilePBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1)        SetREGadgetParam(NoREGadgetOfPBBPanel(#FilePBBPanel))      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#ListPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#ListPBBPanel) = GPBBGadgets\MainPanelGadget      GPBBGadgets\ListsPGadget = PanelGadget(#PB_Any, 0, 0, 1, 1)        For Panel = #ProcPBBPanel To #EndEnumPBBPanels - 1          AddGadgetItem(GPBBGadgets\ListsPGadget, -1, "")          NoGadgetPBBPanel(Panel) = GPBBGadgets\ListsPGadget          NoPBBPanel(Panel) = CountGadgetItems(GPBBGadgets\ListsPGadget) - 1          NoREGadgetOfPBBPanel(Panel) = EditorGadget(#PB_Any, 0, 0, 1, 1)          SetREGadgetParam(NoREGadgetOfPBBPanel(Panel))        Next        CloseGadgetList()      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#DetailPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#DetailPBBPanel) = GPBBGadgets\MainPanelGadget        NoREGadgetOfPBBPanel(#DetailPBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1)        SetREGadgetParam(NoREGadgetOfPBBPanel(#DetailPBBPanel))      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#FoundInFilesPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#FoundInFilesPBBPanel) = GPBBGadgets\MainPanelGadget        NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1)        SetREGadgetParam(NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel))      CloseGadgetList()    ;    GPBBGadgets\BREMenu = ButtonGadget(#PB_Any, 1, 1, 20, 19, #HamburgerMenuSymbol$) ; "☰"    SetWindowPos_(GadgetID(GPBBGadgets\BREMenu), #HWND_TOP, 0, 0, 0, 0, #SWP_NOMOVE | #SWP_NOSIZE)    ;    GPBBGadgets\BStick = CheckBoxGadget(#PB_Any, ExternalMargin, 1, 100, 22, "")    SetGadgetState(GPBBGadgets\BStick, WSticky)    GPBBGadgets\BLanguage = ButtonGadget(#PB_Any, ExternalMargin + 120 + 5, 1, 70, 22, "Language")        GPBBGadgets\BAbout = ButtonGadget(#PB_Any, 1, 1, 150, 22, "")    SetGadgetFont(GPBBGadgets\BAbout, PBBAllGadgetsFont)    GPBBGadgets\BQuit = ButtonGadget(#PB_Any, 1, 1, 60, 22, "")        ;    ResizePBBGadgets()    ;    ; Main window shortcuts.    ; The constants corresponding to these shortcuts are defined in 'PBBrowserDeclarations.pb'.    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Return,                 #PBBMenu_Return)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Escape,                 #PBBMenu_Escape)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Tab,                    #PBBMenu_NextPanel)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Tab | #PB_Shortcut_Shift, #PBBMenu_PreviousPanel)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Up,                     #PBBMenu_Up)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Down,                   #PBBMenu_Down)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_PageUp,                 #PBBMenu_PageUp)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_PageDown,               #PBBMenu_PageDown)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Right,                  #PBBMenu_NextPage)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Left,                   #PBBMenu_PreviousPage)    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Q, #PBBMenu_Find)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_I, #PBBMenu_THAT)    ;    ; Hamburger menu shortcuts.    ; The constants corresponding to this menu are defined in 'PBBrowserDeclarations.pb'.    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Add,      #REM_ZoomIn)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #VK_OEM_PLUS,          #REM_ZoomIn)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Subtract, #REM_ZoomOut)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #VK_OEM_MINUS,         #REM_ZoomOut)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_0,        #REM_ZoomReset)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_F,        #REM_FindInPannel)    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_S,        #REM_SaveAsText)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_R,        #REM_SaveAsRTF)    ;    ; Create a semi-transparent white rectangle that will overlay the content of the window    ; when we want to show that the window is inactive.    GPBBGadgets\IWhiteOver = WhiteBoxOverWindow(GPBBGadgets\PBBWindow)    ;    SetPBBGadgetsTitles()    ;    ColorizeAndSetFontsForPBBGadgets()    ;    ; The window was invisible until now, because we created it with #PB_Window_Invisible.    ; We make it visible now.    HideWindow(GPBBGadgets\PBBWindow, #False)    ;    ProcedureReturn #True  EndIfEndProcedure;Procedure ManagePBBBackgroundTasks()  ;  ; Background task management  ;  ; This procedure is called at each cycle of the main loop of PBBrowserMainProc.  ; Its role is to manage background tasks that involve exploring files listed by 'SetListOfFiles()'.  ; This exploration will be interrupted every 200 milliseconds, to resume in the next cycle,  ; effectively sharing available time between user action management (in the main loop) and exploration tasks (in this procedure),  ; as if the application were running in multi-threaded mode.  ; So, why not use multi-threading?  ; • Because the 'multi-thread safe' option significantly slows down string processing,  ;   which is crucial for performance in this type of task.  ; • Because multi-threading can give users the impression that the machine is lagging,  ;   especially when background tasks are power-hungry (as is the case here).  ;  ; This procedure will distribute machine time by attempting to optimize it:  ; • As long as the user is doing nothing, nearly all machine time is allocated to executing background tasks.  ;   Every 200 milliseconds, a simple WindowEvent() is performed to check if something happens, and if not,  ;   the background tasks resume.  ; • As soon as the user does something (such as moving the mouse), the entire machine power is allocated to them  ;   by suspending the execution of background tasks for 50 ms. This way, the user never feels that their machine is slow.  ;  ; The result obtained by this method is satisfactory, but it imposes significant constraints  ; on background task programming:  ; 1- No process should take longer than 200 ms, to prevent the user from feeling like their machine is frozen.  ;    This requires splitting tasks into very small segments and regularly checking the elapsed time,  ;    to interrupt the task when the time reaches 200 ms.  ; 2- When resuming task execution, we must know exactly where we stopped last time, so we can pick up from where we left off.  ;    This requires remembering a lot of things, and setting up many 'Static' or 'Global' variables to track progress.  ;  ; The more complex the background task is, the heavier these constraints might seem.  ; But in reality, the same methods are always applied to handle them:  ; 1- In each execution loop, you need to check the time and exit the loop when it's time to do so.  ; 2- Just after exiting the loop, you need to remember that the work isn't necessarily done and that the execution stage must be saved.  ; 3- Before entering the loop, you need to always assume that it's not the first time you're entering it and that some work might already have been done.  ;    You just need to have the right Static or Global variables to remind you of your current state.  ;  ; Nevertheless, the implementation of these methods has produced a result that might seem complex  ; to the programmer entering this code for the first time, as some background tasks are really heavy  ; and had to be broken down into a multitude of fragments organized hierarchically, to adhere to the constraints mentioned above.  ;  ; To understand the adopted organization, imagine that 'ManagePBBBackgroundTasks()'  ; explores the leaves of a tree one by one, climbing along the branches and their twigs alternately.  ; Once a leaf is explored, it moves on to the next leaf. Once a twig is explored, it moves on to the next twig.  ; Once a branch is explored, it moves on to the next branch.  ;  ; The two main branches are:  ; • 'SetAllListsOfAllElements()' which creates an inventory of all the 'elements' composing the code:  ;   Procedures, Macros, Structures, Enumerations, Constants, etc.  ;   - This first branch repeatedly calls 'SetOneListOfAllElements()'.  ;       - 'SetOneListOfAllElements()' repeatedly calls 'CompleteListOfAllElements()'.  ;           - 'CompleteListOfAllElements()' explores the files one by one and piece by piece.  ; • 'SetUsageOfElements()' relies on the previously established inventory to determine  ;   which elements are actually used by the main program.  ;   - This branch repeatedly calls FindElementAndUpdateFiliation().  ;  ; The results of these two types of exploration are stored in the ElementsList().  ;  ; Unused elements will be displayed in gray.  ;  Shared BackgroundTasksCompletion ; Indicates the progress of exploration.                                   ; This value is initialized at program startup                                   ; or in the Macro PBBUpdateMainFile, when the user                                   ; changes the main file. It is updated in the following                                   ; as the explorations progress.  ;  ; When BackgroundTasksCompletion = #BackgroundTasksCompleted, all background tasks are completed.  ; It is set to '#BackgroundTasksUncompleted' while they are ongoing,  ; or '#BackgroundTasksHavePriority' if the user, by their action, triggers deep exploration as a priority.  ; When the user changes the main file, BackgroundTasksCompletion = '#BackgroundTasksMustRestart'.    ;  Shared RefreshEPanel             ; When this variable is different from #False, it                                   ; triggers a refresh of the display for certain panels.                                   ; This procedure will set this variable to #True, once per second,                                   ; during the deep exploration phase.    Shared PBBWaitingGadget          ; May contain the number of a gadget when a waiting window                                   ; has been opened by ManageWaitingWindow(). This gives this variable                                   ; the role of an indicator: if it is different from zero,                                   ; it means a waiting window is open.  ;  ;  Shared PBB_LastEventTime ; This timer holds the time of the last user event (such as mouse movement).  ;  Shared ExactValueSearch  ; This variable tells PBBrowserMainProc to restart a search.                           ;      In this case, it will refresh the display of the 'Details' and 'Found in...' panels.  ;  Shared StatReport$ ; Will contain statistics about the exploration and the code.  Shared PBBRichEditMessage ; Current message of the RichEdit Gadget.  Shared ExplorationStep.f ; For calculating the progress of the exploration.  ;  ; Timers  ;  Static LastTimeForBackgroundTasksEnding ; Time of the last interruption of the background tasks.  Static StartTimeForBackgroundTasks      ; Time of the last start of the background tasks.  Static LastEPanelRefreshTime            ; Time of the last time RefreshPanel was set to #True.  Static TotOutTime                       ; Total time elapsed since the beginning of the explorations.  ;  Static Reset  ;  Protected SALParam, TypeOfElement, Result  Protected ExplorationProgress ; For calculating the progress of the exploration.  ;  Protected EventID ; Return value  ;  If FileSize(PBBFicPrincipalPB$) < 1 Or PBBListOfFiles$ = ""    BackgroundTasksCompletion = #BackgroundTasksCompleted    HideGadget(GPBBGadgets\EProgressBar, #True)    HideGadget(GPBBGadgets\TProgressBar, #True)    HideGadget(GPBBGadgets\BStats, #True)    HideGadget(GPBBGadgets\BRefresh, #True)  EndIf  ;  ; *****************************************************************  ;                  Suspension of background tasks  ;  ; The following is intended to take control of the background tasks  ; when the user is active in the application.  ; We will filter events to retain only those triggered by the user's actions  ; and ignore those caused by the update of the EProgressBar.  ;  ;  If BackgroundTasksCompletion <> #BackgroundTasksCompleted    ;    ; As long as there are background tasks left to process, we examine the window events    ; in a loop, without necessarily waiting for an event to occur,    ; meaning we use 'WindowEvent()' and not 'WaitWindowEvent()'.    ; If no event has occurred, we immediately return to background task processing.    ; This will consume most of the computer's power,    ; but we need this power, and it will only last until the file exploration is completed.    EventID = WindowEvent()    ;    ; Only consider application events when the waiting window is not displayed,    ; because if it is displayed, it means the user requested that the deep exploration be completed with priority:    If PBBWaitingGadget = 0      If PBBRichEditMessage ; PBBRichEditCallback() detected an event in a panel.        PBB_LastEventTime = ElapsedMilliseconds()      ElseIf EventID And EventGadget() <> GPBBGadgets\EProgressBar And EventGadget() <> GPBBGadgets\TProgressBar        If EventType() Or (EventID & #WM_MOUSEMOVE) Or EventID = #PB_Event_Menu          ;          ; #WM_TIMER, 280 (an unidentified event) and 15 (another unidentified event)          ; are triggered by the refresh of the ProgressBar.          ; There is no need to handle these events urgently.          ; Don't suspend background tasks when they occur.          If EventID <> #WM_TIMER And EventID <> 280 And EventID <> 15            PBB_LastEventTime = ElapsedMilliseconds()            ; Updating 'PBB_LastEventTime' will suspend the execution            ; of background tasks for 50 milliseconds, allowing us to remain            ; attentive to what the user is doing and react as quickly as possible.          EndIf        EndIf      EndIf    EndIf    ;    ; *****************************************************************    ;    ;                   Managing background tasks    ;    If (ElapsedMilliseconds() - PBB_LastEventTime) > 20 Or BackgroundTasksCompletion = #BackgroundTasksHavePriority      ; If the application has had no user events for 20 milliseconds,      ; execute the background tasks.      ;      If BackgroundTasksCompletion = #BackgroundTasksMustRestart        ;        ; The background tasks need to be done or restarted.        ;        ; Activate the EProgressBar to show the progress of the background tasks:        HideGadget(GPBBGadgets\EProgressBar, #False)        HideGadget(GPBBGadgets\TProgressBar, #False)        HideGadget(GPBBGadgets\BStats, #True)        HideGadget(GPBBGadgets\BRefresh, #True)        ;        ; (Re)initialize the variables.        ;        ;        ; Initialize the counter to measure the time spent outside background tasks.        LastTimeForBackgroundTasksEnding = ElapsedMilliseconds()        ; StartTimeForBackgroundTasks will measure the time spent executing        ; the background tasks. We initialize it as well.        StartTimeForBackgroundTasks = ElapsedMilliseconds()        ;        ; Variable for progress bar calculation:        ExplorationStep = 0        ;        ; Indicate that the lists need to be recalculated:        ;        For TypeOfElement = #PBBProcedure To #EndEnumPBBElementTypes - 1          ListCompletionAll(TypeOfElement)  = #ListCompletion_Undone          ListCompletionUsed(TypeOfElement) = #ListCompletion_Undone        Next        ;        ClearList(ElementsList())        ;        EraseAllCodeInMemory()        Reset = #True        ;        ; Finally, update LastEPanelRefreshTime which is used to refresh        ; certain panels as results from the deep exploration progress.        LastEPanelRefreshTime = ElapsedMilliseconds()        ;        BackgroundTasksCompletion = #BackgroundTasksUncompleted        ;        ExactValueSearch = #DoProgrammedSearch       ; We need to refresh the display of certain panels.        ;        TotOutTime = 0        ;      EndIf      ; Deduct from StartTimeForBackgroundTasks the time not spent on background tasks.      StartTimeForBackgroundTasks + ElapsedMilliseconds() - LastTimeForBackgroundTasksEnding      TotOutTime + ElapsedMilliseconds() - LastTimeForBackgroundTasksEnding      ; This counter now precisely measures the time spent on background tasks since they started.      ;      If BackgroundTasksCompletion = #BackgroundTasksHavePriority        ; The user requested to finish the deep exploration.        SALParam = #ShowCompletionWindow        ; By passing the parameter #ShowCompletionWindow to the exploration tasks, trigger        ; the display of a waiting window.      Else        SALParam = #WorkInBackGround      EndIf      ;      ; Testing 'SetAllListsOfAllElements()' triggers the first phase of exploration      ; (listing all elements).      Result = SetAllListsOfAllElements(SALParam)      If Result = #Completion_Completed        ;        ; The first phase of exploration is complete.        ; All element lists have been completed.        ; The next phase, which I call "Deep Exploration",        ; will determine which elements are used by the main file.        ;        If SetUsageOfElements(SALParam, Reset) = #Completion_Uncomplete          If ElapsedMilliseconds() - LastEPanelRefreshTime > 1000            RefreshEPanel = #True ; For result panels.            ; When a panel containing a list of elements is displayed,            ; RefreshEPanel will trigger, once a second, an update of this panel.            ; Thus, the user will be able to see partial results            ; of the deep exploration as it progresses.            LastEPanelRefreshTime = ElapsedMilliseconds()          EndIf        Else          ;          ; The deep exploration is complete.          ;          StatReport$ = GetTextFromCatalogPB("ExploringDuration")  + " : " + FormatNumber(ElapsedMilliseconds() - StartTimeForBackgroundTasks, 0, ".", ",") + " ms." + #CR$          StatReport$ + GetTextFromCatalogPB("EventManagement")    + " : " + FormatNumber(TotOutTime, 0, ".", ",") + " ms." + #CR$          StatReport$ + GetTextFromCatalogPB("TotalExploringTime") + " : " + FormatNumber(ElapsedMilliseconds() - StartTimeForBackgroundTasks + TotOutTime, 0, ".", ",") + " ms." + #CR$ + #CR$          ;          ;          BackgroundTasksCompletion = #BackgroundTasksCompleted          CloseWaitingWindow()          HideGadget(GPBBGadgets\EProgressBar, #True) ; Hide EProgressBar which showed the progress.          HideGadget(GPBBGadgets\TProgressBar, #True)          HideGadget(GPBBGadgets\BStats, #False)     ; Show the 'Statistics' button.          HideGadget(GPBBGadgets\BRefresh, #False)          BringWindowToTop_(GadgetID(GPBBGadgets\BStats))          BringWindowToTop_(GadgetID(GPBBGadgets\BRefresh))                    ; Trigger a redisplay of the results:          ExactValueSearch = #DoProgrammedSearch ; For the "Details" and "Found in..." panels          RefreshEPanel    = #True               ; For result panels        EndIf        ;        Reset = #False        ;      ElseIf Result = #Completion_Error        alert("Unexpected program Error in 'ManagePBBBackgroundTasks()'.")        BackgroundTasksCompletion = #BackgroundTasksMustRestart        ProcedureReturn      EndIf      ;      If BackgroundTasksCompletion <> #BackgroundTasksCompleted        ; All that follows will not be very useful for analyzing small files        ; because the exploration phase will be completed before the        ; EProgressBar even has time to update. However, for the analysis of large        ; source codes (over 200 KB), which can take more than a second to analyze,        ; it is useful to be able to track its progress.        ;        ExplorationProgress  = 50 * ExplorationStep / (#EndEnumPBBElementTypes - 1)        ;        SetGadgetState(GPBBGadgets\EProgressBar, ExplorationProgress)        ;        ; Note the moment when the exploration was interrupted:        LastTimeForBackgroundTasksEnding = ElapsedMilliseconds()      EndIf    EndIf    ;    ProcedureReturn EventID    ;  EndIf  ;EndProcedure;Procedure ManagePipeMessages()  ;  ; This procedure listens to the 'Pipe' named 'PBBrowserRunningPipe$',  ; and retrieves any message$ sent by another instance of PBBrowser.  ;  ; Specifically, when the PureBasic editor calls PBBrowser from its 'Tools' menu,  ; it starts an instance of PBBrowser. Two possible scenarios arise:  ; If no other instance was already running, PBBrowser  ; starts and directly uses the parameters that were provided.  ; If another instance is already running, the new instance  ; retrieves the arguments and sends them to the old instance via the 'Pipe',  ; then ends its operation.  ; The main instance (the first one started) regularly checks  ; the 'Pipe' to see if any arguments are being passed.  ;  Shared PBB_LastEventTime ; This timer contains the time of the last user event  Shared ExactValueSearch  ;  Protected NewArgument$  Protected ActivePannel, mPBBListOfFiles$, BOText$  ;  ; *******************************************************************  ;  Handling messages from another instance of PBBrowser.  ;  NewArgument$ = ListenForPipeMessages()  If NewArgument$ <> ""    ; The PureBasic editor just launched another instance which has    ; sent us new arguments.    ;    If GetWindowState(GPBBGadgets\PBBWindow) = #PB_Window_Minimize      SetWindowState(GPBBGadgets\PBBWindow, #PB_Window_Normal)    EndIf    SetForegroundWindow_(WindowID(GPBBGadgets\PBBWindow))    SetFocus_(WindowID(GPBBGadgets\PBBWindow))    BringWindowToTop_(WindowID(GPBBGadgets\PBBWindow))    ;    PBB_LastEventTime = ElapsedMilliseconds()    If StringField(NewArgument$, 1, #CR$)      PureBasicProgAddr$ = StringField(NewArgument$, 1, #CR$)      If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ is a global variable        WritePreferenceString("PureBasicProgAdr", PureBasicProgAddr$)        ClosePreferences()      EndIf    EndIf    ;    PBUnderCursor$ = StringField(NewArgument$, 2, #CR$)    ;    FicActualPB$ = StringField(NewArgument$, 3, #CR$)    ;    If StringField(GetGadgetText(GPBBGadgets\SearchedExpression_gadget), 1, #SpecialSpace$) <> PBUnderCursor$      ; The search string has changed. Update:      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, PBUnderCursor$)      ;      If PBUnderCursor$        ActivePannel = GetActivePBBPanel()        If ActivePannel <> #FoundInFilesPBBPanel And  ActivePannel <> #DetailPBBPanel          SetActivePBBPanel(#FoundInFilesPBBPanel)        EndIf      Else        SetActivePBBPanel(#FilePBBPanel)      EndIf      ;      ExactValueSearch = #DoProgrammedSearch    EndIf    ;    If FicActualPB$      PBBUpdateMainFile(FicActualPB$) ; Update with the new arguments.    EndIf  EndIfEndProcedure;; Include the tools here so that they have access; to all the procedures and macros developed above.;XIncludeFile "PBBrowser_NativeTools.pb"XIncludeFile "PBBrowser_CustomTools.pb";Procedure PBBrowserMainProc(WSticky = -1)  ;  Shared RefreshEPanel             ; When this variable is greater than zero, it triggers a refresh of the display for certain panels.                                   ; This is managed by the ManagePBBBackgrounsTasks() procedure, which can set it to one.  ;  Shared BackgroundTasksCompletion ; Indicates the progress state of the exploration.  ;  Shared PBBWaitingGadget          ; Can hold the number of a gadget when a waiting window has been opened by ManageWaitingWindow().  ;  Shared PBBRichEditMessage, PBBREGadgetID, RangeOfClic.CHARRANGE ; To handle clicks on pseudo-links. These variables are updated                                           ; by the PBBRichEditCallback() procedure.                                           ;  Shared ExactValueSearch ; This variable tells PBBrowserMainProc that a new search should be started.                          ; It is shared by ManagePBBBackgroundTasks(), ManagePipeMessages(), and                          ; ClikOverREGadget(), and is also a parameter for GetTypeOfExpression.                          ;  Shared SearchNavigationIndex  ; Will contain the last position in ListOfSearch()  ;  Shared StatReport$      ; Will contain statistics on exploration of the code.  ;  Protected TFileLength, TLines, Addr$, StatReport2$, LineC$, PosInFileList, *FString.String   ; Used for statistics display.  ;  Protected EventID, EventGadget, EventMenu, QuitAll, NoREGadget, ActPannel ; For event handling.  :   Protected PBB_LastUpdateTime ; Used to measure the time since the last check of the files.  ;  ; Other variables:  Protected TypeOfElement, SExpression$, StrRef$, pd, pf  Protected FileName$, LastSearch.LastSearchDetails, SFound  Protected NFile$, mPBBListOfFiles$, BOText$  Protected scrollPos.point, PBBLanguageFolder$  ;  ;  If WSticky = -1 And OpenPreferencesWithPatience(PBBrowserPrefile$)    WSticky = ReadPreferenceLong("WSticky", 1)    ClosePreferences()  EndIf  ;  If OpenPBBMainWindow(WSticky)    ;    PBBUpdateMainFile(PBBFicPrincipalPB$)    ;________________________________________________________    ;    ;     Initializing searches and exploration    ;    If PBUnderCursor$ ; A global variable set upstream that contains the expression                      ; passed by the PureBasic editor to PBBrowser.      SetGadgetState(GPBBGadgets\MainPanelGadget, #FoundInFilesPBBPanel)    Else      SetGadgetState(GPBBGadgets\MainPanelGadget, #FilePBBPanel)      SetActiveGadget(GPBBGadgets\SearchedExpression_gadget)    EndIf    ;________________________________________________________    ;    ClearKeyboardBuffer(GPBBGadgets\PBBWindow)    ;    If PBUnderCursor$ ; This global variable may have been set by arguments received at startup,                      ; if the application is running in 'StandAlone' mode.      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, PBUnderCursor$)      ExactValueSearch = #DoProgrammedSearch    EndIf    ;    Repeat      ;      ; Since the user may toggle between the PureBasic window and the PBBrowser window,      ; ensure that clicks on PBBrowser gadgets are properly transmitted, even when the window      ; was inactive at the time of the click:      Shared MustStayActive ; MustStayActive is updated in the 'ClickOverREGadget()' procedure       ; when activating the PureBasic editor with a 'RunProgram()', which causes our window to lose focus.      If GetActiveWindow() = -1 And (ElapsedMilliseconds() - MustStayActive) < 500        ; For Windows 7, we must force the issue by simulating repeated clicks        ; until we regain focus (for a maximum duration of 500 ms).        ClickOverGadget(GetREGadgetNbrFromActivePBBPanel())      EndIf      ;      ; For Windows versions later than Windows 7,      ; TransfertClickToGadget() is usually sufficient:      TransfertClickToGadget()      ;      If BackgroundTasksCompletion <> #BackgroundTasksCompleted        EventId = ManagePBBBackgroundTasks()      Else        EventId = WaitWindowEvent(200)        ;        ; Every half-second, check if a file has been modified,        ; in order to update our data and display:        If (EventId = 0 Or EventId = #WM_TIMER) And ElapsedMilliseconds() - PBB_LastUpdateTime > 500          PBB_LastUpdateTime = ElapsedMilliseconds()          UpdateAllFilesInMemory()        EndIf      EndIf      ;      ; In each cycle, check if data has been received      ; from another instance:      ManagePipeMessages()      ;      ; Only process application events when the waiting window      ; is not displayed:      If PBBWaitingGadget = 0        If EventWindow() = GPBBGadgets\PBBWindow Or ExactValueSearch Or RefreshEPanel Or PBBFirstLaunch          ;          If EventID = 0 And PBBFirstLaunch            ; Ask to the user if he/she wants to see the Help and Tools window:            If AlertInPBBWindow(GetTextFromCatalog("WantToSeeHelp"), "", 1, 0, 0, 0, "", #AW_YesOrNo_YesByDefault) <> #PB_MessageRequester_Yes              PBBFirstLaunch = 0            EndIf          EndIf          ;          EventGadget = 0          ;          If EventID = #PB_Event_CloseWindow            QuitAll = 1          ElseIf EventID = #PB_Event_Menu Or PBBFirstLaunch            ;            EventMenu = EventMenu()            ;            If PBBFirstLaunch              ; Open the Help and Tools window if PBBFirstLaunch = 1.              PBBFirstLaunch = 0              EventMenu = #PBBMenu_THAT            EndIf            ;            If EventMenu = #PBBMenu_Return ; Press Return.              EventID = #PB_Event_Gadget              EventGadget = GPBBGadgets\BSearchExpression            ElseIf EventMenu = #PBBMenu_Escape ; Press Escape.              QuitAll = 1            ElseIf EventMenu = #PBBMenu_Find ; Press CTRL Q.              If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel                NoREGadget = GetREGadgetNbrFromActivePBBPanel()                SExpression$ = TOM_GetText(NoREGadget)                ; When the user selects a portion of text in the 'Details' panel                ; or in the 'Found in...' panel, and then presses CTRL Q,                ; a search is launched on the selected expression.                If SExpression$                  SetGadgetText(GPBBGadgets\SearchedExpression_gadget, SExpression$)                  ExactValueSearch = #DoProgrammedSearch                EndIf              EndIf              EventID = #PB_Event_Gadget              EventGadget = GPBBGadgets\BSearchExpression            ElseIf EventMenu = #PBBMenu_THAT ; Press CTRL I or select from the menu.              DisablePBBWindow()              ; Open 'Help and Tools'.              THATProc()              ; Refresh the menu.              UpdatePBBMenus()              EnablePBBWindow()              ;              ; Navigation commands:              ;            ElseIf EventMenu = #PBBMenu_Prefs              DisablePBBWindow()              PBBSetParameters()              EnablePBBWindow()              ColorizeAndSetFontsForPBBGadgets()              ExactValueSearch = #DoProgrammedSearch              ;            ElseIf EventMenu = #PBBMenu_NextPanel              WalkOverPannels(1)            ElseIf EventMenu = #PBBMenu_PreviousPanel              WalkOverPannels(-1)            ElseIf EventMenu =  #PBBMenu_PageUp              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_PAGEUP, 0)            ElseIf EventMenu =  #PBBMenu_PageDown              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_PAGEDOWN, 0)            ElseIf EventMenu =  #PBBMenu_Up              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_LINEUP, 0)            ElseIf EventMenu =  #PBBMenu_Down              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_LINEDOWN, 0)            ElseIf EventMenu =  #PBBMenu_NextPage              ActPannel = GetActivePBBPanel()              If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel                If WalkOverPages(1) = #False                  WalkOverPannels(1)                EndIf              Else                WalkOverPannels(1)              EndIf            ElseIf EventMenu =  #PBBMenu_PreviousPage              ActPannel = GetActivePBBPanel()              If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel                If WalkOverPages(-1) = #False                  WalkOverPannels(-1)                EndIf              Else                WalkOverPannels(-1)              EndIf              ;              ; Tool commands:              ;            ElseIf EventMenu >= #PBBMenu_CommandOffset And EventMenu < 300              ExecCommandFromPBBWindow(EventMenu - #PBBMenu_CommandOffset)              ;              ; Hamburger menu commands:              ;            ElseIf EventMenu = #REM_ZoomIn              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), 10)              ReSizeREMenu()            ElseIf EventMenu = #REM_ZoomOut              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), -10)              ReSizeREMenu()            ElseIf EventMenu = #REM_ZoomReset              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), 0)              ReSizeREMenu()            ElseIf EventMenu = #REM_FindInPannel              RE_FindReplace(GetREGadgetNbrFromActivePBBPanel(), 0, GPBBGadgets\PBBWindow)            ElseIf EventMenu = #REM_CopyAll              TOM_Copy(GetREGadgetNbrFromActivePBBPanel(), 0, -1)            ElseIf EventMenu = #REM_SaveAsText              NFile$ = SaveFileRequester(GetTextFromCatalogPB("SaveAs"), "", GetTextFromCatalogPB("TextFile"), 1)              If NFile$                NFile$ = ChangeFileExtension(NFile$, "txt")                RE_SaveContent(GetREGadgetNbrFromActivePBBPanel(), NFile$, #SF_TEXT)              EndIf            ElseIf EventMenu = #REM_SaveAsRTF              NFile$ = SaveFileRequester(GetTextFromCatalogPB("SaveAs"), "", GetTextFromCatalogPB("RTFFile"), 1)              If NFile$                NFile$ = ChangeFileExtension(NFile$, "RTF")                RE_SaveContent(GetREGadgetNbrFromActivePBBPanel(), NFile$, #SF_RTF, 1)              EndIf            EndIf          ElseIf EventID = #PB_Event_Gadget            EventGadget = EventGadget()            ;            If SearchNavigationIndex And EventGadget = GetREGadgetNbrFromActivePBBPanel()              If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel                ; We are in the 'Details' panel or in 'Found in...'.                ; Memorize the position of the scrollbar, so that we can                ; restore it the next time we return to this panel.                ForEach ListOfSearchs()                  If ListIndex(ListOfSearchs()) = SearchNavigationIndex - 1                    SendMessage_(GadgetID(EventGadget), #EM_GETSCROLLPOS, 0, @scrollPos.point)                    If GetActivePBBPanel() = #DetailPBBPanel                      ListOfSearchs()\Search_DetailScrollPos\x = scrollPos\x                      ListOfSearchs()\Search_DetailScrollPos\y = scrollPos\y                    Else                      ListOfSearchs()\Search_FoundInScrollPos\x = scrollPos\x                      ListOfSearchs()\Search_FoundInScrollPos\y = scrollPos\y                    EndIf                  EndIf                Next              EndIf            EndIf          EndIf          ;          ; Repositioning the hamburger button for REGadgets.          ;          If EventId = #WM_LBUTTONDOWN Or EventId = #WM_LBUTTONUP            ReSizeREMenu()          EndIf          ;          ; The refreshing of the item panels can be the result of a user action          ; or a request from background tasks.          ; Therefore, manage the conditions for this refresh separately from the management          ; of other gadgets.          ;          If GetGadgetState(GPBBGadgets\MainPanelGadget) = #ListPBBPanel And FileSize(PBBFicPrincipalPB$) > 2            If RefreshEPanel Or ((EventGadget = GPBBGadgets\ListsPGadget Or EventGadget = GPBBGadgets\MainPanelGadget) And EventType() = #PB_EventType_Change And EventID = #PB_Event_Gadget)              TypeOfElement = TypeElementOfPBBPanel(GetActivePBBPanel())              While ListCompletionAll(TypeOfElement) < #ListCompletion_Done                ; The list of elements that should be displayed is not complete.                ; So, complete it:                SetOneListOfAllElements(TypeOfElement, GPBBGadgets\PBBWindow)              Wend              If RefreshEPanel = #False                CloseWaitingWindow()              EndIf              If ListCompletionAll(TypeOfElement) < #ListCompletion_Printed Or RefreshEPanel                ; The gadget that should contain the list of elements has not been filled yet.                ; So, fill it.                FillElementREGadget(TypeOfElement)                ; In case of 'RefreshEPanel', we clear the event stack generated by the redrawing                ; of the RichEdit Gadget of the item, to avoid unnecessary slowdowns during                ; the background update.                While WindowEvent() : Wend              EndIf            EndIf          EndIf          ;          ; Handling clicks on pseudo-links.          ;          ; (PBBRichEditMessage and PBBREGadgetID are updated by the PBBRichEditCallback procedure).          ;          If PBBRichEditMessage = #WM_LBUTTONUP Or PBBRichEditMessage = #WM_RBUTTONUP ; click inside one of the RichEditGadgets.                        NoREGadget = GetREGadgetNbrFromActivePBBPanel()            If NoREGadget And GadgetID(NoREGadget) = PBBREGadgetID              ClickOverREGadget(PBBRichEditMessage)            EndIf            PBBRichEditMessage = 0          ElseIf PBBRichEditMessage = #WM_LBUTTONDBLCLK            PBBRichEditMessage = 0            ; The user double-clicked inside the content of a RichEdit Gadget,            ; which likely resulted in selecting a portion of text.            ; Check if the double-click occurred in the 'Details' panel or in the 'Found in...' panel.            If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              ;              ; First, check if the double-click occurred on an image-button.              ; This can happen if the user clicks too frantically              ; on the [<] or [>] buttons.              If GetImageNameFromSelectionPos(NoREGadget) = ""                ;                ; Now check if it might be useful to expand the selection,                ; because by default, the selection made by Windows during                ; a double-click in a 'RichEdit control' stops at the underscore ('_')                ; and does not include characters "$" and "#" which are part of variable names.                ;                ; Retrieve the text from the gadget:                StrRef$ = ReplaceString(GetGadgetText(NoREGadget), #LF$, "")                ;                ; Get the position of the last click recorded by PBBRichEditCallback:                pd = RangeOfClic\cpMin + 1                pf = RangeOfClic\cpMax + 1                ;                ; Expand the selection until find a separator on both sides.                While pd And (FindString(ListPBSep$, FastMid(StrRef$, pd, 1)) = 0 Or FastMid(StrRef$, pd, 1) = "*" Or FastMid(StrRef$, pd, 1) = "#") : pd - 1 : Wend                pd + 1                While pf <= Len(StrRef$) And FindString(ListPBSep$, Mid(StrRef$, pf, 1)) = 0  : pf + 1 : Wend                ; Apply the expanded selection in the text.                TOM_SetSelectionPos(NoREGadget, pd - 1, pf - 1)              EndIf            EndIf          EndIf          ;          ; Handling classic gadgets.          ;          If EventGadget = GPBBGadgets\BQuit            QuitAll = 1          ElseIf EventGadget = GPBBGadgets\BStick            StickyWindow(GPBBGadgets\PBBWindow, GetGadgetState(GPBBGadgets\BStick))            If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ is a global variable.              WritePreferenceLong("WSticky", GetGadgetState(GPBBGadgets\BStick))              ClosePreferences()            EndIf            ;          ElseIf EventGadget = GPBBGadgets\BStats            ;            ;- Display Stats            ;            TFileLength = 0            TLines = 0            ;            If PBBListOfFiles$              PosInFileList = 0              Repeat                 PosInFileList + 1                LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)                If LineC$                  Addr$ = StringField(LineC$, 1, #TAB$)                  TFileLength + FileSize(Addr$)                  *FString = GetPointedCodeFromFile(Addr$)                  TLines + CountString(*FString\s, #CR$)                EndIf              Until LineC$ = ""            EndIf            StatReport2$ = GetTextFromCatalogPB("TFileLength")      + " : " + FormatNumber(TFileLength, 0, ".", ",") + " bytes / "            StatReport2$ + FormatNumber(TLines, 0, ".", ",") + " " + GetTextFromCatalogPB("Lines") + "." + #CR$ + #CR$            StatReport2$ + GetTextFromCatalogPB("ElementUsedOrNot") + #CR$            ;            ; Add the number of existing and found elements:            For TypeOfElement = 0 To #EndEnumPBBElementTypes - 1              StatReport2$ + GetTextFromCatalogPB(PBBTypeNames$(TypeOfElement)) + ": " + Str(ListOfAllElementsNbr(TypeOfElement)) + " / " + Str(ListOfUsedElementsNbr(TypeOfElement))   + "." + #CR$            Next            ;            AlertInPBBWindow(StatReport$ + StatReport2$, GetTextFromCatalogPB("Statistics"))            ;          ElseIf EventGadget = GPBBGadgets\BRefresh            PBBUpdateMainFile(PBBFicPrincipalPB$, #True)            ;          ElseIf EventGadget = GPBBGadgets\BAbout            ;            ; Display "Help and Tools'.            ;            DisplayPopupMenu(GPBBGadgets\Menu, WindowID(GPBBGadgets\PBBWindow))            ;          ElseIf EventGadget = GPBBGadgets\BLanguage            ;            ; Language choice:            ;            If OpenPreferencesWithPatience(PBBrowserPrefile$)              PBBLanguageFolder$ = ReadPreferenceString("PBBLanguageFolder", "")              ClosePreferences()            Else              Alert("Error while opening preference file.")              End            EndIf            ;            DisablePBBWindow()            ;            PBBLanguageFolder$ = ChooseLanguage(MyAppDataFolder$ + "Catalogs\", PBBLanguageFolder$)            If OpenPreferencesWithPatience(PBBrowserPrefile$)              WritePreferenceString("PBBLanguageFolder", PBBLanguageFolder$)              ClosePreferences()            EndIf            ;            EnablePBBWindow()            ;            GetTextFromCatalog("", PBBLanguageFolder$ + "PBBrowser.catalog")            SetPBBGadgetsTitles()            ExactValueSearch = #DoProgrammedSearch            ;          ElseIf EventGadget = GPBBGadgets\BREMenu            ;            ; Display the hamburger menu for REGadgets.            ;            DisplayPopupMenu(GPBBGadgets\REMenu, WindowID(GPBBGadgets\PBBWindow))            ;          ElseIf EventGadget = GPBBGadgets\MainPanelGadget And (GetActivePBBPanel() = #FoundInFilesPBBPanel Or GetActivePBBPanel() = #DetailPBBPanel) And EventType() = #PB_EventType_Change            ; While navigating inside the panels, the user just triggered the display            ; of the "Details" panel or the "Found in..." panel.            ExactValueSearch = #DoProgrammedSearch ; Refresh the search results.            ;          ElseIf EventGadget = GPBBGadgets\BChangeAdresse            FileName$ = OpenFileRequester(GetTextFromCatalogPB("SelectMainFile"), PBBFicPrincipalPB$, "PureBasic (pb,pbi,pbp)|*.pb;*.pbi;*pbp", 1)            ; The user just changed the address of the main file.            If FileName$              SetGadgetText(GPBBGadgets\SearchedExpression_gadget, "")              SetActivePBBPanel(#FilePBBPanel)              PBBUpdateMainFile(FileName$)            EndIf          EndIf          ;          ; The management of what follows can also have several causes.          ; It could either be triggered by the user (by clicking on 'Search'),          ; or by a procedure or by what preceded it (if a non-zero value          ; has been assigned to ExactValueSearch).          ; Again, we manage the situation differently from other gadgets.          ;           If (EventID = #PB_Event_Gadget And EventGadget = GPBBGadgets\BSearchExpression) Or (ExactValueSearch And ExactValueSearch <> #NoSearch)            ;            ;- BSearchExpression            ;            ; Check if the files are up to date compared to what is in memory.            ; If not, 'UpdateAllFilesInMemory()' will update them, as well as            ; the list of elements:            UpdateAllFilesInMemory()            ;            ;            SExpression$ = GetGadgetText(GPBBGadgets\SearchedExpression_gadget)            ;            If FindString(SExpression$, #SpecialSpace$)              ;              ; The search field contains an expression that has already been searched.              ;              SFound = 0              If ListSize(ListOfSearchs())                ForEach ListOfSearchs()                  If ListIndex(ListOfSearchs()) = SearchNavigationIndex - 1                    LastSearch\ElementName$ = ListOfSearchs()\Search_Details\ElementName$                    LastSearch\ElementType = ListOfSearchs()\Search_Details\ElementType                    LastSearch\TypeName$ = ListOfSearchs()\Search_Details\TypeName$                    SExpression$ = ComputeExpressionField(LastSearch)                    SetGadgetText(GPBBGadgets\SearchedExpression_gadget, SExpression$)                    SFound = 1                    Break                  EndIf                Next              EndIf              If SFound = 0                SExpression$ = StringField(SExpression$, 1, #SpecialSpace$)              EndIf            EndIf            ;            If FindString(SExpression$, #SpecialSpace$) = 0              ; The user entered an expression in the search field.              ; or the search history has been cleared.              ;              GetTypeOfExpression(SExpression$, LastSearch, #DoManualSearch)              If LastSearch\ElementType > -1                ; The #SpecialSpace$ character (thin space) is used to isolate                ; the entered expression from what follows (a specification of the expression type).                SExpression$ = ComputeExpressionField(LastSearch)              EndIf              SetGadgetText(GPBBGadgets\SearchedExpression_gadget, SExpression$)            EndIf            ;            If GetActivePBBPanel() = #DetailPBBPanel              FillDetailREGadget(LastSearch)            ElseIf SExpression$              SetActivePBBPanel(#FoundInFilesPBBPanel)              FillFoundInREGadget(LastSearch)            EndIf            ;            ExactValueSearch = #NoSearch          EndIf        EndIf      EndIf      RefreshEPanel = #False    Until QuitAll        If IsWindow(GPBBGadgets\PBBWindow)      RecordWindowDimInPref(PBBrowserPrefile$, GPBBGadgets\PBBWindow)      CloseWindow(GPBBGadgets\PBBWindow)    EndIf  EndIf  ClearKeyboardBuffer(0)  ;  ; Ensure to keep the clipboard content available after program ending:  OleFlushClipboard_()  ;EndProcedure;PBBrowserMainProc();; IDE Options = PureBasic 6.30 beta 5 (Windows - x64); CursorPosition = 5324; FirstLine = 1818; Folding = AAgIAIAAMtRq6; Optimizer; EnableThread; EnableXP; DPIAware; DllProtection; UseIcon = PBBrowser resources\Images\PBBrowserLogo.ico; Executable = PBBrowser.exe; Compiler = PureBasic 6.30 beta 5 (Windows - x64); DisablePurifier = 32,32,64,32