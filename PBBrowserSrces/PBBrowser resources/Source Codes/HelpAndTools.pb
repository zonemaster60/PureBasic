;***********************************************************************;;                            HelpAndTools.pb;                       Part of PBBrowser project;                           Zapman - Dec 2024;;     Set of functions to print the 'help and tools' panel and to;           manage the 'tool-commands' and there shortcuts.;;***********************************************************************;;;Prototype.i ProcedureWithoutArguments();Prototype.s ProcedureWithArguments(Arg$);Structure CommandDetails  CommandName$  CommandShortCut.i  CommandNo.i  Commandtype.i  CommandDescription$  CommandDontShow.b  CommandSimpleProcAddr.ProcedureWithoutArguments  CommandWithArgProcAdr.ProcedureWithArgumentsEndStructure;Global NewList CommandList.CommandDetails();Procedure.s ComputePrefFromCommandName(CommandName$)  ; On formate CommandName$ pour former, dans tous les cas,  ; un nom acceptable en tant que nom de valeur dans le  ; fichier des préférences.  Protected NCommandName$, ct  ;  CommandName$ = ReplaceString(CommandName$, "InCatalog:", "")  CommandName$ = Trim(ReplaceString(CommandName$, "  ", " "))  CommandName$ = ReplaceString(CommandName$, " ", "_")  ;  ; On enlève les accents et les caractères bizarres.  ; CommandName$ = RemoveAccents(CommandName$)  NCommandName$ = ""  For ct = 1 To Len(CommandName$)    If Mid(CommandName$, ct, 1) <> "_" And Asc(Mid(CommandName$, ct, 1)) < 48 Or (Asc(Mid(CommandName$, ct, 1)) > 57 And Asc(Mid(CommandName$, ct, 1)) < 65) Or (Asc(Mid(CommandName$, ct, 1)) > 90 And Asc(Mid(CommandName$, ct, 1)) < 97) Or Asc(Mid(CommandName$, ct, 1)) > 122      NCommandName$ + "_"    Else      NCommandName$ + Mid(CommandName$, ct, 1)    EndIf  Next  ProcedureReturn NCommandName$EndProcedure;Procedure AddCommandToList(*CDetails.CommandDetails)  ;  Static cpt  ;  Protected PrefShortcutName$, PrefDontShowName$  ;  If *CDetails And *CDetails\CommandName$    cpt + 1    ;    AddElement(CommandList())    CopyStructure(*CDetails, @CommandList(), CommandDetails)    ;    CommandList()\CommandNo = cpt    ;    If OpenPreferencesWithPatience(PBBrowserPrefile$)      PrefShortcutName$ = ComputePrefFromCommandName(CommandList()\CommandName$) + "_Shortcut"      CommandList()\CommandShortCut = ReadPreferenceInteger(PrefShortcutName$, *CDetails\CommandShortCut)      PrefDontShowName$ = ComputePrefFromCommandName(CommandList()\CommandName$) + "_DontShow"      CommandList()\CommandDontShow = ReadPreferenceInteger(PrefDontShowName$, *CDetails\CommandDontShow)      ClosePreferences()    EndIf    ;  EndIf  ProcedureReturn cptEndProcedure;Procedure GetCommandDetails(CommandName$)  ; Retourne un pointeur vers la position contenant 'CommandName$'  ; dans la liste CommandList().  ; Retourne zéro si 'CommandName$' n'a pas été trouvé.  ;  If LCase(CommandList()\CommandName$) <> LCase(CommandName$)    ; Inutile de rechercher la bonne position    ; si nous sommes déjà dessus !    ForEach CommandList()      If LCase(CommandList()\CommandName$) = LCase(CommandName$)        Break      EndIf    Next  EndIf  ;  If LCase(CommandList()\CommandName$) = LCase(CommandName$)    ProcedureReturn @CommandList()  Else    AlertInPBBWindow("Programme error in 'GetCommandDetails()':" + #CR$ + "A wrong CommandName$ has been requested:" + #CR$ + "'" + CommandName$ + "'")  EndIfEndProcedure;Procedure.s GetCommandName(CommandNo)  If CommandList()\CommandNo <> CommandNo    ; Inutile de rechercher la bonne position    ; si nous sommes déjà dessus !    ForEach CommandList()      If CommandList()\CommandNo = CommandNo        Break      EndIf    Next  EndIf  If CommandNo And CommandList()\CommandNo = CommandNo    ProcedureReturn CommandList()\CommandName$  Else    ProcedureReturn "Error in GetCommandDetails() parametre: '" + Str(CommandNo) + "' is'nt a valid command number."  EndIfEndProcedure;Procedure.s GetTranslatedCommandName(CommandeNo)  Protected TitleName$ = GetCommandName(CommandeNo) ; Valeur de retour  If Left(TitleName$, 10) = "InCatalog:"    ; Le titre de la commande demande à être traduit    ; à l'aide du 'Catalog' (fichier de textes traduits    ; dans la langue courante de l'application).    TitleName$ = Trim(Mid(TitleName$, 11))    TitleName$ = GetTextFromCatalogPB(TitleName$)  EndIf  ProcedureReturn TitleName$EndProcedure;Procedure.s GetTranslatedCommandDescription(CommandeNo)  ;  Protected Description$ ; Valeur de retour                         ;  GetCommandName(CommandeNo)  Description$ = CommandList()\CommandDescription$  If Left(Description$, 10) = "InCatalog:"    ; Le titre de la commande demande à être traduit    ; à l'aide du 'Catalog' (fichier de textes traduits    ; dans la langue courante de l'application).    Description$ = Trim(Mid(Description$, 11))    Description$ = GetTextFromCatalogPB(Description$)  EndIf  ProcedureReturn Description$EndProcedure;Procedure GetCommandNo(CommandName$)  GetCommandDetails(CommandName$)  ProcedureReturn CommandList()\CommandNoEndProcedure;Procedure GetCommandShortCut(CommandeNo)  GetCommandName(CommandeNo)  ProcedureReturn CommandList()\CommandShortCutEndProcedure;Procedure GetCommandDontShow(CommandeNo)  GetCommandName(CommandeNo)  ProcedureReturn CommandList()\CommandDontShowEndProcedure;Procedure SetCommandShortCut(CommandeNo, ShortCut)  ;  Protected  PrefShortcutName$  ;  GetCommandName(CommandeNo)  CommandList()\CommandShortCut = ShortCut  ; On enregistre le raccourci dans les préférences, afin de le conserver  ; pour les prochaines sessions :  If OpenPreferencesWithPatience(PBBrowserPrefile$)    PrefShortcutName$ = ComputePrefFromCommandName(CommandList()\CommandName$) + "_Shortcut"    WritePreferenceInteger(PrefShortcutName$, CommandList()\CommandShortCut)    ClosePreferences()  EndIfEndProcedure;Procedure SetCommandDontShow(CommandeNo, XDontShow)  ;  Protected  PrefDontShowName$  ;  GetCommandName(CommandeNo)  CommandList()\CommandDontShow = XDontShow  ; On enregistre la valeur dans les préférences, afin de la conserver  ; pour les prochaines sessions :  If OpenPreferencesWithPatience(PBBrowserPrefile$)    PrefDontShowName$ = ComputePrefFromCommandName(CommandList()\CommandName$) + "_DontShow"    WritePreferenceInteger(PrefDontShowName$, CommandList()\CommandDontShow)    ClosePreferences()  EndIfEndProcedure;Procedure.s ExecCommandProc(Arg$ = "")  If CommandList()\CommandSimpleProcAddr = 0    AlertInPBBWindow("Bad parameter for ExecCommandProc(). CommandName$ = " + CommandList()\CommandName$)    ProcedureReturn  EndIf  If CommandList()\Commandtype = 1    ProcedureReturn Str(CommandList()\CommandSimpleProcAddr())  ElseIf CommandList()\Commandtype = 2    ProcedureReturn CommandList()\CommandWithArgProcAdr(Arg$)  EndIfEndProcedure;Procedure.s ExecCommandProcFromName(CommandName$, Arg$ = "")  ;  If GetCommandDetails(CommandName$)    ProcedureReturn ExecCommandProc(Arg$)  EndIfEndProcedure;Procedure.s ExecCommandProcFromNo(CommandNo, Arg$ = "")  ;  GetCommandName(CommandNo)  ProcedureReturn ExecCommandProcFromName(CommandList()\CommandName$, Arg$)EndProcedure;; *******************************************************************************;;            Fenêtre Tips, Help and Tools et gestion des raccourcis;;Structure THATGadgetsStruct  WTHAT.i  ; Layout parameters:  Margins.i  ButtonHeight.i  TitleHeight.i  TipsList$  HelpList$  ToolsList$  ;  IWhiteOver.i  ;  ; Gadget numbers:  TipsListTitle.i  TipsList.i  HelpListTitle.i  HelpList.i  ToolsListTitle.i  ToolsList.i  EExplanations.i  BExecute.i  BShortcut.i  TitleShortcut.i  Shortcut.i  XDontShow.i  BCopy.i  BQuit.i  ;EndStructure; Procedure ExecCommandFromTHATWindow(NoLine)  ;  Shared THATGadgets.THATGadgetsStruct ; Pour permettre l'accès partagé aux données de la fenêtre  ;  HideGadget(THATGadgets\IWhiteOver, #False)  DisableWindow(THATGadgets\WTHAT, #True)  ;  ExecCommandProcFromNo(NoLine)  ;  DisableWindow(THATGadgets\WTHAT, #False)  HideGadget(THATGadgets\IWhiteOver, #True)  SetActiveWindow(THATGadgets\WTHAT)EndProcedure;Procedure ExecCommandFromPBBWindow(NoLine)  ;  DisablePBBWindow()  ;  ExecCommandProcFromNo(NoLine)  ;  EnablePBBWindow()EndProcedure;Procedure SetPBBShortcut()  ;  ; Ouvre une fenêtre permettant à l'utilisateur de définir un raccourci-clavier  ; pour une commande particulière.  ;  Protected  ShortCutsList$, CSGadgetNames.CSCTitleAndButtons  Protected NoLine, TitleName$, SC, MSC  ;  Shared THATGadgets.THATGadgetsStruct ; Pour permettre l'accès partagé aux numéros de gadgets  ;  NoLine = GetGadgetState(THATGadgets\ToolsList) + 1  If NoLine > 0    HideGadget(THATGadgets\IWhiteOver, #False)    DisableWindow(THATGadgets\WTHAT, #True)    ;    ShortCutsList$ = ""    ; On recense les raccourçis déjà utilisés par les autres outils    ForEach(CommandList())      If CommandList()\CommandNo <> NoLine And CommandList()\CommandShortCut        ShortCutsList$ + GetTranslatedCommandName(CommandList()\CommandNo) + " = " + ComputeShortcutString(CommandList()\CommandShortCut) + #CRLF$      EndIf    Next    ;    TitleName$  = GetTranslatedCommandName(NoLine)    InitButtonsNamesForCaptureSC(CSGadgetNames.CSCTitleAndButtons)    CSGadgetNames\CaptureShortCutsTitle$ = GetTextFromCatalogPB("CaptureShortCutsTitleFor")    CSGadgetNames\CaptureShortCutsTitle$ + " " + TitleName$    MSC = CommandList()\CommandShortCut    CSGadgetNames\DefaultShortCut$ = ComputeShortcutString(CommandList()\CommandShortCut)    ;    ShortCutsList$ + "CloseThisWindow = ESC" + #CR$ + "ExecFind = RET" + #CRLF$    ShortCutsList$ + "OpenTipsHelpAndTools = CTRL + I" + #CRLF$    ShortCutsList$ + "Copy = CTRL + C" + #CR$ + "FindSelectedExpression = CTRL + Q" + #CRLF$    ShortCutsList$ + "SetShortcut = CTRL + S" + #CRLF$    ShortCutsList$ + "ScrollUp = UP" + #CR$ + "ScrollDown = DOWN" + #CRLF$    ShortCutsList$ + "ScrollPageUp = PAGEUP" + #CR$ + "ScrollPageDown = PAGEDOWN" + #CRLF$    ShortCutsList$ + "PreviousPage = LEFT" + #CR$ + "NextPage = RIGHT" + #CRLF$    ShortCutsList$ + "PreviousPannel = SHIFT + TAB" + #CR$ + "NextPannel = TAB" + #CRLF$    SC = CaptureShortCut(ShortCutsList$, CSGadgetNames)    If SC > -1      SetCommandShortCut(NoLine, SC)      If MSC        RemoveKeyboardShortcut(THATGadgets\WTHAT, MSC)      EndIf      AddKeyboardShortcut(THATGadgets\WTHAT, SC, NoLine + 20)    EndIf    ;    DisableWindow(THATGadgets\WTHAT, #False)    HideGadget(THATGadgets\IWhiteOver, #True)  EndIfEndProcedure;Procedure.s AddNormalColorToTextStyle(FontStyle$)  If FindString(FontStyle$, "ForeColor") = 0    FontStyle$ + ",ForeColor(" + Str(GetValueFromBPPrefFile("NormalTextColor")) + ")"  EndIf  If FindString(FontStyle$, "Bold") = 0    FontStyle$ + ",Bold(0)"  EndIf  If FindString(FontStyle$, "Italic") = 0    FontStyle$ + ",Italic(0)"  EndIf  If FindString(FontStyle$, "Underline") = 0    FontStyle$ + ",Underline(0)"  EndIf  If FindString(LCase(FontStyle$), "strikethrough") = 0    FontStyle$ + ",Strikethrough(0)"  EndIf  ProcedureReturn FontStyle$EndProcedure;Procedure ResizeGadgetsTHAT()  ;  ; Redimensionnement des gadgets de la fenêtre 'THATGadgets\WTHAT'  ;  Shared THATGadgets.THATGadgetsStruct ; Pour permettre l'accès partagé aux numéros de gadgets  ;  Protected FormWindowWidth, FormWindowHeight, LShift, HLists, HL1, HL2, WLists, LowBPos, SCLowPos, HLM, TW, PCA  ;  FormWindowWidth = WindowWidth(THATGadgets\WTHAT)  FormWindowHeight = WindowHeight(THATGadgets\WTHAT)  LShift = FormWindowWidth / 2.6  HLists = (FormWindowHeight - 3 * THATGadgets\Margins - 3 * THATGadgets\TitleHeight) / 3  WLists = LShift - THATGadgets\Margins / 2 - THATGadgets\Margins  ;  HL1 = HLists / 2  HL2 = HLists / 1  ;  LowBPos = FormWindowHeight - THATGadgets\ButtonHeight - THATGadgets\Margins + 2  SCLowPos = LowBPos - THATGadgets\ButtonHeight * 2 - THATGadgets\Margins * 2 + 6  ;  ResizeGadget(THATGadgets\TipsListTitle, #PB_Ignore, #PB_Ignore, WLists, #PB_Ignore)  ResizeGadget(THATGadgets\TipsList, #PB_Ignore, #PB_Ignore, WLists, HL1)  ;  ResizeGadget(THATGadgets\HelpListTitle, #PB_Ignore, HL1 + THATGadgets\Margins + THATGadgets\TitleHeight - 1, WLists, #PB_Ignore)  ResizeGadget(THATGadgets\HelpList, #PB_Ignore, HL1 + THATGadgets\Margins + THATGadgets\TitleHeight * 2, WLists, HL2)  ;  ResizeGadget(THATGadgets\ToolsListTitle, #PB_Ignore, HL1 + HL2 + (THATGadgets\Margins) * 2 + THATGadgets\TitleHeight * 2 - 1, WLists, #PB_Ignore)  ResizeGadget(THATGadgets\ToolsList, #PB_Ignore, HL1 + HL2 + (THATGadgets\Margins) * 2 + THATGadgets\TitleHeight * 3, WLists, FormWindowHeight - HL1 - HL2 - THATGadgets\Margins * 3 - THATGadgets\TitleHeight * 3)  ;  If GetGadgetState(THATGadgets\ToolsList) > -1    HLM = (THATGadgets\ButtonHeight + THATGadgets\Margins) * 3 + THATGadgets\Margins - 2  Else    HLM = (THATGadgets\ButtonHeight + THATGadgets\Margins) + THATGadgets\Margins - 2  EndIf  ResizeGadget(THATGadgets\EExplanations, LShift + THATGadgets\Margins / 2, THATGadgets\Margins, FormWindowWidth - LShift - THATGadgets\Margins / 2 - THATGadgets\Margins, FormWindowHeight - HLM - THATGadgets\Margins)  ;  If GetGadgetText(THATGadgets\Shortcut)    TW = GetTextWidthPix(THATGadgets\Shortcut, GetGadgetText(THATGadgets\Shortcut))    PCA = TW + THATGadgets\Margins    SetGadgetText(THATGadgets\BShortcut, GetTextFromCatalogPB("Change"))  Else    TW = 10    PCA = 0    HideGadget(THATGadgets\Shortcut, #True)    SetGadgetText(THATGadgets\BShortcut, GetTextFromCatalogPB("Assign"))  EndIf  ResizeGadget(THATGadgets\TitleShortcut, LShift + THATGadgets\Margins / 2, SCLowPos + 3, #PB_Ignore, #PB_Ignore)  ResizeGadget(THATGadgets\Shortcut, LShift + THATGadgets\Margins / 2 + GadgetWidth(THATGadgets\TitleShortcut) + THATGadgets\Margins, SCLowPos + 6, TW, #PB_Ignore)  ResizeGadget(THATGadgets\BShortcut, LShift + THATGadgets\Margins / 2 + GadgetWidth(THATGadgets\TitleShortcut) + PCA + THATGadgets\Margins, SCLowPos, #PB_Ignore, #PB_Ignore)  ;  ResizeGadget(THATGadgets\XDontShow, LShift + THATGadgets\Margins / 2, SCLowPos + THATGadgets\ButtonHeight, #PB_Ignore, #PB_Ignore)  ;  ResizeGadget(THATGadgets\BExecute, LShift + THATGadgets\Margins / 2, LowBPos, #PB_Ignore, #PB_Ignore)  ResizeGadget(THATGadgets\BQuit, FormWindowWidth - GadgetWidth(THATGadgets\BQuit) - THATGadgets\Margins, LowBPos, #PB_Ignore, #PB_Ignore)  ResizeGadget(THATGadgets\BCopy, FormWindowWidth - GadgetWidth(THATGadgets\BCopy) - GadgetWidth(THATGadgets\BQuit) - 2 * THATGadgets\Margins, LowBPos, #PB_Ignore, #PB_Ignore)  ;  ; Redraw the WhiteBox with the new window dimensions:  THATGadgets\IWhiteOver = WhiteBoxOverWindow(THATGadgets\WTHAT)  ;EndProcedure;#FromCommandList$ = "FromCommandList";Procedure FillTHATReGadget(ReGadget, TextList$, NoLine, SButton, XDontShow)  ;  ; Récupère un texte d'information dans le 'catalog' ou dans  ; la liste des commandes, et l'affiche dans 'ReGadget'  ; avant de le mettre en forme.  ;  Protected LName$, TitleName$, InfoText$, ExText$, ExLine$  Protected p, mp, ep  ;  If NoLine    If TextList$ = #FromCommandList$      ; Le texte est à récupérer dans le liste des      ; commandes.      TitleName$ = GetTranslatedCommandName(NoLine)      InfoText$ = GetTranslatedCommandDescription(NoLine)      SetGadgetText(SButton, ComputeShortcutString(GetCommandShortCut(NoLine)))      SetGadgetState(XDontShow, GetCommandDontShow(NoLine))    Else      ; Le texte est à récupérer dans la liste TextList$.      ; Il sera ensuite traduit grâce au contenu du 'Catalog'.      LName$ = StringField(TextList$, NoLine, ",")      If LName$        TitleName$ = GetTextFromCatalogPB(LName$)        ; On s'appuie ici sur une convention : tous les textes figurant        ; dans la partie explicative de 'THAT' sont enregistrés dans        ; le 'catalog' sous la forme :        ;  - NomDuTexteTitle  : Titre du texte        ;  - NomduTexteEx     : Contenu du texte        ; Ainsi, à partir du nom du texte, on sait comment obtenir son contenu :        InfoText$ = GetTextFromCatalogPB(ReplaceString(LName$, "Title", "Ex"))      EndIf    EndIf    ;    PBBPanelsDefaultFontStyle$ = AddNormalColorToTextStyle(PBBPanelsDefaultFontStyle$)    ;    If TitleName$      PBB_SuspendRedraw(ReGadget, #True)      ;      If @InfoText$ And (PeekC(@InfoText$) = #RTF_Marker Or Left(InfoText$, 2) = "{\")        ; Le texte récupéré est codé en RTF. On le place dans le gadget :        TOM_InsertText(ReGadget, InfoText$, 0, -1)        ; Et on lui applique tout de même un formatage de la police et de la taille :        TOM_SetFontStyles(ReGadget, PBBPanelsDefaultFontStyle$, 0, -1)      Else        ; Le texte récupéré est un texte simple. On le met en forme.        ExText$ = TitleName$ + #CR$ + InfoText$        TOM_InsertText(ReGadget, ReplaceString(ExText$, #CR$, #CRLF$), 0, -1)        TOM_ResetFontStyles(ReGadget, 0, -1); On supprime tous les styles.                                            ; On défini la police et la taille par défaut :        TOM_SetFontStyles(ReGadget, PBBPanelsDefaultFontStyle$, 0, -1)        ;        ; On sélectionne tout et on applique des petites marges        ; gauche et droite, pour que le texte, ne soit pas collé        ; aux bords :        TOM_SetParaStyles(ReGadget, "LeftIndent(6), RightIndent(6), SpaceAfter(2), Align(Justify)", 0, Len(ExText$))        ;        p = 0        Repeat          mp = p + 1          p = FindString(ExText$, #CR$, mp)          ep = p          If ep = 0 And mp < Len(ExText$) : ep = Len(ExText$) + 1 : EndIf          ExLine$ = Mid(ExText$, mp, ep - mp)          If mp = 1            ; On met la première ligne en gras et en rouge            TOM_SetFontStyles(ReGadget, "ForeColor(" + GetPBBStringParameter("PBBSetValueColor") + "), Bold", mp - 1, ep)            TOM_SetParaStyles(ReGadget, "SpaceAfter(6)", mp - 1, ep)          ElseIf Left(ExLine$, 2) = "• "            ; Les lignes avec un point sont décalées à droite            ; et se voient appliquer un offset (retrait de la            ; première ligne).            TOM_SetParaStyles(ReGadget, "LeftIndent(15), FirstLineIndent(-8)", mp - 1, ep)          EndIf        Until p = 0      EndIf      TOM_SetSelectionPos(ReGadget, 0, 0)      PBB_SuspendRedraw(ReGadget, #False)    EndIf  EndIfEndProcedure;Procedure FillListGadget(NoGadget, TextList$)  ;  ; Remplit le ListViewGadget(NoGadget... avec les titres  ; dont les noms figurent dans 'TextList$' ou dans la liste  ; des commandes.  ;  Protected NoLine, LName$, TitleName$  ;  If TextList$ = #FromCommandList$    ; Les titres sont à récupérer dans la liste des commandes.    ; On parcours la liste pour en extraire les noms :    ForEach CommandList()      TitleName$ = GetTranslatedCommandName(CommandList()\CommandNo)      AddGadgetItem(NoGadget, -1, TitleName$)    Next  Else    ; Les titres sont à extraire de la liste TextList$    ; et devront être traduits à l'aide du 'catalog'.    NoLine = 0    Repeat      NoLine + 1      LName$ = StringField(TextList$, NoLine, ",")      If LName$        TitleName$ = GetTextFromCatalogPB(LName$)        AddGadgetItem(NoGadget, -1, TitleName$)      EndIf    Until LName$ = ""  EndIfEndProcedure;Procedure SetUpExplanationContent(EventMenu)  ;  ; Ajuste le contenu de THATGadgets\EExplanations en fonction  ; de la liste active ou en réaction à l'appui sur les flèches Up et Down.  ;  Shared THATGadgets.THATGadgetsStruct ; Pour permettre l'accès partagé aux numéros de gadgets                                       ;  Protected ListGadget, NoLine, Nlist$  ;  ListGadget = GetActiveGadget()  ; On tente d'identifier le ListViewGadget actuellement actif :  If ListGadget <> THATGadgets\TipsList And ListGadget <> THATGadgets\HelpList And ListGadget <> THATGadgets\ToolsList    ; Aucun gadget n'est actif. On va activer celui qui a une ligne sélectionnée.    If GetGadgetState(THATGadgets\TipsList) > -1      ListGadget = THATGadgets\TipsList    ElseIf GetGadgetState(THATGadgets\HelpList) > -1      ListGadget = THATGadgets\HelpList    ElseIf GetGadgetState(THATGadgets\ToolsList) > -1      ListGadget = THATGadgets\ToolsList    Else      ; Si aucune ligne n'est activée, on choisit THATGadgets\TipsList par défaut.      ListGadget = THATGadgets\TipsList    EndIf  EndIf  NoLine = GetGadgetState(ListGadget)  If EventMenu = #PBBMenu_Down : NoLine + 1 : EndIf  If EventMenu = #PBBMenu_Up   : NoLine - 1 : EndIf  If NoLine < 0    ; Suite à l'appui sur la touche 'UP', quand on est arrivé à la première    ; ligne d'un ListeViewGadet, on passe au précédent :    If ListGadget = THATGadgets\TipsList : ListGadget = THATGadgets\ToolsList    ElseIf ListGadget = THATGadgets\HelpList : ListGadget = THATGadgets\TipsList    ElseIf ListGadget = THATGadgets\ToolsList : ListGadget = THATGadgets\HelpList    EndIf    NoLine = CountGadgetItems(ListGadget) - 1  ElseIf NoLine > CountGadgetItems(ListGadget) - 1    ; Suite à l'appui sur la touche 'DOWN', quand on est arrivé à la dernière    ; ligne d'un ListeViewGadet, on passe au suivant :    If ListGadget = THATGadgets\TipsList : ListGadget = THATGadgets\HelpList    ElseIf ListGadget = THATGadgets\HelpList : ListGadget = THATGadgets\ToolsList    ElseIf ListGadget = THATGadgets\ToolsList : ListGadget = THATGadgets\TipsList    EndIf    NoLine = 0  EndIf  SetActiveGadget(ListGadget)  ; On désactive toutes les lignes des gadgets pour s'assurer  ; qu'une seule d'entre elles sera finalement sélectionnée :  SetGadgetState(THATGadgets\TipsList, -1)  SetGadgetState(THATGadgets\HelpList, -1)  SetGadgetState(THATGadgets\ToolsList, -1)  ; On ne sélectionne que celle-là :  SetGadgetState(ListGadget, NoLine)  ;  ; Les boutons THATGadgets\BExecute et THATGadgets\BShortcut  ; ne sont actifs que lorsque la ligne sélectionnée appartient  ; au ListView THATGadgets\ToolsList  If ListGadget = THATGadgets\ToolsList    HideGadget(THATGadgets\Shortcut, #False)    HideGadget(THATGadgets\TitleShortcut, #False)    HideGadget(THATGadgets\BShortcut, #False)    HideGadget(THATGadgets\XDontShow, #False)    HideGadget(THATGadgets\BExecute, #False)    Nlist$ = THATGadgets\ToolsList$  Else    HideGadget(THATGadgets\Shortcut, #True)    HideGadget(THATGadgets\TitleShortcut, #True)    HideGadget(THATGadgets\BShortcut, #True)    HideGadget(THATGadgets\XDontShow, #True)    HideGadget(THATGadgets\BExecute, #True)    If ListGadget = THATGadgets\TipsList      Nlist$ = THATGadgets\TipsList$    Else      Nlist$ = THATGadgets\HelpList$    EndIf  EndIf  ; On va chercher les explications correspondant à la ligne  ; finalement sélectionnée :  FillTHATReGadget(THATGadgets\EExplanations, Nlist$, NoLine + 1, THATGadgets\Shortcut, THATGadgets\XDontShow)  ResizeGadgetsTHAT()EndProcedure;Macro SetUpListGadget(TGadget, LGadget, GadgetTitleName, LText)  ;  ; Crée et applique les mêmes réglages aux trois titres de ListViewGadgets  ; et aux trois ListViewGadgets eux-mêmes.  ;  TGadget = TextGadget(#PB_Any, THATGadgets\Margins, 0, 1, 18, GetTextFromCatalogPB(GadgetTitleName))  LGadget = ListViewGadget(#PB_Any, THATGadgets\Margins, THATGadgets\TitleHeight, 1, 1, #PB_Editor_ReadOnly)  FillListGadget(LGadget, LText)EndMacro;Macro FontAndColorForTitles(TGadget)  SetGadgetColor(TGadget, #PB_Gadget_FrontColor, GetPBBNumParameter("PBBTitleColor"))  SetGadgetFont(TGadget, PBBTitleFont)EndMacro;Procedure THATProc()  ;  ; Affichage et gestion de la fenêtre 'Tips, Help And Tools' (THAT).  ;  Shared THATGadgets.THATGadgetsStruct ; Pour permettre l'accès partagé aux numéros de gadgets  ;  Protected Wwidth, Wheight ; Dimensions de la fenêtre.  Protected WParam, NoLine  Protected event, EventMenu, EventGadget  Protected OX, OY, *GadgetAdress, GadgetList$  ;  Wwidth = 600 : Wheight = 410  THATGadgets\Margins = 8  THATGadgets\ButtonHeight = 24  THATGadgets\TitleHeight = 18  Protected ParentWindowID = ComputeWinOrigins(@OX, @OY, WWidth, WHeight, GPBBGadgets\PBBWindow)  WParam = #PB_Window_Invisible | #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar  THATGadgets\WTHAT = OpenWindow(#PB_Any, OX, OY, Wwidth, Wheight, GetTextFromCatalogPB("ToolsWindowTitle"), WParam, ParentWindowID)  If THATGadgets\WTHAT    ApplyDarkModeToWindow(THATGadgets\WTHAT)    WindowBounds(THATGadgets\WTHAT, 480, 400, #PB_Ignore, #PB_Ignore)    StickyWindow(THATGadgets\WTHAT, 1)    ;    THATGadgets\TipsList$  = "PBShortCutsTitle,SearchLimitsTitle,CreateToolsTitle"    THATGadgets\HelpList$  = "AboutPBBrowserTitle,MainFileTitle,ChangeMainFileTitle,SearchLaunchTitle,SearchModTitle,NavigationTitle"    THATGadgets\ToolsList$ = #FromCommandList$    ;    SetUpListGadget(THATGadgets\TipsListTitle, THATGadgets\TipsList, "TipsListTitle", THATGadgets\TipsList$)    SetUpListGadget(THATGadgets\HelpListTitle, THATGadgets\HelpList, "HelpListTitle", THATGadgets\HelpList$)    SetUpListGadget(THATGadgets\ToolsListTitle, THATGadgets\ToolsList, "ToolsListTitle", THATGadgets\ToolsList$)    ;    THATGadgets\EExplanations = EditorGadget(#PB_Any, 1, 1, 1, 1, #PB_Editor_WordWrap)    SendMessage_(GadgetID(THATGadgets\EExplanations), #EM_SETTEXTMODE, #TM_RICHTEXT, 0)    SetGadgetColor(THATGadgets\EExplanations, #PB_Gadget_BackColor, $F0FDFD)    ;    THATGadgets\TitleShortcut = TextGadget(#PB_Any, 1, 1, 60, THATGadgets\ButtonHeight, GetTextFromCatalogPB("Shortcut") + ":")    SetGadgetFont(THATGadgets\TitleShortcut, PBBAllGadgetsFont)    THATGadgets\Shortcut = TextGadget(#PB_Any, 1, 1, 80, THATGadgets\ButtonHeight, "")    SetGadgetFont(THATGadgets\Shortcut, LoadFont(10, "Segoe UI", 7))    THATGadgets\BShortcut = ButtonGadget(#PB_Any, 1, 1, 70, THATGadgets\ButtonHeight, GetTextFromCatalogPB("Change"))    SetGadgetFont(THATGadgets\BShortcut, PBBAllGadgetsFont)    HideGadget(THATGadgets\TitleShortcut, #True)    HideGadget(THATGadgets\Shortcut, #True)    HideGadget(THATGadgets\BShortcut, #True)    THATGadgets\XDontShow = CheckBoxGadget(#PB_Any, 1, 1, 260, THATGadgets\ButtonHeight, GetTextFromCatalogPB("DontShowInMenu"))    SetGadgetFont(THATGadgets\XDontShow, PBBAllGadgetsFont)    HideGadget(THATGadgets\XDontShow, #True)    THATGadgets\BExecute = ButtonGadget(#PB_Any, 1, 1, 70, THATGadgets\ButtonHeight, GetTextFromCatalogPB("Execute"))    SetGadgetFont(THATGadgets\BExecute, PBBAllGadgetsFont)    HideGadget(THATGadgets\BExecute, #True)    THATGadgets\BQuit = ButtonGadget(#PB_Any, 1, 1, 80, THATGadgets\ButtonHeight, GetTextFromCatalogPB("Quit"), #PB_Button_Default)    SetGadgetFont(THATGadgets\BQuit, PBBAllGadgetsFont)    THATGadgets\BCopy = ButtonGadget(#PB_Any, 1, 1, 80, THATGadgets\ButtonHeight, GetTextFromCatalogPB("Copy"))    SetGadgetFont(THATGadgets\BCopy, PBBAllGadgetsFont)    ;    AddKeyboardShortcut(THATGadgets\WTHAT, #PB_Shortcut_Return, #PBBMenu_Return)    AddKeyboardShortcut(THATGadgets\WTHAT, #PB_Shortcut_Escape, #PBBMenu_Return)    AddKeyboardShortcut(THATGadgets\WTHAT, #PB_Shortcut_Control | #PB_Shortcut_S, #PBBMenu_SetShortcut)    AddKeyboardShortcut(THATGadgets\WTHAT, #PB_Shortcut_Up, #PBBMenu_Up)    AddKeyboardShortcut(THATGadgets\WTHAT, #PB_Shortcut_Down, #PBBMenu_Down)    ForEach CommandList()      If CommandList()\CommandShortCut        AddKeyboardShortcut(THATGadgets\WTHAT, CommandList()\CommandShortCut, CommandList()\CommandNo + 20)      EndIf    Next    ;    ResizeGadgetsTHAT()    BindEvent(#PB_Event_SizeWindow, @ResizeGadgetsTHAT(), THATGadgets\WTHAT)    ClearKeyboardBuffer(THATGadgets\WTHAT)    ;    *GadgetAdress = @THATGadgets\TipsListTitle    Repeat      GadgetList$ + Str(PeekI(*GadgetAdress)) + ","      *GadgetAdress + SizeOf(Integer)    Until *GadgetAdress > @THATGadgets\BQuit    ;    ApplyFontToGadgetList(GadgetList$)    ;    SetGadgetsColorsFromTheme(THATGadgets\WTHAT, InterfaceColorPresets(), GadgetList$)    ;    FontAndColorForTitles(THATGadgets\TipsListTitle)    FontAndColorForTitles(THATGadgets\HelpListTitle)    FontAndColorForTitles(THATGadgets\ToolsListTitle)    ;    SetGadgetColor(THATGadgets\EExplanations, #PB_Gadget_BackColor, GetValueFromBPPrefFile("BackgroundColor"))    FillTHATReGadget(THATGadgets\EExplanations, "AboutTHATTitle", 1, THATGadgets\Shortcut, THATGadgets\XDontShow)    ;    ; ---------------------------------------------------    ;    ; The window was invisible until now, because we created it with #PB_Window_Invisible.    ; We make it visible now.    HideWindow(THATGadgets\WTHAT, #False)    ;    Repeat      ;      event = WaitWindowEvent()      If EventWindow() <> THATGadgets\WTHAT        SetActiveWindow(THATGadgets\WTHAT)      Else        If GetActiveGadget() = THATGadgets\EExplanations          ; On emploie un moyen simple pour désactiver le curseur-clignotant dans le gadget 'read-only'.          If GetGadgetState(THATGadgets\ToolsList) > -1            SetActiveGadget(THATGadgets\BShortcut)          Else            SetActiveGadget(THATGadgets\BQuit)          EndIf        EndIf        ;        If event = #PB_Event_SizeWindow          ResizeGadgetsTHAT()        ElseIf event = #PB_Event_CloseWindow          Break        ElseIf event = #PB_Event_Menu          EventMenu = EventMenu()          If EventMenu = #PBBMenu_Return            Break          ElseIf EventMenu = #PBBMenu_Up Or EventMenu = #PBBMenu_Down            SetUpExplanationContent(EventMenu)          ElseIf EventMenu = #PBBMenu_SetShortcut            SetPBBShortcut()            SetUpExplanationContent(0)          ElseIf EventMenu > 19            ExecCommandFromTHATWindow(EventMenu - 20)          EndIf        ElseIf event = #PB_Event_Gadget          EventGadget = EventGadget()          If EventGadget = THATGadgets\BQuit            Break          ElseIf EventGadget = THATGadgets\BCopy            TOM_Copy(THATGadgets\EExplanations, 0, -1)          ElseIf EventGadget = THATGadgets\TipsList Or EventGadget = THATGadgets\HelpList Or EventGadget = THATGadgets\ToolsList            SetUpExplanationContent(0)          ElseIf EventGadget = THATGadgets\XDontShow            NoLine = GetGadgetState(THATGadgets\ToolsList) + 1            If NoLine > 0              SetCommandDontShow(NoLine, GetGadgetState(THATGadgets\XDontShow))            EndIf          ElseIf EventGadget = THATGadgets\BShortcut            SetPBBShortcut()            SetUpExplanationContent(0)          ElseIf EventGadget = THATGadgets\BExecute             NoLine = GetGadgetState(THATGadgets\ToolsList) + 1            If NoLine > 0              ExecCommandFromTHATWindow(NoLine)            EndIf          EndIf        EndIf      EndIf    ForEver    ClearKeyboardBuffer(THATGadgets\WTHAT)    CloseWindow(THATGadgets\WTHAT)    ProcedureReturn #True  EndIfEndProcedure; IDE Options = PureBasic 6.20 Beta 4 (Windows - x64); CursorPosition = 207; FirstLine = 82; Folding = Egn8-; EnableXP; DPIAware; UseMainFile = ..\..\PBBrowser.pb