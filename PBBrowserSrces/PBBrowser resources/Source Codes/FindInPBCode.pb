;***********************************************************************;;                            FindInPBCode.pb;                       Part of PBBrowser project;                           Zapman - Dec 2024;; Set of functions to find and replace strings into a PureBasic codefile.;;***********************************************************************;;Global ListPBSepWithoutEndChars$ = " ,();+-=" + #DOUBLEQUOTE$ + "/*\><@{}|~[]&.!?"Global ListPBSep$ = ":" + #CR$ + ListPBSepWithoutEndChars$;Enumeration CheckModesForFindInPBCode  #NoCheck  #CheckOnlyLeft  #CheckOnlyRight  #CheckOnlyLeftAndRight  #CheckOnlyComAndQuote  #CheckLeftAndComAndQuote  #CheckRightAndComAndQuote  #CheckAll  #CheckOneKeyWordOnlyEndEnumeration;Procedure FindInPBPointedCode(*SearchString.String, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Searches for keywords in a PureBasic code page, ensuring that they are not  ; placed within comments or quotes.  ;  ; KeywordList$ can contain multiple words separated by commas, such as  ; "IncludeFile,XIncludeFile", in which case the first word found  ; in this list will determine the return position.  ;  ; If you want to include a comma in one of the words in KeywordList$,  ; replace the comma with the expression "\comma_". Alternatively, if you are searching  ; for only a single expression, assign the value '#CheckOneKeyWordOnly' to 'CheckMode'  ; and commas will no longer be considered as keyword separators.  ; #CheckOneKeyWordOnly can be combined with all other values of the enumeration  ; 'CheckModesForFindInPBCode'. For example: #CheckOnlyLeft|#CheckOneKeyWordOnly  ;  ; The enumeration CheckModesForFindInPBCode lists the different verification possibilities  ; that will be performed on the searched string.  ; If CheckMode equals 1, 5, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its left side (the list of valid separators  ; is defined by the global variable ListPBSep$, defined a little earlier).  ; If CheckMode equals 2, 6, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its right side.  ; If CheckMode equals 4, 5, or 7, the string will only be considered found if it is  ; not within a comment or between quotes.  ;  ; Instead of passing the 'SearchString' parameter as a string, which can  ; consume memory and time if the string is long, we work  ; with a pointer to a String structure. Thus, the string is not  ; duplicated in memory when the call is made.  ;  Protected SimpleSearch, FirstKeyword$, FirstKeywordPos, nl, Keyword$  Protected posdepR, p, ppv, nbg, TestS$  ;  If CheckMode & #CheckOneKeyWordOnly Or FindString(KeywordList$, ",") = 0    FirstKeyword$ = KeywordList$    SimpleSearch = 1  Else    SimpleSearch = 0  EndIf  ;  SearchFurtherLabel:   ;  If *SearchString = 0    Debug "Empty pointer"    CallDebugger    ProcedureReturn  EndIf  If SimpleSearch    p = FindString(*SearchString\s, FirstKeyword$, posdep, FMode)  Else    FirstKeyword$ = ""    FirstKeywordPos = 0    nl = 1    Repeat      Keyword$ = StringField(KeywordList$, nl, ",")      If Keyword$        Keyword$ = ReplaceString(Keyword$, "\comma_", ",")        p = FindString(*SearchString\s, Keyword$, posdep, FMode)        If p And ((p - Len(Keyword$) < FirstKeywordPos - Len(FirstKeyword$)) Or FirstKeywordPos = 0)          FirstKeywordPos = p          FirstKeyword$ = Keyword$        EndIf      EndIf      nl + 1    Until Keyword$ = ""    p = FirstKeywordPos  EndIf  ;  If p    ; First, we check that the found word is properly surrounded by valid separators.    If (CheckMode & #CheckOnlyLeft And p > 1 And FindString(ListPBSep$, FastMid(*SearchString\s, p - 1, 1), 0) = 0) Or (CheckMode & #CheckOnlyRight And (p + Len(FirstKeyword$) < Len(*SearchString\s)) And FindString(ListPBSep$, FastMid(*SearchString\s, p + Len(FirstKeyword$), 1), 0) = 0)      ; At least one of the separators is not valid.      posdep = p + Len(FirstKeyword$)      Goto SearchFurtherLabel ; Restart the search.    EndIf    ;    If CheckMode & #CheckOnlyComAndQuote      ;      ; Examine what is between the start of the line and the found string:      ;      posdepR = p      ; Go back to the beginning of the line:      While posdepR > 0 And PeekC(@*SearchString\s + (posdepR - 1) * SizeOf(CHARACTER)) <> #CR        posdepR - 1      Wend      posdepR + 1      ;      If posdepR > posdep : posdep = posdepR : EndIf ; Adjust the start position for the next search      ;      ; Check if we are at the start of the line (otherwise, there's no need to continue testing).      If p - posdepR > 0        ; Extract the existing text segment between the start of the line and the found position.        TestS$ = Trim(FastMid(*SearchString\s, posdepR, p - posdepR))        If TestS$          ; Check that the found string is not a comment.          If FastLeft(TestS$, 1) = ";"            posdep = FindString(*SearchString\s, #CR$, posdep + ppv) ; Search for the carriage return following it.            If posdep = 0              p = 0            Else              Goto SearchFurtherLabel ; Restart the search.            EndIf          EndIf          If p            ppv = 0            Repeat              ; Search for a ";" between the start of the line and the found position              ppv = FindString(TestS$, ";", ppv + 1)              If ppv                ; Check that the semicolon found is not between quotes.                ; By counting the number of quotes in the segment TestS$.                nbg = CountString(Mid(TestS$, 1, ppv), #DOUBLEQUOTE$)                If Not (nbg & 1) ; There is an even number of quotes or none at all.                  ; The found string is a comment. We cannot consider it valid.                  posdep = FindString(*SearchString\s, #CR$, posdep + ppv) ; Search for the carriage return following it.                  If posdep = 0 : p = 0 : Break : EndIf                  Goto SearchFurtherLabel ; Restart the search.                EndIf              EndIf            Until p = 0 Or ppv = 0          EndIf          ;          If p            ; Check that the searched string is not inside quotes.            ; By counting the number of quotes in the segment TestS$.            nbg = CountString(TestS$, #DOUBLEQUOTE$)            If nbg & 1 ; There is an odd number of quotes.              ; The found string is therefore inside quotes. We cannot consider it valid.              posdep = p + 2              Goto SearchFurtherLabel ; Restart the search.            EndIf          EndIf        EndIf      EndIf    EndIf  EndIf  ProcedureReturn pEndProcedure;Procedure FindInPBStringCode(SearchString$, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Identical to FindInPBPointedCode with a search on a regular string  ; passed as a parameter.  ; This can be more convenient for short strings.  ;  Protected SearchString.String\s = SearchString$  ;  ProcedureReturn FindInPBPointedCode(SearchString, KeywordList$, posdep, CheckMode, FMode)EndProcedure;Procedure ReverseFindInPBCode(txt$, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Searches for keywords in a PureBasic code page, ensuring that they are not  ; placed within comments or quotes.  ;  ; KeywordList$ can contain multiple words separated by commas, like  ; for example "IncludeFile,XIncludeFile", in which case, the first word found  ; will determine the return position.  ;  ; Unlike the FindInPBCode() procedure, this one searches for the keyword(s)  ; UPSTREAM (before) the position posdep. It is a reverse search.  ;  ; If you want to include a comma in one of the words in the KeywordList$  ; replace the comma with the expression "\comma_". Or, if you are only searching  ; for a single expression, assign the value '#CheckOneKeyWordOnly' to 'CheckMode'  ; and commas will no longer be considered as keyword separators.  ; #CheckOneKeyWordOnly can be combined with any other values from the  ; 'CheckModesForFindInPBCode' enumeration. For example: #CheckOnlyLeft|#CheckOneKeyWordOnly  ;  ; The CheckModesForFindInPBCode enumeration lists the various verification options  ; that will be applied to the searched string.  ; If CheckMode is 1, 5, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its left side (the list of valid separators  ; is defined by the global variable ListPBSep$, defined a little higher).  ; If CheckMode is 2, 6, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its right side.  ; If CheckMode is 4, 5, or 7, the string will only be considered found if it is  ; not inside a comment or between quotes.  ;  ; Note: 'ReverseFindInPBCode()' uses a reversed (and thus modified)  ; version of the 'txt$' string passed as a parameter. It is stored in 'Static' to  ; avoid wasting time calculating a ReverseString() on each call.  ;  Static SearchString$  ;    Protected FirstKeyword$, FirstKeywordPos, nl, Keyword$, cg$  Protected posdepR, p, ppv, nbg, SimpleSearch, SStringLength  ;  If txt$    ; If the procedure is called multiple times, we can avoid passing the first    ; parameter after the first call, because SearchString$ is a 'Static' variable    ; (kept in memory).    ; This can save time when working with a large string,    ; because even though ReverseString() is fast, it still takes some time.    SearchString$ = ReverseString(txt$)  EndIf  ;  If KeywordList$    If Right(KeywordList$, 1) = "," : KeywordList$ = Left(KeywordList$, Len(KeywordList$) - 1) : EndIf    KeywordList$ = ReverseString(KeywordList$)    ;    SStringLength = Len(SearchString$)    If posdep      posdep = SStringLength - posdep + 1    EndIf    ;    If CheckMode & #CheckOneKeyWordOnly Or FindString(KeywordList$, ",") = 0      FirstKeyword$ = KeywordList$      SimpleSearch = 1    Else      SimpleSearch = 0    EndIf    ;    ;    ReverseSearchFurtherLabel:     If SimpleSearch      FirstKeywordPos = FindString(SearchString$, KeywordList$, posdep, FMode)    Else      FirstKeyword$ = ""      FirstKeywordPos = 0      nl = 1      Repeat        Keyword$ = StringField(KeywordList$, nl, ",")        If Keyword$          Keyword$ = ReplaceString(Keyword$, "\comma_", ",")          p = FindString(SearchString$, Keyword$, posdep, FMode)          If p And ((p - Len(Keyword$) < FirstKeywordPos - Len(FirstKeyword$)) Or FirstKeywordPos = 0)            FirstKeywordPos = p            FirstKeyword$ = Keyword$          EndIf        EndIf        nl + 1      Until Keyword$ = ""    EndIf    ;    ;    If FirstKeywordPos        p = FirstKeywordPos + Len(FirstKeyword$)        ; First, we check that the found keyword is properly surrounded by valid separators.      If (CheckMode & #CheckOnlyRight And p <= SStringLength And FindString(ListPBSep$, FastMid(SearchString$, p, 1), 0) = 0) Or (CheckMode & #CheckOnlyLeft And p - Len(FirstKeyword$) - 1 > 0 And FindString(ListPBSep$, FastMid(SearchString$, p - Len(FirstKeyword$) - 1, 1), 0) = 0)        ; At least one of the separators is invalid.        posdep = p        Goto ReverseSearchFurtherLabel ; Restart the search.      EndIf      ;      If CheckMode & #CheckOnlyComAndQuote        ;        posdepR = FindString(SearchString$, #CR$, p) ; Move to the start of the line (in normal order).        If posdepR = 0 : posdepR = SStringLength + 1 : EndIf        ;        If posdepR > p          cg$ = FastMid(SearchString$, p, posdepR - p) ; Extract the segment between the found expression and the start of the line.          ppv = FindString(cg$, ";")          If ppv            ; Extract the segment between the semicolon and the start of the line,            ; and count the number of quotes in the segment.            nbg = CountString(FastMid(cg$, ppv), #DOUBLEQUOTE$)            If Not (nbg & 1) ; There are no quotes or an even number of quotes.               ; The expression has been found inside a comment. It doesn't work.              posdep = p + ppv - 1 ; Move back to before the start of the comment (in normal order).              Goto ReverseSearchFurtherLabel ; Restart the search.            EndIf          EndIf          ;          ; Now check if the found expression is not inside quotes:          ;          ; Count the quotes between the start of the line and the expression          ; (i.e., in reverse order, between the expression and posdepR).          nbg = CountString(cg$, #DOUBLEQUOTE$)          If nbg & 1 ; There is an odd number of quotes. The expression is therefore inside quotes.                   ; Move back before the quotes (in normal order),                   ; that is, after the quotes in reverse order.            posdep = FirstOccurrenceOfChar(SearchString$, #DOUBLEQUOTE$ + #CR$ + ":", p) + 1             If posdep              Goto ReverseSearchFurtherLabel ; Restart the search.            Else              ProcedureReturn 0            EndIf          EndIf        EndIf      EndIf      If p        ProcedureReturn SStringLength - p + 2      EndIf    EndIf  EndIfEndProcedure;Procedure FindReplaceInPBPointedCode(*SearchString.String, KeywordList$, ReplaceKeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Searches for keyword(s) in a PureBasic code page, ensuring that they are not  ; placed within comments or quotes. Then replace the keyword(s) by something  ; figuring in ReplaceKeywordList$.  ;  ; KeywordList$ can contain multiple words separated by commas, such as  ; "IncludeFile,XIncludeFile".  ;  ; If you want to include a comma in one of the words in KeywordList$, or ReplaceKeywordList$,  ; replace the comma with the expression "\comma_". Alternatively, if you are searching  ; for only a single expression, assign the value '#CheckOneKeyWordOnly' to 'CheckMode'  ; and commas will no longer be considered as keyword separators.  ; #CheckOneKeyWordOnly can be combined with all other values of the enumeration  ; 'CheckModesForFindInPBCode'. For example: #CheckOnlyLeft|#CheckOneKeyWordOnly  ;  ; The enumeration CheckModesForFindInPBCode lists the different verification possibilities  ; that will be performed on the searched string.  ; If CheckMode equals 1, 5, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its left side (the list of valid separators  ; is defined by the global variable ListPBSep$, defined a little earlier).  ; If CheckMode equals 2, 6, or 7, the string will only be considered found if it is  ; bordered by a valid separator on its right side.  ; If CheckMode equals 4, 5, or 7, the string will only be considered found if it is  ; not within a comment or between quotes.  ;  ; Instead of passing the 'SearchString' parameter as a string, which can  ; consume memory and time if the string is long, we work  ; with a pointer to a String structure. Thus, the string is not  ; duplicated in memory when the call is made.  ;  ; ReplaceKeywordList$ can contain many or only one word(s).  ; If KeywordList$ contains a list of words separated by commas, ReplaceKeywordList$  ; can contain a list of corresponding words to replace to, also separated by commas.  ; If ReplaceKeywordList$ contains a unic word, all the words contained by KeywordList$  ; will be replaced by this unic word.  ; If ReplaceKeywordList$ is empty, the words contained by KeywordList$ will be erased  ; from the text.  ;  Protected Rep = 0, SimpleSearch, mposdep, nl, Keyword$, RKeyword$  ;  If CheckMode & #CheckOneKeyWordOnly Or FindString(KeywordList$, ",") = 0    SimpleSearch = 1  Else    SimpleSearch = 0  EndIf  ;  If *SearchString = 0    Debug "Empty pointer"    CallDebugger    ProcedureReturn  EndIf  ;  mposdep = posdep  ;  nl = 0  RKeyword$ = ReplaceKeywordList$  Repeat    nl + 1    If SimpleSearch      Keyword$ = KeywordList$    Else      Keyword$ = StringField(KeywordList$, nl, ",")      If FindString(ReplaceKeywordList$, ",")        RKeyword$ = StringField(ReplaceKeywordList$, nl, ",")      EndIf    EndIf    If Keyword$      Keyword$ = ReplaceString(Keyword$, "\comma_", ",")      posdep = mposdep      Repeat        posdep = FindInPBPointedCode(*SearchString, Keyword$, posdep, CheckMode, FMode)        If posdep          *SearchString\s = FastLeft(*SearchString\s, posdep - 1) + RKeyword$ + FastMid(*SearchString\s, posdep + Len(Keyword$))          Rep + 1          posdep + Len(RKeyword$)        EndIf      Until posdep = 0    EndIf  Until Keyword$ = "" Or SimpleSearch  ;  ProcedureReturn RepEndProcedure;Procedure.s FindReplaceInPBStringCode(SearchString$, SearchKeyword$, ReplaceKeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Identical to FindReplaceInPBPointedCode with a search on a regular string  ; passed as a parameter.  ; This can be more convenient for short strings.  ;  Protected SearchString.String\s = SearchString$  ;  FindReplaceInPBPointedCode(SearchString, SearchKeyword$, ReplaceKeywordList$, posdep, CheckMode, FMode)  ;  ProcedureReturn SearchString.String\sEndProcedure;; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 119; FirstLine = 90; Folding = l; EnableXP; DPIAware; UseMainFile = ..\..\PBBrowser.pb